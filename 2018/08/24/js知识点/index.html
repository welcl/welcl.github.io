<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="一:jsonp实现跨域获取数据:参考:https://blog.csdn.net/hansexploration/article/details/80314948 参考:https://www.cnblogs.com/chiangchou/p/jsonp.html 这里列举下实现jsonp跨域的一个demo:     首先,你必须要有两个不同的协议,域名,端口都不同的url,只有这样才符合要跨域的">
<meta property="og:type" content="article">
<meta property="og:title" content="js知识点">
<meta property="og:url" content="http://yoursite.com/2018/08/24/js知识点/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一:jsonp实现跨域获取数据:参考:https://blog.csdn.net/hansexploration/article/details/80314948 参考:https://www.cnblogs.com/chiangchou/p/jsonp.html 这里列举下实现jsonp跨域的一个demo:     首先,你必须要有两个不同的协议,域名,端口都不同的url,只有这样才符合要跨域的">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2018/08/24/js知识点/location.jpg">
<meta property="og:updated_time" content="2018-12-25T05:38:25.362Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js知识点">
<meta name="twitter:description" content="一:jsonp实现跨域获取数据:参考:https://blog.csdn.net/hansexploration/article/details/80314948 参考:https://www.cnblogs.com/chiangchou/p/jsonp.html 这里列举下实现jsonp跨域的一个demo:     首先,你必须要有两个不同的协议,域名,端口都不同的url,只有这样才符合要跨域的">
<meta name="twitter:image" content="http://yoursite.com/2018/08/24/js知识点/location.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/24/js知识点/"/>





  <title>js知识点 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/24/js知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">js知识点</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-24T16:40:34+08:00">
                2018-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="一-jsonp实现跨域获取数据"><a href="#一-jsonp实现跨域获取数据" class="headerlink" title="一:jsonp实现跨域获取数据:"></a>一:jsonp实现跨域获取数据:</h3><pre><code>参考:https://blog.csdn.net/hansexploration/article/details/80314948
参考:https://www.cnblogs.com/chiangchou/p/jsonp.html
这里列举下实现jsonp跨域的一个demo:
    首先,你必须要有两个不同的协议,域名,端口都不同的url,只有这样才符合要跨域的基本条件,

    在localhost:8080端口的index.html下:
        .......
              &lt;head&gt;
                &lt;meta charset=&quot;utf-8&quot;&gt;
                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
                &lt;title&gt;shoppingSystem&lt;/title&gt;
                &lt;script src=&quot;http://code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt;
                &lt;script type=&quot;text/javascript&quot;&gt;
                    var localHandler = function(data){
                        alert(&apos;我是本地函数，可以被跨域的jsonp.js文件调用，远程js带来的数据是：&apos; + data.result);
                      };
                      var url = &quot;http://localhost:3000/jsonp.js&quot;;
                      // 创建script标签，设置其属性
                      var script = document.createElement(&apos;script&apos;);
                      script.setAttribute(&apos;src&apos;, url);
                      // 把script标签加入head，此时调用开始
                      document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);
                    &lt;/script&gt;
                &lt;!--&lt;/script&gt;--&gt;
              &lt;/head&gt;
        ......

    在localhost:3000端口下的jsonp.js下:
        localHandler({&quot;result&quot;,&quot;我是后端返回的数据&quot;});

    此时页面就会弹出:    我是本地函数，可以被跨域的jsonp.js文件调用，远程js带来的数据是：我是后端返回的数据证明跨域
    请求成功了!剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用,jQuery如何实现jsonp调用？

    在localhost:8080端口的index.html下:
        jQuery(document).ready(function(){
                $.ajax({
                     type: &quot;get&quot;,
                     async: false,
                     url: &quot;http://localhost:3000/jsonp.js&quot;,
                     dataType: &quot;jsonp&quot;,
                     jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
                     jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，
                                                                            //jQuery会自动为你处理数据
                     success: function(json){
                         alert(&apos;您查询到航班信息：票价： &apos; + json.price + &apos; 元，余票： &apos; + json.tickets + &apos; 张。&apos;);
                     },
                     error: function(){
                         alert(&apos;fail&apos;);
                     }
                 });
             });

        在localhost:3000端口下的jsonp.js下:
            flightHandler({
              &quot;code&quot;: &quot;CA1998&quot;,
              &quot;price&quot;: 1780,
              &quot;tickets&quot;: 5
            });

        当页面中弹出您查询到航班信息：票价： 1780  元，余票： 5 张。
</code></pre><h3 id="二-冒泡排序-选择排序-插入排序-数组去重"><a href="#二-冒泡排序-选择排序-插入排序-数组去重" class="headerlink" title="二:冒泡排序,选择排序,插入排序,数组去重:"></a>二:冒泡排序,选择排序,插入排序,数组去重:</h3><h4 id="去重排序"><a href="#去重排序" class="headerlink" title="去重排序"></a>去重排序</h4><pre><code>// 方法1:利用indexOf()
Array.prototype.removeRepeat=function(){
    var result=[];
    for(var i=0;i&lt;this.length;i++){
        if(result.indexOf(this[i])==-1){
            result.push(this[i]);
        }
    }
    return result;
};
var arr=[1,2,2,5,&quot;测试&quot;,&quot;test&quot;,&quot;测试&quot;];
console.log(arr.removeRepeat());

// 方法2:利用对象的key值是否存在判断
Array.prototype.removeRepeat=function(){
    var result=[];
    var obj={};
    for(var i=0;i&lt;this.length;i++){
       if(!obj[this[i]]){
            result.push(this[i]);
            obj[this[i]]=1;
       }
    }
    return result;
};
var arr=[1,2,2,5,&quot;测试&quot;,&quot;test&quot;,&quot;测试&quot;];
console.log(arr.removeRepeat());
</code></pre><h4 id="冒泡排序、插入排序、选择排序合称为简单排序。"><a href="#冒泡排序、插入排序、选择排序合称为简单排序。" class="headerlink" title="冒泡排序、插入排序、选择排序合称为简单排序。"></a>冒泡排序、插入排序、选择排序合称为简单排序。</h4><pre><code>//升序排序:
方法1:利用sort方法排序
var quickSort=function(arr){
    function sortNumber(a,b){
        return a-b;
    }
    return arr.sort(sortNumber);
};
arr=[1,4,65,21,2,222,111];
console.log(quickSort(arr));

//方法2:/***冒泡排序法***/
//假设从大到小排序:
//冒泡排序就是第一次循环时:从第一个元素开始和相邻后边元素比较,如果大于后一个元素,则和后一个元素互换位置
//如果小于后一个元素,则用后一个元素和其相邻的后一个元素再比较,直到最后一个元素为当前数组中最大的元素
var quickSort=function(arr){
    var temp;
    for(var i=0;i&lt;arr.length-1;i++){
        for(var j=0;j&lt;arr.length-i-1;j++){
            if(arr[j]&gt;arr[j+1]){
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
    }
    return arr;
};
arr=[1,4,65,21,2,222,111];
console.log(quickSort(arr));
</code></pre><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><pre><code>//选择排序假设从大到小排序:
// 第一轮:首先先假设第一个元素的下标a[0]为记录的位置,当后边的元素大于这个记录的元素时,
//更改记录的位置下标为大的元素的下标,以此类推,直到第一次循环找出最大元素的下标,然后把最大元素的和
// 假设的第一个元素互换位置.
//第二轮:重复第一轮过程,只不过此时假设第一个元素的下标为a[1],
var quickSort=function(arr){
    //因为数组没有直接获取最大值的方法,所以利用apply函数调用Math的max方法(虽然这里没有用到,但是要知道apply用法)
    // var max=Math.max.apply(null,arr);
    // console.log(max);
    var temp;
    var index;
    for(var i=0;i&lt;arr.length;i++){
        index=i;//这个就是假设第一个元素的下标
            for(var j=i+1;j&lt;arr.length;j++){
                if(arr[index]&lt;arr[j]){
                    index=j;//这个就是最大元素的下标
                }
            }
            //互换位置
            temp=arr[index];
            arr[index]=arr[i];
            arr[i]=temp;
    }
    return arr;
};
arr=[1,4,65,21,2,222,111];
console.log(quickSort(arr));
</code></pre><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序:"></a>插入排序:</h5><pre><code>// 在一个数组中我们不知道哪个是最小值，那么就假定第一个就是最小值，然后取第二个值与第一个值比较,产生排序后的序列，
// 然后再取第三个值与排序后的序列进行比较插入到对应的位置，依次类推。
var quickSort=function(arr){
    var key;
    for(var i=1;i&lt;arr.length;i++){
         key=arr[i];
         var  j=i-1;
         while(arr[j]&gt;key){
             arr[j+1]=arr[j];
             j--;
         }
         arr[j+1]=key;
    }
    return arr;
};
arr=[1,4,65,21,2,222,111];
console.log(quickSort(arr));
</code></pre><h3 id="三-阻止冒泡事件和默认事件"><a href="#三-阻止冒泡事件和默认事件" class="headerlink" title="三:阻止冒泡事件和默认事件:"></a>三:阻止冒泡事件和默认事件:</h3><pre><code>        在jQuery中使用return false时，相当于同时使用event.preventDefault(阻止默认事件)和event.stopPropagation(阻止冒泡事件)，
它会阻止冒泡也会阻止默认行为。但是使用原生js写时，return false只会阻止默认行为。
</code></pre><h3 id="四-闭包"><a href="#四-闭包" class="headerlink" title="四:闭包:"></a>四:闭包:</h3><pre><code>参考:https://www.cnblogs.com/gitbo/p/6597733.html
参考:https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449934543461c9d5dfeeb848f5b72bd012e1113d15000
</code></pre><h4 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1.什么是闭包;"></a>1.什么是闭包;</h4><pre><code>专业说法：
        当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。
还可以这么理解：
        闭包就是一个具有封闭功能与包裹功能的结构，是为了实现具有私有访问空间的函数的，函数可以构成闭包，
        因为函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数
        可以构成闭包。建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量
 函数套函数就是闭包吗？不是！，当一个内部函数被其外部函数之外的变量引用时，才会形成了一个闭包。
 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
</code></pre><h4 id="2-闭包的作用"><a href="#2-闭包的作用" class="headerlink" title="2. 闭包的作用:"></a>2. 闭包的作用:</h4><pre><code>1.读取函数内部变量(一般情况下我们没法在函数外读取一个函数内的局部变量)
2.让变量值始终保持在内存里(可以延长局部变量的生命周期,封装私有变量)
3.避免污染全局变量(我们在函数内定义的a变量不会污染全局a变量)
</code></pre><h4 id="3-闭包的缺点"><a href="#3-闭包的缺点" class="headerlink" title="3.闭包的缺点"></a>3.闭包的缺点</h4><pre><code>    闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
    删除闭包中保存的变量。函数销毁（主动把函数赋为null或者页面卸载）可以释放内存
实例:
有权访问另一个函数作用域内变量的函数都是闭包。
这里 inc 函数访问了构造函数 a 里面的变量 n，所以形成了一个闭包。
    function a(){
        var n = 0;
        function inc(){
           n++;
           console.log(n);
        }
        return inc;
    }
    var c = a();
    c();    //控制台输出1
    c();    //控制台输出2
看看是怎么执行的：
var c = a()，这一句 a()返回的是函数 inc，那这句等同于 var c = inc;
c()，这一句等同于 inc();  注意，函数名只是一个标识（指向函数的指针），而()才是执行函数。
后面三句翻译过来就是：  var c = inc;  inc();  inc();
 为啥要这样写呢:
    我们知道，js的每个函数都是一个个小黑屋，它可以获取外界信息，但是外界却无法直接看到里面的内容。将变量 n 放进小黑屋里，
    除了 inc 函数之外，没有其他办法能接触到变量 n,而且在函数 a 外定义同名的变量 n 也是互不影响的，这就是所谓的增强“封装性”。
    而之所以要用 return 返回函数标识 inc，是因为在 a 函数外部无法直接调用 inc 函数，所以 return inc 与外部联系起来.
 实例:
    //常见的闭包陷阱:返回10个10
        function createFunctions(){
            var result = new Array();
            for (var i=0; i &lt; 10; i++){
                result[i] = function(){
                    return i;
                };
            }
            return result;
        }
        var funcs = createFunctions();
        console.log(funcs);
        for (var i=0; i &lt; funcs.length; i++){
            console.log(funcs[i]());
        }
        // //正常的闭包:返回0~9
        function createFunctions1(){
            var result = new Array();
            for (var i=0; i &lt; 10; i++){
                result[i] = (function(n){
                    return function(){
                        return n;
                    };
                })(i);
            }
            return result;
        }
        var funcs1= createFunctions1();
        console.log(funcs1);
        for (var i=0; i &lt; funcs1.length; i++){
            console.log(funcs1[i]());
        }
</code></pre><h3 id="五-原型和原型链"><a href="#五-原型和原型链" class="headerlink" title="五.原型和原型链:"></a>五.原型和原型链:</h3><pre><code>要了解:构造函数,原型对象,实例对象之间的关系:
普通对象
        最普通的对象：有__proto__属性（指向其原型链），没有prototype属性。
        原型对象(person.prototype 原型对象还有constructor属性（指向构造函数对象）)
函数对象：
       凡是通过new Function()创建的都是函数对象。
       拥有__proto__、prototype属性（指向原型对象）。
        Function、Object、Array、Date、String、自定义函数
        特例： Function.prototype(是原型对象，却是函数对象，下面会有解释)
        参考:https://blog.csdn.net/sinat_21274091/article/details/52741788
</code></pre><h3 id="六-js是一门什么样的语言"><a href="#六-js是一门什么样的语言" class="headerlink" title="六.js是一门什么样的语言:"></a>六.js是一门什么样的语言:</h3><pre><code>js是脚本语言,解释性语言,弱类型语言,基于对象,动态语言
脚本语言:脚本语言是一个不需要显示编译的编程语言
解释性语言:当浏览器解析这行代码的时候,才知道这个变量具体是什么类型,
弱类型语言:声明都用var,没有其他类型的变量声明
基于对象:直接使用系统当中的对象,而不是自己创建对象
动态语言:动态语言是在运行时确定数据类型的语言
 扩展:
   静态语言是指在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型
   编译语言:需要把代码翻译成计算机所认知的二进制语言,才能够执行
</code></pre><h3 id="七-js代码注意问题"><a href="#七-js代码注意问题" class="headerlink" title="七:js代码注意问题:"></a>七:js代码注意问题:</h3><pre><code>1.在一对script的标签中有错误的js代码,那么该错误的代码后面的js代码不会执行
2.如果第一对的script标签中有错误,不会影响后面的script标签中的js代码执行
3.script标签一般是放在body的标签的最后的,这样浏览器渲染时先渲染html文件,之后才走script中的内容,可以提高效率
</code></pre><h3 id="八-js中的数据类型"><a href="#八-js中的数据类型" class="headerlink" title="八:js中的数据类型:"></a>八:js中的数据类型:</h3><pre><code>js中的原始数据类型:number,string,boolean,null,undefined,object
     * number:数字类型(整数和小数)
     * string:字符串类型(的值一般都是用单引号或者是双引号括起来)  &quot;34&quot;
     * boolean:布尔类型(值只有两个,true(真1),false(假0))
     * null:空类型,值只有一个:null,一个对象指向为空了,此时可以赋值为null
     * undefined:未定义,值只有一个:undefined
     * object:对象
基本类型(简单类型),值类型: number,string,boolean
复杂类型(引用类型):object
空类型:undefined,null

值类型的值在哪一块空间中存储? 栈中存储
引用类型的值在哪一块空间中存储?对象在堆上存储,地址在栈上存储

var num=10;//值类型,值在栈上
var obj={};//复杂类型,对象在堆,地址(引用)在栈

值类型之间传递,传递的是值
引用类型之间传递,传递的是地址(引用)

值类型作为函数的参数,传递的是值
引用类型作为函数的参数,传递的是地址

类型转换:
    一:其他类型转数字类型:
           总结:想要转整数用parseInt(),想要转小数用parseFloat()
                    想要转数字:Number();要比上面的两种方式严格
                    例如:
                            1.parseInt();//转整数  console.log(parseInt(&quot;10.98fdsfd&quot;));//10
                            2.parseFloat()//转小数 console.log(parseFloat(&quot;10.98fdsfd&quot;));//10.98
                            3.Number();//转数字  console.log(Number(&quot;10.98fdsfd&quot;));//NaN
    二:其他类型转字符串类型:
           如果变量有意义调用.toString()使用转换
           如果变量没有意义使用String()转换
           例如:
               1.变量无意义
                   var num2;
                   console.log(String(num2));
                   var num3=null;
                   console.log(String(num3));
               2.变量有意义
                   var num2=20;
                   console.log(num2.toString());
    三:其他类型转布尔类型:
        console.log(Boolean(1));//true
        console.log(Boolean(&quot;哈哈&quot;));//true
        console.log(Boolean(0));//false
        console.log(Boolean(&quot;&quot;));//false
        console.log(Boolean(null));//false
        console.log(Boolean(undefined));//false
     break关键字:如果在循环中使用,遇到了break,则立刻跳出当前所在的循环
     continue:在循环中如果遇到continue关键字,直接开始下一次循环
</code></pre><h3 id="九-基本包装类型"><a href="#九-基本包装类型" class="headerlink" title="九 基本包装类型:"></a>九 基本包装类型:</h3><pre><code>//基本包装类型

    //普通变量不能直接调用属性或者方法
    //对象可以直接调用属性和方法

    //基本包装类型:本身是基本类型,但是在执行代码的过程中,如果这种类型的变量调用了属性或者是方法,
    那么这种类型就不再是基本类型了,而是基本包装类型,这个变量也不是普通的变量了,而是基本包装类型对象
    基本包装类型对象:string number boolean
    例子:
        //    var str=&quot;hello&quot;;
        //    str=str.replace(&quot;ll&quot;,&quot;HH&quot;);
        //    console.log(str);

        //    var str=new String(&quot;hello&quot;);
        //    str=str.replace(&quot;ll&quot;,&quot;HH&quot;);
        //    console.log(str);
        //    str=null;

        //    var num=10;//number----&gt;
        //    console.log(num.toString());
</code></pre><h3 id="十-函数的相关知识点"><a href="#十-函数的相关知识点" class="headerlink" title="十 函数的相关知识点:"></a>十 函数的相关知识点:</h3><pre><code>一:函数需要先定义,然后才能使用
    函数名字:要遵循驼峰命名法
    函数一旦重名,后面的会把前面的函数覆盖
    命名函数:函数如果有名字,就是命名函数
     匿名函数:函数如果没有名字,就是匿名函数
    函数定义:
         * 1. 函数声明--函数定义
         * function 函数名(){
         *     函数体
         * }
         2.函数表达式:
              * 把一个函数给一个变量,此时形成了函数表达式
              * var 变量=匿名函数;
              * 例子:
              * var f1=function (){
              *
              * };
              * 如果是函数表达式,那么此时前面的变量中存储的就是一个函数,而这个变量就相当于是一个函数,就可以直接加小括号调用了
              * f1();
         3.函数的自调用,没有名字,调用---声明的同时,直接调用(一次性的)
                (function(){console.log(&quot;嘎嘎&quot;)})();

    1.函数可以作为参数使用,
        如果一个函数作为参数,那么我们说这个参数(函数)可以叫回调函数
       只要是看到一个函数作为参数使用了,那就是回调函数
    2.:函数是可以作为返回值使用的:(闭包)
             function f1() {
                   console.log(&quot;f1函数调用了&quot;);
                   return function () {
                     console.log(&quot;这是一个函数&quot;);
                   };
                 }
                 var ff=f1();//调用
                      //ff就是一个函数了
                 ff();

    Ctrl +鼠标左键----&gt;转到定义
    * 形参:函数定义的时候函数名字后面的小括号里的变量就是参数,是不需要写var
    * 实参:函数在调用的时候小括号里传入的值叫实参,实参可以是变量也可以是值
    * 如果一个函数中有return ,那么这个函数就有返回值
    * 如果一个函数中没有return,那么这个函数就没有返回值
    * 如果一个函数中没有明确的返回值,那么调用的时候接收了,结果就是undefined
    * (没有明确返回值:函数中没有return,函数中有return,但是return后面没有任何内容)
    arguments-----&gt;数组使用------伪数组---
        * arguments-----&gt;可以获取函数调用的时候,传入的实参的个数
        * arguments是一个对象,是一个伪数组
        * arguments.length---&gt;是实参的个数
        * arguments[索引]----&gt;实参的值
    function f1() {
          var sum=0;
          for(var i=0;i&lt;arguments.length;i++){
            sum+=arguments[i];
          }
          return sum;
        }
    console.log(f1(10,20,30));

二:作用域和作用域链:
        1.作用域：变量可以起作用的范围
            作用域:使用范围
            /*
            *
            * 全局变量:声明的变量是使用var声明的,那么这个变量就是全局变量,全局变量可以在页面的任何位置使用
            * 除了函数以外,其他的任何位置定义的变量都是全局变量
            * 局部变量:在函数内部定义的变量,是局部变量,外面不能使用
            * 全局变量,如果页面不关闭,那么就不会释放,就会占空间,消耗内存
            *
            * 全局作用域:全局变量的使用范围
            * 局部作用域:局部变量的使用范围
            *
            * 块级作用域:一对大括号就可以看成是一块,在这块区域中定义的变量,只能在这个区域中使用,但是在js中在这个块级作用域中定义的变量,外面也能使用;
            * 说明:js没有块级作用域,只有函数除外
            *
            * 隐式全局变量:声明的变量没有var,就叫隐式全局变量
            * 全局变量是不能被删除的,隐式全局变量是可以被删除的
            * 定义变量使用var是不会被删除的,没有var是可以删除的
            */
        2.作用域链:
            将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。
             var num=10;
                function f1() {
                  var num=20;
                  function f2() {
                    var num=30;
                    function f3() {
                      var num=50;
                      console.log(num);
                    }
                    f3();
                  }
                  f2();
                }
                f1();
三:预解析:
        1.提前解析代码
            * 预解析:就是在解析代码之前
            * 预解析做什么事?
            * 把变量的声明提前了----提前到当前所在的作用域的最上面
            * 函数的声明也会被提前---提前到当前所在的作用域的最上面
        2.预解析分段问题的局部作用域问题:         
            //预解析中,变量的提升,只会在当前的作用域中提升,提前到当前的作用域的最上面
             //函数中的变量只会提前到函数的作用域中的最前面,不会出去
             //预解析会分段(多对的script标签中函数重名,预解析的时候不会冲突)              
</code></pre><h3 id="十一object-对象-的相关知识"><a href="#十一object-对象-的相关知识" class="headerlink" title="十一object(对象)的相关知识:"></a>十一object(对象)的相关知识:</h3><pre><code>(js高级教程Number,String,Date,Array,Boolean,Math,RegExp)
          什么是对象:
              对象:有属性和方法,特指的某个事物
              对象:一组无序属性的集合的键值对,属性的值可以是任意的类型
      一:创建对象的方法:
              1.调用系统的构造函数创建对象
                   var 变量名= new Object(); Object 是系统的构造函数  Array

              2.自定义构造函数创建对象(结合第一种和需求通过工厂模式创建对象)
               *  //工厂模式创建对象
                      function createObject(name,age) {
                        var obj = new Object();//创建对象
                        //添加属性
                        obj.name = name;
                        obj.age = age;
                        //添加方法
                        obj.sayHi = function () {
                          console.log(&quot;阿涅哈斯诶呦,我叫:&quot; + this.name + &quot;我今年:&quot; + this.age);
                        };
                        return obj;
                      }
                      //创建人的对象
                      var per1 = createObject(&quot;小芳&quot;,20);
                      per1.sayHi();


                   自定义构造函数创建对象,我要自己定义一个构造函数,自定义构造函数,创建对象
                     函数和构造函数的区别；名字是不是大写(首字母是大写)
                      function Person(name,age) {
                        this.name=name;
                        this.age=age;
                        this.sayHi=function () {
                          console.log(&quot;我叫:&quot;+this.name+&quot;,年龄是:&quot;+this.age);
                        };
                      } 
                      //自定义构造函数创建对象:先自定义一个构造函数,创建对象
                      var obj=new Person(&quot;小明&quot;,10);
                      console.log(obj.name);
                      console.log(obj.age);
                      obj.sayHi();

                      自定义构造函数创建对象做了什么事?(new 的执行过程:)
                              * 1. 在内存中开辟(申请一块空闲的空间)空间,存储创建的新的对象
                              * 2. 把this设置为当前的对象
                              * 3. 设置对象的属性和方法的值
                              * 4. 把this这个对象返回

               * 3.字面量的方式创建对象
                      var obj={};
      //遍历对象,是不能通过for循环遍历,因为无序要用for in
          //key是一个变量,这个变量中存储的是该对象的所有的属性的名字
          var json = {
                &quot;name&quot;: &quot;小明&quot;,
                &quot;age&quot;: &quot;10&quot;,
                &quot;sex&quot;: &quot;男&quot;
              };
          for (var key in json) {
            console.log(key + &quot;===========&quot; + json[key]);
          }
</code></pre><h4 id="Math对象-是静态对象"><a href="#Math对象-是静态对象" class="headerlink" title="Math对象;(是静态对象)"></a>Math对象;(是静态对象)</h4><pre><code>实例对象:通过构造函数创建出来,实例化的对象
静态对象:不需要创建,直接就是一个对象,方法(静态方法)直接通过这个对象名字调用,
实例方法必须通过实例对象调用
静态方法必须通过大写的对象调用
    常用的:
    Math.PI----π---
    Math.E----常数的底数
    Math.abs(值)-----绝对值
    Math.ceil(值)----向上取整
    Math.floor(值)---向下取整
    Math.max(x,y,z,...,n)---返回 x,y,z,...,n 中的最高值。
    Math.min(x,y,z,...,n)---返回 x,y,z,...,n 中的最小值。
    Math.pow(x,y)---返回 x 的 y 次幂。
    Math.random()---返回 0 ~ 1 之间的随机数。
    Math.round(x)---四舍五入。
    Math.sqrt(x)---返回数的平方根。
</code></pre><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象:"></a>Date对象:</h4><pre><code>1.创建date对象:
    var dt = new Date(); 
2.常用方法:
     dt.getFullYear();//年
     dt.getMonth();//月---从0开始
     dt.getDate();//日
     dt.getHours();//小时
     dt.getMinutes();//分钟
     dt.getSeconds();//秒
     dt.getDay();//星期---从0开始
     dt.toDateString();//日期
     dt.toLocaleDateString();//日期
     dt.toTimeString();//时间
     dt.toLocaleTimeString();//时间
     dt.valueOf();//毫秒
</code></pre><h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象:"></a>String对象:</h4><pre><code>1.String----&gt;是一个对象
    * 字符串可以看成是字符组成的数组,但是js中没有字符类型
    * 字符是一个一个的,在别的语言中字符用一对单引号括起来
    * 在js中字符串可以使用单引号也可以使用双引号
    * 因为字符串可以看成是数组,所以,可以通过for循环进行遍历
    *
    * 字符串特性:不可变性,字符串的值是不能改变
    *
    * 字符串的值之所以看起来是改变的,那是因为指向改变了,并不是真的值改变了
2.常用属性:
     * 字符串的常用属性:
         * .length------&gt;字符串的长度
         * .charAt(索引),返回值是指定索引位置的字符串,超出索引,结果是空字符串
         * .fromCharCode(数字值,可以是多个参数),返回的是ASCII码对应的值
         * .concat(字符串1,字符串2,...);返回的是拼接之后的新的字符串
         * .indexOf(要找的字符串,从某个位置开始的索引);返回的是这个字符串的索引值,没找到则返回-1
         * .lastIndexOf(要找的字符串);从后向前找,但是索引仍然是从左向右的方式,找不到则返回-1
         * .replace(&quot;原来的字符串&quot;,&quot;新的字符串&quot;);用来替换字符串的
         * .slice(开始的索引,结束的索引); 从索引5的位置开始提取,到索引为10的前一个结束,没有10，并返回这个提取后的字符串
         * .split(&quot;要干掉的字符串&quot;,切割后留下的个数);切割字符串
         * .substr(开始的位置,个数);返回的是截取后的新的字符串
         * .substring(开始的索引,结束的索引),返回截取后的字符串,不包含结束的索引的字符串
         * .toLocaleLowerCase();转小写
         * .toLowerCase();转小写
         * .toLocaleUpperCase()转大写
         * .toUpperCase();转大写
         * .trim();干掉字符串两端的空格
</code></pre><h4 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象:"></a>Array对象:</h4><pre><code>1.数组:一组有序的数据
        数组的作用:可以一次性存储多个数据
        如何创建数组:
            1. 通过构造函数创建数组
                var 数组名=new Array();//定义了一个数组
            2. 通过字面量的方式创建数组
                var 数组名=[];//空数组
        数组可以存储的各种类型:
                var arr=[10,&quot;哈哈&quot;,true,null,undefined,new Object()];
         冒泡排序:上面有示例
2.判断是不是数组2种方法:
    1.Array.isArray(对象)----&gt;判断这个对象是不是数组
    2. instanceof关键字
3.常用属性:
        * .concat(数组,数组,数组,...) 组合一个新的数组
         * .every(函数)--返回值是布尔类型,函数作为参数使用,函数中有三个参数,第一个参数是元素的值，第二个参数是索引值,第三个参数是原来的数组(没用)
         * 如果这个数组中的每个元素的值都符合条件,最后才返回的是true
         *
         * .filter(函数);返回的是数组中每一个元素都复合条件的元素,组成了一个新的数组
         *
         * .push(值);---&gt;把值追加到数组中,加到最后了---返回值也是追加数据之后的数组长度
         * .pop();---&gt;删除数组中最后一个元素,返回值就是删除的这个值
         * .shift();---&gt;删除数组中第一个元素,返回值就是删除的这个值
         * .unshift();---&gt;向数组的第一个元素前面插入一个新的元素,----返回值是插入后的程度
         * .forEach(函数)方法---遍历数组用---相当于for循环
         * .indexOf(元素值);返回的是索引,没有则是-1
         * .join(&quot;字符串&quot;);----返回的是一个字符串
         * .map(函数);---&gt;数组中的每个元素都要执行这个函数,把执行后的结果重新的全部的放在一个新的数组中
         * .reverse();-----&gt;反转数组
         * .sort();---排序的,可能不稳定,如果不稳定,请写MDN中的那个固定的代码
         * .arr.slice(开始的索引,结束的索引);把截取的数组的值放在一个新的数组中,但是不包含结束的索引对应的元素值
         * .splice(开始的位置,要删除的个数,替换的元素的值);一般是用于删除数组中的元素,或者是替换元素,或者是插入元素
</code></pre><h3 id="十二-js学习中三种对象"><a href="#十二-js学习中三种对象" class="headerlink" title="十二: js学习中三种对象:"></a>十二: js学习中三种对象:</h3><pre><code>* 1.内置对象----js系统自带的对象
        Math, Date, String, Array, Object
* 2.自定义对象---自己定义的构造函数创建的对象
* 3.浏览器对象---
        DOM:Document Object Model 文档对象模型,操作页面元素的
        BOM:Browser Object Model 浏览器对象模型,操作浏览器的
</code></pre><h3 id="十三-webapi的知识点"><a href="#十三-webapi的知识点" class="headerlink" title="十三:webapi的知识点:"></a>十三:webapi的知识点:</h3><h4 id="一-节点-元素-自定义属性相关知识点"><a href="#一-节点-元素-自定义属性相关知识点" class="headerlink" title="一.节点,元素,自定义属性相关知识点:"></a>一.节点,元素,自定义属性相关知识点:</h4><pre><code>文档:document
元素:页面中所有的标签,元素---element,  标签----元素---对象
节点:页面中所有的内容(标签,属性,文本(文字,换行,空格,回车)),Node
根元素:html标签
</code></pre><h5 id="1-节点的属性"><a href="#1-节点的属性" class="headerlink" title="1.节点的属性:"></a>1.节点的属性:</h5><pre><code>可以使用标签--元素.出来,可以使用属性节点.出来,文本节点.点出来
nodeType:节点的类型:1----标签,2---属性,3---文本
nodeName:节点的名字:标签节点--大写的标签名字,属性节点--小写的属性名字,文本节点--#text
nodeValue:节点的值:标签节点---null,属性节点---属性值,文本节点---文本内容
使用:
  ulObj=my$(&quot;uu&quot;);ulObj.nodeType,ulObj.nodeName,ulObj.nodeValue,
  利用nodeType判断是标签是属性还是文本,
  利用nodeName获取指定标签,
获取节点的方法:
  //12行代码:都是获取节点和元素的
  //ul
  var ulObj=document.getElementById(&quot;uu&quot;);
  var threeObj=document.getElementById(&quot;three&quot;);
  //父级节点
  console.log(ulObj.parentNode);
  //父级元素
  console.log(ulObj.parentElement);
  //子节点
  console.log(ulObj.childNodes);
  //子元素
  console.log(ulObj.children);
  console.log(&quot;==============================================&quot;);
  //第一个子节点
  console.log(ulObj.firstChild);//------------------------IE8中是第一个子元素
  //第一个子元素
  console.log(ulObj.firstElementChild);//-----------------IE8中不支持
  //最后一个子节点
  console.log(ulObj.lastChild);//------------------------IE8中是第一个子元素
  //最后一个子元素
  console.log(ulObj.lastElementChild);//-----------------IE8中不支持
  //某个元素的前一个兄弟节点
  console.log(threeObj.previousSibling);//------------------------IE8中是第一个子元素
  //某个元素的前一个兄弟元素
  console.log(threeObj.previousElementSibling);//-----------------IE8中不支持
  //某个元素的后一个兄弟节点
  console.log(threeObj.nextSibling);//------------------------IE8中是第一个子元素
  //某个元素的后一个兄弟元素
  console.log(threeObj.nextElementSibling);//-----------------IE8中不支持
  //总结:凡是获取节点的代码在谷歌和火狐得到的都是  相关的节点
  //凡是获取元素的代码在谷歌和火狐得到的都是   相关的元素
  //从子节点和兄弟节点开始,凡是获取节点的代码在IE8中得到的是元素,获取元素的相关代码,在IE8中得到的是undefined----元素的代码,iE中不支持
</code></pre><h5 id="2-元素的创建"><a href="#2-元素的创建" class="headerlink" title="2.元素的创建:"></a>2.元素的创建:</h5><pre><code>元素创建-----为了提高用户的体验
元素创建的三种方式:
1. document.write(&quot;标签的代码及内容&quot;);
  document.write()创建元素,缺陷:如果是在页面加载完毕后,此时通过这种方式创建元素,
  那么页面上存在的所有的内容全部被干掉
2. 对象.innerHTML=&quot;标签及代码&quot;;
    document.getElementById(&apos;idm名&apos;).innerHTML=&quot;&lt;p&gt;窗前明月光,疑是地上霜,举头望明月,低头思故乡&lt;/p&gt;&quot;;
3. document.createElement(&quot;标签的名字&quot;);
  1.首先创建元素(可根据需要在元素中增加内容 元素对象.innerHTML=&apos;xxx&apos;)
  2.把元素追加到父级元素中
  //document.createElement(&quot;标签名字&quot;);
  var pObj = document.createElement(&quot;p&quot;);
   document.getElementById(&apos;id名&apos;).appendChild(pObj);
   父级元素.appendChild(子级元素对象)
    //在父级元素后追加
   父级元素.insertBefore(新的子级元素对象,参照的子级对象);
    //在参照子级元素前添加新子级对象
    父级元素.removeChild(要删除的子级对象);
</code></pre><h5 id="3-自定义属性的操作"><a href="#3-自定义属性的操作" class="headerlink" title="3.自定义属性的操作"></a>3.自定义属性的操作</h5><pre><code>自定义属性:标签原本没有这个属性,为了存储数据,程序员自己添加的属性
自定义属性无法直接通过DOM对象的方式获取或者设置
对象.getAttribute(&quot;自定义属性名字&quot;);获取自定义属性的值
对象.setAttribute(&quot;属性名字&quot;,&quot;值&quot;);设置自定义属性及值
移除自定义属性
对象.removeAttribute(&quot;属性的名字&quot;);    
</code></pre><h4 id="二-JS浏览器BOM对象中的属性和方法"><a href="#二-JS浏览器BOM对象中的属性和方法" class="headerlink" title="二:JS浏览器BOM对象中的属性和方法:"></a>二:JS浏览器BOM对象中的属性和方法:</h4><h5 id="1-location对象"><a href="#1-location对象" class="headerlink" title="1.location对象:"></a>1.location对象:</h5><pre><code>location对象中的属性和方法:console.log(window.location);
</code></pre><p><img src="/2018/08/24/js知识点/location.jpg" alt="Alt text">;<br>        例如一个地址为:localhost:8080/index.html#12580<br>        地址栏上#及后面的内容:window.location.hash<br>          console.log(window.location.hash);//12580<br>        主机名及端口号:window.location.host<br>          console.log(window.location.host);//localhost:8080<br>        主机名:window.location.hostname<br>          console.log(window.location.hostname);//localhost<br>        文件的路径—相对路径:window.location.pathname<br>          console.log(window.location.pathname);//index.html<br>        端口号:window.location.port<br>          console.log(window.location.port);//8080<br>        协议:window.location.protocol<br>          console.log(window.location.protocol);//http<br>        搜索的内容:window.location.search<br>          console.log(window.location.search);//是url后边?号跟的搜索的内容<br>        设置跳转的页面的地址<br>          location.href=”<a href="http://www.jd.com&quot;;//属性-----&gt;必须记住,有历史记录,浏览器返回按钮呢可点" target="_blank" rel="noopener">http://www.jd.com&quot;;//属性-----&gt;必须记住,有历史记录,浏览器返回按钮呢可点</a><br>          location.assign(“<a href="http://www.jd.com&quot;);//方法--&gt;有历史记录,浏览器返回按钮呢可点" target="_blank" rel="noopener">http://www.jd.com&quot;);//方法--&gt;有历史记录,浏览器返回按钮呢可点</a><br>          location.reload();//重新加载–刷新<br>          location.replace(“<a href="http://www.jd.com&quot;);//没有历史记录,所以浏览器中返回按钮不可点" target="_blank" rel="noopener">http://www.jd.com&quot;);//没有历史记录,所以浏览器中返回按钮不可点</a></p>
<h5 id="2-history对象"><a href="#2-history对象" class="headerlink" title="2.history对象:"></a>2.history对象:</h5><pre><code>/*必须需要先有路径跳转后前进后退才能生效*/
  window.history.forward()//前进
  window.history.back();//后退
  window.history.go();// go()方法只有一个参数，可以是整数、负数。如果是正数，就前进。负数就是后退。
  history.go(-1)和history.back()的区别:
    history.go(-1)表示后退与刷新。如数据有改变也随之改变
    history.back()只是单纯的返回到上一页
</code></pre><h5 id="3-navigator对象"><a href="#3-navigator对象" class="headerlink" title="3.navigator对象:"></a>3.navigator对象:</h5><pre><code>window.navigator.userAgent
/*通过userAgent可以判断用户浏览器的类型*/
window.navigator.platform
/*通过platform可以判断浏览器所在的系统平台类型.*/
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/15/vue2-0-node-mongodb/" rel="next" title="vue2.0+node.js+mongodb">
                <i class="fa fa-chevron-left"></i> vue2.0+node.js+mongodb
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/11/项目中关于url截取和rem/" rel="prev" title="url截取和rem">
                url截取和rem <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-jsonp实现跨域获取数据"><span class="nav-number">1.</span> <span class="nav-text">一:jsonp实现跨域获取数据:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-冒泡排序-选择排序-插入排序-数组去重"><span class="nav-number">2.</span> <span class="nav-text">二:冒泡排序,选择排序,插入排序,数组去重:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#去重排序"><span class="nav-number">2.1.</span> <span class="nav-text">去重排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#冒泡排序、插入排序、选择排序合称为简单排序。"><span class="nav-number">2.2.</span> <span class="nav-text">冒泡排序、插入排序、选择排序合称为简单排序。</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#选择排序"><span class="nav-number">2.2.1.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入排序"><span class="nav-number">2.2.2.</span> <span class="nav-text">插入排序:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-阻止冒泡事件和默认事件"><span class="nav-number">3.</span> <span class="nav-text">三:阻止冒泡事件和默认事件:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-闭包"><span class="nav-number">4.</span> <span class="nav-text">四:闭包:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是闭包"><span class="nav-number">4.1.</span> <span class="nav-text">1.什么是闭包;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-闭包的作用"><span class="nav-number">4.2.</span> <span class="nav-text">2. 闭包的作用:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-闭包的缺点"><span class="nav-number">4.3.</span> <span class="nav-text">3.闭包的缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-原型和原型链"><span class="nav-number">5.</span> <span class="nav-text">五.原型和原型链:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-js是一门什么样的语言"><span class="nav-number">6.</span> <span class="nav-text">六.js是一门什么样的语言:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七-js代码注意问题"><span class="nav-number">7.</span> <span class="nav-text">七:js代码注意问题:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八-js中的数据类型"><span class="nav-number">8.</span> <span class="nav-text">八:js中的数据类型:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九-基本包装类型"><span class="nav-number">9.</span> <span class="nav-text">九 基本包装类型:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十-函数的相关知识点"><span class="nav-number">10.</span> <span class="nav-text">十 函数的相关知识点:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十一object-对象-的相关知识"><span class="nav-number">11.</span> <span class="nav-text">十一object(对象)的相关知识:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Math对象-是静态对象"><span class="nav-number">11.1.</span> <span class="nav-text">Math对象;(是静态对象)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date对象"><span class="nav-number">11.2.</span> <span class="nav-text">Date对象:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String对象"><span class="nav-number">11.3.</span> <span class="nav-text">String对象:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array对象"><span class="nav-number">11.4.</span> <span class="nav-text">Array对象:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十二-js学习中三种对象"><span class="nav-number">12.</span> <span class="nav-text">十二: js学习中三种对象:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十三-webapi的知识点"><span class="nav-number">13.</span> <span class="nav-text">十三:webapi的知识点:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一-节点-元素-自定义属性相关知识点"><span class="nav-number">13.1.</span> <span class="nav-text">一.节点,元素,自定义属性相关知识点:</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-节点的属性"><span class="nav-number">13.1.1.</span> <span class="nav-text">1.节点的属性:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-元素的创建"><span class="nav-number">13.1.2.</span> <span class="nav-text">2.元素的创建:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-自定义属性的操作"><span class="nav-number">13.1.3.</span> <span class="nav-text">3.自定义属性的操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二-JS浏览器BOM对象中的属性和方法"><span class="nav-number">13.2.</span> <span class="nav-text">二:JS浏览器BOM对象中的属性和方法:</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-location对象"><span class="nav-number">13.2.1.</span> <span class="nav-text">1.location对象:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-history对象"><span class="nav-number">13.2.2.</span> <span class="nav-text">2.history对象:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-navigator对象"><span class="nav-number">13.2.3.</span> <span class="nav-text">3.navigator对象:</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
