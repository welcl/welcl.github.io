<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/15/项目中封装的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/15/项目中封装的方法/" itemprop="url">项目中封装的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-15T11:22:14+08:00">
                2019-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-格式化后台传过来的-quot-lt-gt-等特殊字符"><a href="#一-格式化后台传过来的-quot-lt-gt-等特殊字符" class="headerlink" title="一:格式化后台传过来的&quot;&lt;&gt;等特殊字符"></a>一:格式化后台传过来的&quot;&lt;&gt;等特殊字符</h3><pre><code>有时候后台传入的数据是&amp;quot;&amp;lt;&amp;gt;这种特殊字符,在页面中显示需要转移下
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">formatDetails(str)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">var</span> obj=&#123;</span><br><span class="line">      <span class="string">'&amp;lt;'</span>:<span class="string">'&lt;'</span>,</span><br><span class="line">      <span class="string">'&amp;gt;'</span>:<span class="string">'&gt;'</span>,</span><br><span class="line">      <span class="string">'&amp;quot;'</span>:<span class="string">'"'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      <span class="keyword">while</span>(str.indexOf(key)!=<span class="number">-1</span>)&#123;</span><br><span class="line">        str=str.replace(key,obj[key]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">formatDetails(res.data);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/js之基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/js之基础知识/" itemprop="url">js之基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-08T15:53:22+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-js是一门什么样的语言"><a href="#一-js是一门什么样的语言" class="headerlink" title="一.js是一门什么样的语言:"></a>一.js是一门什么样的语言:</h3><pre><code>js是脚本语言,解释性语言,弱类型语言,基于对象,动态语言
脚本语言:脚本语言是一个不需要显示编译的编程语言
解释性语言:当浏览器解析这行代码的时候,才知道这个变量具体是什么类型,
弱类型语言:声明都用var,没有其他类型的变量声明
基于对象:直接使用系统当中的对象,而不是自己创建对象
动态语言:动态语言是在运行时确定数据类型的语言
 扩展:
   静态语言是指在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型
   编译语言:需要把代码翻译成计算机所认知的二进制语言,才能够执行
</code></pre><h3 id="二-js代码注意问题"><a href="#二-js代码注意问题" class="headerlink" title="二:js代码注意问题:"></a>二:js代码注意问题:</h3><pre><code>1.在一对script的标签中有错误的js代码,那么该错误的代码后面的js代码不会执行
2.如果第一对的script标签中有错误,不会影响后面的script标签中的js代码执行
3.script标签一般是放在body的标签的最后的,这样浏览器渲染时先渲染html文件,之后才走script中的内容,可以提高效率
</code></pre><h3 id="三-js中的数据类型"><a href="#三-js中的数据类型" class="headerlink" title="三:js中的数据类型:"></a>三:js中的数据类型:</h3><pre><code>js中的原始数据类型:number,string,boolean,null,undefined,object
     * number:数字类型(整数和小数)
     * string:字符串类型(的值一般都是用单引号或者是双引号括起来)  &quot;34&quot;
     * boolean:布尔类型(值只有两个,true(真1),false(假0))
     * null:空类型,值只有一个:null,一个对象指向为空了,此时可以赋值为null
     * undefined:未定义,值只有一个:undefined
     * object:对象
基本类型(简单类型),值类型: number,string,boolean
复杂类型(引用类型):object
空类型:undefined,null

值类型的值在哪一块空间中存储? 栈中存储
引用类型的值在哪一块空间中存储?对象在堆上存储,地址在栈上存储

var num=10;//值类型,值在栈上
var obj={};//复杂类型,对象在堆,地址(引用)在栈

值类型之间传递,传递的是值
引用类型之间传递,传递的是地址(引用)

值类型作为函数的参数,传递的是值
引用类型作为函数的参数,传递的是地址

类型转换:
    一:其他类型转数字类型:
           总结:想要转整数用parseInt(),想要转小数用parseFloat()
                    想要转数字:Number();要比上面的两种方式严格
                    例如:
                            1.parseInt();//转整数  console.log(parseInt(&quot;10.98fdsfd&quot;));//10
                            2.parseFloat()//转小数 console.log(parseFloat(&quot;10.98fdsfd&quot;));//10.98
                            3.Number();//转数字  console.log(Number(&quot;10.98fdsfd&quot;));//NaN
    二:其他类型转字符串类型:
           如果变量有意义调用.toString()使用转换
           如果变量没有意义使用String()转换
           例如:
               1.变量无意义
                   var num2;
                   console.log(String(num2));
                   var num3=null;
                   console.log(String(num3));
               2.变量有意义
                   var num2=20;
                   console.log(num2.toString());
    三:其他类型转布尔类型:
        console.log(Boolean(1));//true
        console.log(Boolean(&quot;哈哈&quot;));//true
        console.log(Boolean(0));//false
        console.log(Boolean(&quot;&quot;));//false
        console.log(Boolean(null));//false
        console.log(Boolean(undefined));//false
     break关键字:如果在循环中使用,遇到了break,则立刻跳出当前所在的循环
     continue:在循环中如果遇到continue关键字,直接开始下一次循环
</code></pre><h3 id="四-基本包装类型"><a href="#四-基本包装类型" class="headerlink" title="四:基本包装类型:"></a>四:基本包装类型:</h3><pre><code>//基本包装类型

    //普通变量不能直接调用属性或者方法
    //对象可以直接调用属性和方法

    //基本包装类型:本身是基本类型,但是在执行代码的过程中,如果这种类型的变量调用了属性或者是方法,
    那么这种类型就不再是基本类型了,而是基本包装类型,这个变量也不是普通的变量了,而是基本包装类型对象
    基本包装类型对象:string number boolean
    例子:
        //    var str=&quot;hello&quot;;
        //    str=str.replace(&quot;ll&quot;,&quot;HH&quot;);
        //    console.log(str);

        //    var str=new String(&quot;hello&quot;);
        //    str=str.replace(&quot;ll&quot;,&quot;HH&quot;);
        //    console.log(str);
        //    str=null;

        //    var num=10;//number----&gt;
        //    console.log(num.toString());
</code></pre><h3 id="五-函数的相关知识点"><a href="#五-函数的相关知识点" class="headerlink" title="五:函数的相关知识点:"></a>五:函数的相关知识点:</h3><pre><code>一:函数需要先定义,然后才能使用
    函数名字:要遵循驼峰命名法
    函数一旦重名,后面的会把前面的函数覆盖
    命名函数:函数如果有名字,就是命名函数
     匿名函数:函数如果没有名字,就是匿名函数
    函数定义:
         * 1. 函数声明--函数定义
         * function 函数名(){
         *     函数体
         * }
         2.函数表达式:
              * 把一个函数给一个变量,此时形成了函数表达式
              * var 变量=匿名函数;
              * 例子:
              * var f1=function (){
              *
              * };
              * 如果是函数表达式,那么此时前面的变量中存储的就是一个函数,而这个变量就相当于是一个函数,就可以直接加小括号调用了
              * f1();
         3.函数的自调用,没有名字,调用---声明的同时,直接调用(一次性的)
                (function(){console.log(&quot;嘎嘎&quot;)})();

    1.函数可以作为参数使用,
        如果一个函数作为参数,那么我们说这个参数(函数)可以叫回调函数
       只要是看到一个函数作为参数使用了,那就是回调函数
    2.:函数是可以作为返回值使用的:(闭包)
             function f1() {
                   console.log(&quot;f1函数调用了&quot;);
                   return function () {
                     console.log(&quot;这是一个函数&quot;);
                   };
                 }
                 var ff=f1();//调用
                      //ff就是一个函数了
                 ff();

    Ctrl +鼠标左键----&gt;转到定义
    * 形参:函数定义的时候函数名字后面的小括号里的变量就是参数,是不需要写var
    * 实参:函数在调用的时候小括号里传入的值叫实参,实参可以是变量也可以是值
    * 如果一个函数中有return ,那么这个函数就有返回值
    * 如果一个函数中没有return,那么这个函数就没有返回值
    * 如果一个函数中没有明确的返回值,那么调用的时候接收了,结果就是undefined
    * (没有明确返回值:函数中没有return,函数中有return,但是return后面没有任何内容)
    arguments-----&gt;数组使用------伪数组---
        * arguments-----&gt;可以获取函数调用的时候,传入的实参的个数
        * arguments是一个对象,是一个伪数组
        * arguments.length---&gt;是实参的个数
        * arguments[索引]----&gt;实参的值
    function f1() {
          var sum=0;
          for(var i=0;i&lt;arguments.length;i++){
            sum+=arguments[i];
          }
          return sum;
        }
    console.log(f1(10,20,30));

二:作用域和作用域链:
        1.作用域：变量可以起作用的范围
            作用域:使用范围
            /*
            *
            * 全局变量:声明的变量是使用var声明的,那么这个变量就是全局变量,全局变量可以在页面的任何位置使用
            * 除了函数以外,其他的任何位置定义的变量都是全局变量
            * 局部变量:在函数内部定义的变量,是局部变量,外面不能使用
            * 全局变量,如果页面不关闭,那么就不会释放,就会占空间,消耗内存
            *
            * 全局作用域:全局变量的使用范围
            * 局部作用域:局部变量的使用范围
            *
            * 块级作用域:一对大括号就可以看成是一块,在这块区域中定义的变量,只能在这个区域中使用,但是在js中在这个块级作用域中定义的变量,外面也能使用;
            * 说明:js没有块级作用域,只有函数除外
            *
            * 隐式全局变量:声明的变量没有var,就叫隐式全局变量
            * 全局变量是不能被删除的,隐式全局变量是可以被删除的
            * 定义变量使用var是不会被删除的,没有var是可以删除的
            */
        2.作用域链:
            将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。
             var num=10;
                function f1() {
                  var num=20;
                  function f2() {
                    var num=30;
                    function f3() {
                      var num=50;
                      console.log(num);
                    }
                    f3();
                  }
                  f2();
                }
                f1();
三:预解析:
        1.提前解析代码
            * 预解析:就是在解析代码之前
            * 预解析做什么事?
            * 把变量的声明提前了----提前到当前所在的作用域的最上面
            * 函数的声明也会被提前---提前到当前所在的作用域的最上面
        2.预解析分段问题的局部作用域问题:         
            //预解析中,变量的提升,只会在当前的作用域中提升,提前到当前的作用域的最上面
             //函数中的变量只会提前到函数的作用域中的最前面,不会出去
             //预解析会分段(多对的script标签中函数重名,预解析的时候不会冲突)              
</code></pre><h3 id="六-object-对象-的相关知识"><a href="#六-object-对象-的相关知识" class="headerlink" title="六:object(对象)的相关知识:"></a>六:object(对象)的相关知识:</h3><pre><code>(js高级教程Number,String,Date,Array,Boolean,Math,RegExp)
          什么是对象:
              对象:有属性和方法,特指的某个事物
              对象:一组无序属性的集合的键值对,属性的值可以是任意的类型
      一:创建对象的方法:
              1.调用系统的构造函数创建对象
                   var 变量名= new Object(); Object 是系统的构造函数  Array

              2.自定义构造函数创建对象(结合第一种和需求通过工厂模式创建对象)
               *  //工厂模式创建对象
                      function createObject(name,age) {
                        var obj = new Object();//创建对象
                        //添加属性
                        obj.name = name;
                        obj.age = age;
                        //添加方法
                        obj.sayHi = function () {
                          console.log(&quot;阿涅哈斯诶呦,我叫:&quot; + this.name + &quot;我今年:&quot; + this.age);
                        };
                        return obj;
                      }
                      //创建人的对象
                      var per1 = createObject(&quot;小芳&quot;,20);
                      per1.sayHi();


                   自定义构造函数创建对象,我要自己定义一个构造函数,自定义构造函数,创建对象
                     函数和构造函数的区别；名字是不是大写(首字母是大写)
                      function Person(name,age) {
                        this.name=name;
                        this.age=age;
                        this.sayHi=function () {
                          console.log(&quot;我叫:&quot;+this.name+&quot;,年龄是:&quot;+this.age);
                        };
                      } 
                      //自定义构造函数创建对象:先自定义一个构造函数,创建对象
                      var obj=new Person(&quot;小明&quot;,10);
                      console.log(obj.name);
                      console.log(obj.age);
                      obj.sayHi();

                      自定义构造函数创建对象做了什么事?(new 的执行过程:)
                              * 1. 在内存中开辟(申请一块空闲的空间)空间,存储创建的新的对象
                              * 2. 把this设置为当前的对象
                              * 3. 设置对象的属性和方法的值
                              * 4. 把this这个对象返回

               * 3.字面量的方式创建对象
                      var obj={};
      //遍历对象,是不能通过for循环遍历,因为无序要用for in
          //key是一个变量,这个变量中存储的是该对象的所有的属性的名字
          var json = {
                &quot;name&quot;: &quot;小明&quot;,
                &quot;age&quot;: &quot;10&quot;,
                &quot;sex&quot;: &quot;男&quot;
              };
          for (var key in json) {
            console.log(key + &quot;===========&quot; + json[key]);
          }
</code></pre><h4 id="Math对象-是静态对象"><a href="#Math对象-是静态对象" class="headerlink" title="Math对象;(是静态对象)"></a>Math对象;(是静态对象)</h4><pre><code>实例对象:通过构造函数创建出来,实例化的对象
静态对象:不需要创建,直接就是一个对象,方法(静态方法)直接通过这个对象名字调用,
实例方法必须通过实例对象调用
静态方法必须通过大写的对象调用
    常用的:
    Math.PI----π---
    Math.E----常数的底数
    Math.abs(值)-----绝对值
    Math.ceil(值)----向上取整
    Math.floor(值)---向下取整
    Math.max(x,y,z,...,n)---返回 x,y,z,...,n 中的最高值。
    Math.min(x,y,z,...,n)---返回 x,y,z,...,n 中的最小值。
    Math.pow(x,y)---返回 x 的 y 次幂。
    Math.random()---返回 0 ~ 1 之间的随机数。
    Math.round(x)---四舍五入。
    Math.sqrt(x)---返回数的平方根。
</code></pre><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象:"></a>Date对象:</h4><pre><code>1.创建date对象:
    var dt = new Date(); 
2.常用方法:
     dt.getFullYear();//年
     dt.getMonth();//月---从0开始
     dt.getDate();//日
     dt.getHours();//小时
     dt.getMinutes();//分钟
     dt.getSeconds();//秒
     dt.getDay();//星期---从0开始
     dt.toDateString();//日期
     dt.toLocaleDateString();//日期
     dt.toTimeString();//时间
     dt.toLocaleTimeString();//时间
     dt.valueOf();//毫秒
</code></pre><h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象:"></a>String对象:</h4><pre><code>1.String----&gt;是一个对象
    * 字符串可以看成是字符组成的数组,但是js中没有字符类型
    * 字符是一个一个的,在别的语言中字符用一对单引号括起来
    * 在js中字符串可以使用单引号也可以使用双引号
    * 因为字符串可以看成是数组,所以,可以通过for循环进行遍历
    *
    * 字符串特性:不可变性,字符串的值是不能改变
    *
    * 字符串的值之所以看起来是改变的,那是因为指向改变了,并不是真的值改变了
2.常用属性:
     * 字符串的常用属性:
         * .length------&gt;字符串的长度
         * .charAt(索引),返回值是指定索引位置的字符串,超出索引,结果是空字符串
         * .fromCharCode(数字值,可以是多个参数),返回的是ASCII码对应的值
         * .concat(字符串1,字符串2,...);返回的是拼接之后的新的字符串
         * .indexOf(要找的字符串,从某个位置开始的索引);返回的是这个字符串的索引值,没找到则返回-1
         * .lastIndexOf(要找的字符串);从后向前找,但是索引仍然是从左向右的方式,找不到则返回-1
         * .replace(&quot;原来的字符串&quot;,&quot;新的字符串&quot;);用来替换字符串的
         * .slice(开始的索引,结束的索引); 从索引5的位置开始提取,到索引为10的前一个结束,没有10，并返回这个提取后的字符串
         * .split(&quot;要干掉的字符串&quot;,切割后留下的个数);切割字符串
         * .substr(开始的位置,个数);返回的是截取后的新的字符串
         * .substring(开始的索引,结束的索引),返回截取后的字符串,不包含结束的索引的字符串
         * .toLocaleLowerCase();转小写
         * .toLowerCase();转小写
         * .toLocaleUpperCase()转大写
         * .toUpperCase();转大写
         * .trim();干掉字符串两端的空格
</code></pre><h4 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象:"></a>Array对象:</h4><pre><code>1.数组:一组有序的数据
        数组的作用:可以一次性存储多个数据
        如何创建数组:
            1. 通过构造函数创建数组
                var 数组名=new Array();//定义了一个数组
            2. 通过字面量的方式创建数组
                var 数组名=[];//空数组
        数组可以存储的各种类型:
                var arr=[10,&quot;哈哈&quot;,true,null,undefined,new Object()];
         冒泡排序:上面有示例
2.判断是不是数组2种方法:
    1.Array.isArray(对象)----&gt;判断这个对象是不是数组
    2. instanceof关键字
3.常用属性:
        * .concat(数组,数组,数组,...) 组合一个新的数组
         * .every(函数)--返回值是布尔类型,函数作为参数使用,函数中有三个参数,第一个参数是元素的值，第二个参数是索引值,第三个参数是原来的数组(没用)
         * 如果这个数组中的每个元素的值都符合条件,最后才返回的是true
         *
         * .filter(函数);返回的是数组中每一个元素都复合条件的元素,组成了一个新的数组
         *
         * .push(值);---&gt;把值追加到数组中,加到最后了---返回值也是追加数据之后的数组长度
         * .pop();---&gt;删除数组中最后一个元素,返回值就是删除的这个值
         * .shift();---&gt;删除数组中第一个元素,返回值就是删除的这个值
         * .unshift();---&gt;向数组的第一个元素前面插入一个新的元素,----返回值是插入后的程度
         * .forEach(函数)方法---遍历数组用---相当于for循环
         * .indexOf(元素值);返回的是索引,没有则是-1
         * .join(&quot;字符串&quot;);----返回的是一个字符串
         * .map(函数);---&gt;数组中的每个元素都要执行这个函数,把执行后的结果重新的全部的放在一个新的数组中
         * .reverse();-----&gt;反转数组
         * .sort();---排序的,可能不稳定,如果不稳定,请写MDN中的那个固定的代码
         * .arr.slice(开始的索引,结束的索引);把截取的数组的值放在一个新的数组中,但是不包含结束的索引对应的元素值
         * .splice(开始的位置,要删除的个数,替换的元素的值);一般是用于删除数组中的元素,或者是替换元素,或者是插入元素
</code></pre><p>###七:js学习中三种对象:</p>
<pre><code>* 1.内置对象----js系统自带的对象
        Math, Date, String, Array, Object
* 2.自定义对象---自己定义的构造函数创建的对象
* 3.浏览器对象---
        DOM:Document Object Model 文档对象模型,操作页面元素的
        BOM:Browser Object Model 浏览器对象模型,操作浏览器的
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/js之webapi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/js之webapi/" itemprop="url">js之webapi</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-08T15:44:03+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="webapi的知识点"><a href="#webapi的知识点" class="headerlink" title="webapi的知识点:"></a>webapi的知识点:</h1><h2 id="一-节点-元素-自定义属性相关知识点"><a href="#一-节点-元素-自定义属性相关知识点" class="headerlink" title="一.节点,元素,自定义属性相关知识点:"></a>一.节点,元素,自定义属性相关知识点:</h2><pre><code>文档:document
元素:页面中所有的标签,元素---element,  标签----元素---对象
节点:页面中所有的内容(标签,属性,文本(文字,换行,空格,回车)),Node
根元素:html标签
</code></pre><p>###1.节点的属性:<br>        可以使用标签–元素.出来,可以使用属性节点.出来,文本节点.点出来<br>        nodeType:节点的类型:1—-标签,2—属性,3—文本<br>        nodeName:节点的名字:标签节点–大写的标签名字,属性节点–小写的属性名字,文本节点–#text<br>        nodeValue:节点的值:标签节点—null,属性节点—属性值,文本节点—文本内容<br>        使用:<br>          ulObj=my$(“uu”);ulObj.nodeType,ulObj.nodeName,ulObj.nodeValue,<br>          利用nodeType判断是标签是属性还是文本,<br>          利用nodeName获取指定标签,<br>        获取节点的方法:<br>          //12行代码:都是获取节点和元素的<br>          //ul<br>          var ulObj=document.getElementById(“uu”);<br>          var threeObj=document.getElementById(“three”);<br>          //父级节点<br>          console.log(ulObj.parentNode);<br>          //父级元素<br>          console.log(ulObj.parentElement);<br>          //子节点<br>          console.log(ulObj.childNodes);<br>          //子元素<br>          console.log(ulObj.children);<br>          console.log(“==============================================”);<br>          //第一个子节点<br>          console.log(ulObj.firstChild);//————————IE8中是第一个子元素<br>          //第一个子元素<br>          console.log(ulObj.firstElementChild);//—————–IE8中不支持<br>          //最后一个子节点<br>          console.log(ulObj.lastChild);//————————IE8中是第一个子元素<br>          //最后一个子元素<br>          console.log(ulObj.lastElementChild);//—————–IE8中不支持<br>          //某个元素的前一个兄弟节点<br>          console.log(threeObj.previousSibling);//————————IE8中是第一个子元素<br>          //某个元素的前一个兄弟元素<br>          console.log(threeObj.previousElementSibling);//—————–IE8中不支持<br>          //某个元素的后一个兄弟节点<br>          console.log(threeObj.nextSibling);//————————IE8中是第一个子元素<br>          //某个元素的后一个兄弟元素<br>          console.log(threeObj.nextElementSibling);//—————–IE8中不支持<br>          //总结:凡是获取节点的代码在谷歌和火狐得到的都是  相关的节点<br>          //凡是获取元素的代码在谷歌和火狐得到的都是   相关的元素<br>          //从子节点和兄弟节点开始,凡是获取节点的代码在IE8中得到的是元素,获取元素的相关代码,在IE8中得到的是undefined—-元素的代码,iE中不支持</p>
<p>###2.元素的创建:<br>      元素创建—–为了提高用户的体验<br>      元素创建的三种方式:</p>
<pre><code>1. document.write(&quot;标签的代码及内容&quot;);
  document.write()创建元素,缺陷:如果是在页面加载完毕后,此时通过这种方式创建元素,
  那么页面上存在的所有的内容全部被干掉
2. 对象.innerHTML=&quot;标签及代码&quot;;
    document.getElementById(&apos;idm名&apos;).innerHTML=&quot;&lt;p&gt;窗前明月光,疑是地上霜,举头望明月,低头思故乡&lt;/p&gt;&quot;;
3. document.createElement(&quot;标签的名字&quot;);
  1.首先创建元素(可根据需要在元素中增加内容 元素对象.innerHTML=&apos;xxx&apos;)
  2.把元素追加到父级元素中
  //document.createElement(&quot;标签名字&quot;);
  var pObj = document.createElement(&quot;p&quot;);
   document.getElementById(&apos;id名&apos;).appendChild(pObj);
   父级元素.appendChild(子级元素对象)
    //在父级元素后追加
   父级元素.insertBefore(新的子级元素对象,参照的子级对象);
    //在参照子级元素前添加新子级对象
    父级元素.removeChild(要删除的子级对象);
</code></pre><h3 id="3-自定义属性的操作"><a href="#3-自定义属性的操作" class="headerlink" title="3.自定义属性的操作"></a>3.自定义属性的操作</h3><pre><code>自定义属性:标签原本没有这个属性,为了存储数据,程序员自己添加的属性
自定义属性无法直接通过DOM对象的方式获取或者设置
对象.getAttribute(&quot;自定义属性名字&quot;);获取自定义属性的值
对象.setAttribute(&quot;属性名字&quot;,&quot;值&quot;);设置自定义属性及值
移除自定义属性
对象.removeAttribute(&quot;属性的名字&quot;);    
</code></pre><h2 id="二-JS浏览器BOM对象中的属性和方法"><a href="#二-JS浏览器BOM对象中的属性和方法" class="headerlink" title="二:JS浏览器BOM对象中的属性和方法:"></a>二:JS浏览器BOM对象中的属性和方法:</h2><h3 id="1-location对象"><a href="#1-location对象" class="headerlink" title="1.location对象:"></a>1.location对象:</h3><pre><code>location对象中的属性和方法:console.log(window.location);
</code></pre><p><img src="/2019/01/08/js之webapi/location.jpg" alt="Alt text">;<br>        例如一个地址为:localhost:8080/index.html#12580<br>        地址栏上#及后面的内容:window.location.hash<br>          console.log(window.location.hash);//12580<br>        主机名及端口号:window.location.host<br>          console.log(window.location.host);//localhost:8080<br>        主机名:window.location.hostname<br>          console.log(window.location.hostname);//localhost<br>        文件的路径—相对路径:window.location.pathname<br>          console.log(window.location.pathname);//index.html<br>        端口号:window.location.port<br>          console.log(window.location.port);//8080<br>        协议:window.location.protocol<br>          console.log(window.location.protocol);//http<br>        搜索的内容:window.location.search<br>          console.log(window.location.search);//是url后边?号跟的搜索的内容<br>        设置跳转的页面的地址<br>          location.href=”<a href="http://www.jd.com&quot;;//属性-----&gt;必须记住,有历史记录,浏览器返回按钮呢可点" target="_blank" rel="noopener">http://www.jd.com&quot;;//属性-----&gt;必须记住,有历史记录,浏览器返回按钮呢可点</a><br>          location.assign(“<a href="http://www.jd.com&quot;);//方法--&gt;有历史记录,浏览器返回按钮呢可点" target="_blank" rel="noopener">http://www.jd.com&quot;);//方法--&gt;有历史记录,浏览器返回按钮呢可点</a><br>          location.reload();//重新加载–刷新<br>          location.replace(“<a href="http://www.jd.com&quot;);//没有历史记录,所以浏览器中返回按钮不可点" target="_blank" rel="noopener">http://www.jd.com&quot;);//没有历史记录,所以浏览器中返回按钮不可点</a></p>
<h3 id="2-history对象"><a href="#2-history对象" class="headerlink" title="2.history对象:"></a>2.history对象:</h3><pre><code>/*必须需要先有路径跳转后前进后退才能生效*/
  window.history.forward()//前进
  window.history.back();//后退
  window.history.go();// go()方法只有一个参数，可以是整数、负数。如果是正数，就前进。负数就是后退。
  history.go(-1)和history.back()的区别:
    history.go(-1)表示后退与刷新。如数据有改变也随之改变
    history.back()只是单纯的返回到上一页
</code></pre><h3 id="3-navigator对象"><a href="#3-navigator对象" class="headerlink" title="3.navigator对象:"></a>3.navigator对象:</h3><pre><code>window.navigator.userAgent
/*通过userAgent可以判断用户浏览器的类型*/
window.navigator.platform
/*通过platform可以判断浏览器所在的系统平台类型.*/
</code></pre><h2 id="三-js三大系列-offset系列-scroll系列-client系列"><a href="#三-js三大系列-offset系列-scroll系列-client系列" class="headerlink" title="三:js三大系列:offset系列,scroll系列,client系列"></a>三:js三大系列:offset系列,scroll系列,client系列</h2><h3 id="offset系列"><a href="#offset系列" class="headerlink" title="offset系列:"></a>offset系列:</h3><pre><code>div如果要移动,就需要脱离文档流,(position:absolute)
  注意:如果样式的代码是在style的标签中设置,外面是获取不到:
      &lt;style&gt;
          #dv{
              left:50px;
          }
      &lt;/style&gt;
      &lt;script&gt;
          document.getElementById(&apos;div&apos;).style.left;
          /*这样是获取不到div设置的left值的,除非div的是内联样式而不是在style中
         然而document.getElementById(&apos;div&apos;).offsetLeft;是既可以获取到内联样式的属性值也可以
         获取到style设置的属性值,所以我们要用offset系列的来获取
          */

      &lt;/script&gt;

* offsetHeight:获取元素的高(有边框)
* offsetWidth:获取元素的宽(有边框)
* offsetLeft:获取元素距离左边位置的值
* offsetTop:获取元素距离上面位置的值
没有脱离文档流情况下:
    offsetLeft:父级元素margin+父级元素padding+父级元素的border+自己的margin其实相对于document
    或者body的位置
脱离文档流了:
    主要是自己的left和自己的margin,其实是相对于父级元素的位置
</code></pre><h3 id="scroll系列"><a href="#scroll系列" class="headerlink" title="scroll系列:"></a>scroll系列:</h3><pre><code>* scroll系列:卷曲---滚出去
* scrollWidth:元素中内容的实际的宽(没有边框),如果没有内容就是元素的宽
* scrollHeight:元素中内容的实际的高(没有边框),如果没有内容就是元素的高
    比如一个div高为200px,里面的内容400px,这时内容会超出div高度,使用scrollHeight就是400px
* scrollTop:元素向上卷曲的距离
* scrollLeft:元素向左卷曲的的距离
</code></pre><h3 id="client系列-可视区域"><a href="#client系列-可视区域" class="headerlink" title="client系列:可视区域"></a>client系列:可视区域</h3><pre><code>* clientWidth:可视区域的宽(没有边框),边框内部的宽度
* clientHeight:可视区域的高(没有边框),边框内部的高度
* clientLeft:左边边框的宽度
* clientTop:上面的边框的宽度
* clientX:可视区域的横坐标
* clientY:可视区域的纵坐标
</code></pre><h2 id="四-元素隐藏的不同方式"><a href="#四-元素隐藏的不同方式" class="headerlink" title="四:元素隐藏的不同方式:"></a>四:元素隐藏的不同方式:</h2><pre><code>1.$(&quot;#dv&quot;).style.display=&quot;none&quot;;//不占位
2.$(&quot;#dv&quot;).style.visibility=&quot;hidden&quot;;//占位
3.$(&quot;#dv&quot;).style.opacity=0;//占位
4.$(&quot;#dv&quot;).style.height=&quot;0px&quot;;//占位
  $(&quot;#dv&quot;).style.border=&quot;0px solid red&quot;;
</code></pre><h2 id="五-大量字符串拼接需要注意-优化-的问题"><a href="#五-大量字符串拼接需要注意-优化-的问题" class="headerlink" title="五:大量字符串拼接需要注意(优化)的问题:"></a>五:大量字符串拼接需要注意(优化)的问题:</h2><pre><code>在我们有大量字符串进行拼接的时候,因为字符串具有不可变性,所以每拼接一个字符串的时候都会新开辟内存
空间,这会极大的占用内存,所以这个时候我们可以把它设置成一个数组,把每个字符串加到数组中然后再拼接在
一起,这样就不会占用大量的内存了!(据说在新的浏览器中已经优化了这个问题,可能字符串拼接比数组拼接还好?)
例子:
    /*点击按钮,把在input输入的字符串拼接起来*/
    1.用字符串拼接的办法:(不推荐)
      document.getElementById(&quot;btn&quot;).onclick = function () {
        var str = &quot;&quot;;//声明一个字符串变量
        //获取所有的文本框
        var inputs = document.getElementsByTagName(&quot;input&quot;);
        //每个文本框的value属性值
        for (var i = 0; i &lt; inputs.length; i++) {
          if (inputs[i].type != &quot;button&quot;) {
            str+=inputs[i].value+&quot;|&quot;;
          }
        }
        console.log(str+inputs[inputs.length-1].value);
      };
    2.推荐使用数组的方式拼接大量的字符串
    document.getElementById(&quot;btn&quot;).onclick = function () {
        var str = [];
        //获取所有的文本框
        var inputs = document.getElementsByTagName(&quot;input&quot;);
        //每个文本框的value属性值
        for (var i = 0; i &lt; inputs.length; i++) {
          if (inputs[i].type != &quot;button&quot;) {
            str.push(inputs[i].value);
          }
        }
        console.log(str.join(&quot;|&quot;));//字符串
      };
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/经典案例收集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/经典案例收集/" itemprop="url">经典案例收集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T10:15:01+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="总结了一些自己喜欢的经典案例"><a href="#总结了一些自己喜欢的经典案例" class="headerlink" title="总结了一些自己喜欢的经典案例:"></a>总结了一些自己喜欢的经典案例:</h2><h3 id="1-模拟输入框搜索"><a href="#1-模拟输入框搜索" class="headerlink" title="1.模拟输入框搜索"></a>1.模拟输入框搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    #box &#123;</span><br><span class="line">      width: 450px;</span><br><span class="line">      margin: 200px auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #txt &#123;</span><br><span class="line">      width: 350px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #pop &#123;</span><br><span class="line">      width: 350px;</span><br><span class="line">      border: 1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #pop ul &#123;</span><br><span class="line">      margin: 10px;</span><br><span class="line">      padding: 0px;</span><br><span class="line">      width: 200px;</span><br><span class="line">      list-style-type: none;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #pop ul li &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; id=&quot;txt&quot; value=&quot;&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot; value=&quot;搜索&quot; id=&quot;btn&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">	function my$(id) &#123;</span><br><span class="line">    	return document.getElementById(id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function setInnerText(element, text) &#123;</span><br><span class="line">	    if (typeof element.textContent == &quot;undefined&quot;) &#123;</span><br><span class="line">	        element.innerText = text;</span><br><span class="line">	    &#125; else &#123;</span><br><span class="line">	        element.textContent = text;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  var keyWords = [&quot;小杨才是最纯洁的&quot;, &quot;小杨才是最帅的&quot;, &quot;小段是最猥琐的&quot;, &quot;小超是最龌龊的&quot;, &quot;苹果是个水果&quot;, &quot;苹果很贵啊&quot;, &quot;苹果好吃&quot;, &quot;苹果此次召回还是没有中国&quot;];</span><br><span class="line">  //获取文本框注册键盘抬起事件</span><br><span class="line">  my$(&quot;txt&quot;).onkeyup = function () &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //每一次的键盘抬起都判断页面中有没有这个div</span><br><span class="line">    if(my$(&quot;dv&quot;))&#123;</span><br><span class="line">      //删除一次</span><br><span class="line">      my$(&quot;box&quot;).removeChild(my$(&quot;dv&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    //获取文本框输入的内容</span><br><span class="line">    var text = this.value;</span><br><span class="line">    //临时数组--空数组-------&gt;存放对应上的数据</span><br><span class="line">    var tempArr = [];</span><br><span class="line">    //把文本框输入的内容和数组中的每个数据对比</span><br><span class="line">    for (var i = 0; i &lt; keyWords.length; i++) &#123;</span><br><span class="line">      //是否是最开始出现的</span><br><span class="line">      if (keyWords[i].indexOf(text) == 0) &#123;</span><br><span class="line">        tempArr.push(keyWords[i]);//追加</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果文本框是空的,临时数组是空的,不用创建div</span><br><span class="line">    if (this.value.length == 0 || tempArr.length == 0) &#123;</span><br><span class="line">      //如果页面中有这个div,删除这个div</span><br><span class="line">      if (my$(&quot;dv&quot;)) &#123;</span><br><span class="line">        my$(&quot;box&quot;).removeChild(my$(&quot;dv&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建div,把div加入id为box的div中</span><br><span class="line">    var dvObj = document.createElement(&quot;div&quot;);</span><br><span class="line">    my$(&quot;box&quot;).appendChild(dvObj);</span><br><span class="line">    dvObj.id = &quot;dv&quot;;</span><br><span class="line">    dvObj.style.width = &quot;350px&quot;;</span><br><span class="line">    //dvObj.style.height=&quot;100px&quot;;//肯定是不需要的------</span><br><span class="line">    dvObj.style.border = &quot;1px solid green&quot;;</span><br><span class="line">    //循环遍历临时数组,创建对应的p标签</span><br><span class="line">    for (var i = 0; i &lt; tempArr.length; i++) &#123;</span><br><span class="line">      //创建p标签</span><br><span class="line">      var pObj = document.createElement(&quot;p&quot;);</span><br><span class="line">      //把p加到div中</span><br><span class="line">      dvObj.appendChild(pObj);</span><br><span class="line">      setInnerText(pObj, tempArr[i]);</span><br><span class="line">      pObj.style.margin = 0;</span><br><span class="line">      pObj.style.padding = 0;</span><br><span class="line">      pObj.style.cursor = &quot;pointer&quot;;</span><br><span class="line">      pObj.style.marginTop = &quot;5px&quot;;</span><br><span class="line">      pObj.style.marginLeft = &quot;5px&quot;;</span><br><span class="line">      //鼠标进入</span><br><span class="line">      pObj.onmouseover = function () &#123;</span><br><span class="line">        this.style.backgroundColor = &quot;yellow&quot;;</span><br><span class="line">      &#125;;</span><br><span class="line">      //鼠标离开</span><br><span class="line">      pObj.onmouseout = function () &#123;</span><br><span class="line">        this.style.backgroundColor = &quot;&quot;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/兼容性代码合集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/兼容性代码合集/" itemprop="url">兼容性代码合集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-20T09:58:23+08:00">
                2018-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="这里放的都是关于浏览器兼容性代码的函数封装总结"><a href="#这里放的都是关于浏览器兼容性代码的函数封装总结" class="headerlink" title="这里放的都是关于浏览器兼容性代码的函数封装总结!"></a>这里放的都是关于浏览器兼容性代码的函数封装总结!</h1><h2 id="浏览器兼容性的判断思路"><a href="#浏览器兼容性的判断思路" class="headerlink" title="浏览器兼容性的判断思路:"></a>浏览器兼容性的判断思路:</h2><pre><code>如果这个属性在浏览器中不支持,那么这个属性的类型是undefined
判断这个属性的类型 是不是undefined,就知道浏览器是否支持
</code></pre><h2 id="一-innerText-textContent-innerHTML的区别和兼容性"><a href="#一-innerText-textContent-innerHTML的区别和兼容性" class="headerlink" title="一:innerText,textContent,innerHTML的区别和兼容性"></a>一:innerText,textContent,innerHTML的区别和兼容性</h2><h3 id="1-innerText和textContent兼容代码"><a href="#1-innerText和textContent兼容代码" class="headerlink" title="1.innerText和textContent兼容代码:"></a>1.innerText和textContent兼容代码:</h3><pre><code>    设置标签中的文本内容,应该使用innerText属性,谷歌,火狐,IE8都支持,
    设置标签中的文本内容,应该使用textContent属性,谷歌,火狐支持,IE8不支持
    目前的浏览器都支持innerText,应该是属于ie的标准,textContent本身是火狐支持,IE8不支持
    设置任意的标签中间的任意文本内容,两个参数(标签元素,文本内容)
  function setInnerText(element,text) {
    //判断浏览器是否支持这个属性
    if(typeof element.textContent ==&quot;undefined&quot;){//不支持
      element.innerText=text;
    }else{//支持这个属性
      element.textContent=text;
    }
  }
  setInnerText(document.getElementById(&apos;id名&apos;),&apos;你好啊&apos;);
  //获取任意标签中间的文本内容,一个参数(标签元素)
  function getInnerText(element) {
    if(typeof element.textContent==&quot;undefined&quot;){
     return element.innerText;
    }else{
      return element.textContent;
    }
  }
2.innerText,textContent,innerHTML区别:
    想要设置标签内容(可以带标签),使用innerHTML,想要设置文本内容,innerText或者textContent,
或者innerHTML,推荐用innerHTML
</code></pre><h2 id="二-获取节点和元素的方法以及兼容性代码"><a href="#二-获取节点和元素的方法以及兼容性代码" class="headerlink" title="二:获取节点和元素的方法以及兼容性代码"></a>二:获取节点和元素的方法以及兼容性代码</h2><pre><code>1.获取节点和元素的方法:
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;dv&quot;&gt;哦哦</span><br><span class="line">  &lt;span&gt;这是div中的第一个span标签&lt;/span&gt;</span><br><span class="line">  &lt;p&gt;这是div中的第二个元素,第一个p标签&lt;/p&gt;</span><br><span class="line">  &lt;ul id=&quot;uu&quot;&gt;</span><br><span class="line">    &lt;li&gt;这是ul中的第一个标签&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是ul中的第二个标签&lt;/li&gt;</span><br><span class="line">    &lt;li id=&apos;three&apos;&gt;这是ul中的第三个标签&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是ul中的第四个标签&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是ul中的第五个标签&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<pre><code>//12行代码:都是获取节点和元素的
//ul
var ulObj=document.getElementById(&quot;uu&quot;);
//父级节点
console.log(ulObj.parentNode);//
//父级元素
console.log(ulObj.parentElement);
//子节点
console.log(ulObj.childNodes);
//子元素
console.log(ulObj.children);
console.log(&quot;==============================================&quot;);
//第一个子节点
console.log(ulObj.firstChild);//------------------------IE8中是第一个子元素
//第一个子元素
console.log(ulObj.firstElementChild);//-----------------IE8中不支持
//最后一个子节点
console.log(ulObj.lastChild);//------------------------IE8中是第一个子元素
//最后一个子元素
console.log(ulObj.lastElementChild);//-----------------IE8中不支持
//某个元素的前一个兄弟节点
console.log(threeObj.previousSibling);//------------------------IE8中是第一个子元素
//某个元素的前一个兄弟元素
console.log(threeObj.previousElementSibling);//-----------------IE8中不支持
//某个元素的后一个兄弟节点
console.log(threeObj.nextSibling);//------------------------IE8中是第一个子元素
//某个元素的后一个兄弟元素
console.log(threeObj.nextElementSibling);//-----------------IE8中不支持

总结:凡是获取节点的代码在谷歌和火狐得到的都是相关的节点
    凡是获取元素的代码在谷歌和火狐得到的都是相关的元素
    从子节点和兄弟节点开始,凡是获取节点的代码在IE8中得到的是元素,获取元素的相关代码,在IE8中
    得到的是undefined----元素的代码,iE中不支持
</code></pre><h3 id="兼容代码"><a href="#兼容代码" class="headerlink" title="兼容代码:"></a>兼容代码:</h3><pre><code>以获取第一个子级元素为例写兼容性代码,(其他的都一样):
function getFirstElementChild(element) {
    if(element.firstElementChild){//true---&gt;支持
        return element.firstElementChild;
    }else{
        var node=element.firstChild;//第一个节点
        while (node&amp;&amp;node.nodeType!=1){
            node=node.nextSibling;
        }
        return node;
    }
}
</code></pre><h2 id="三-为元素绑定事件写入兼容代码"><a href="#三-为元素绑定事件写入兼容代码" class="headerlink" title="三:为元素绑定事件写入兼容代码:"></a>三:为元素绑定事件写入兼容代码:</h2><pre><code>为元素绑定事件(DOM):一种,但是不兼容.
addEventListener和attachEvent的区别:
相同点:都可以为元素绑定事件
不同点:
    1.方法名不一样,
    2.参数个数不一样addEventListener三个参数,attachEvent两个参数
    3.谷歌和火狐支持,ie11支持,IE8不支持
        谷歌不支持,火狐不支持,ie11不支持,IE8支持
    4.this指向不同:
        addEventListener中的this是指向当前绑定事件对象,
        attachEvent中的this指向window
    5.addEventListener中事件的类型没有on,attachEvent中的事件类型有on
以onclick事件为例,如果我们需要在一个标签中注入多个点击事件,使用:多个
document.getElementById(&apos;id名&apos;).onclick=function(){}写的话会出现后注册的点击事件覆
盖先注册的点击事件,这个时候我们需要用addEventListener来为元素元素绑定多个事件,然而
addEventListener存在兼容性问题,再ie上需要attachEvent
addEventListener:
    参数1:事件的类型---事件的名字,没有on
    参数2:事件处理函数---函数(命名函数,匿名函数)
    参数3:布尔类型,目前就写false://addEventListener中第三个参数是控制事件阶段的
        document.getElementById(&apos;id名&apos;).addEventListener(&quot;click&quot;,function () {
            console.log(&quot;我是点击事件1&quot;);
        },false);
        document.getElementById(&apos;id名&apos;).addEventListener(&quot;click&quot;,function () {
            console.log(&quot;我是点击事件2&quot;);
        },false);
attachEvent:
    参数1:事件类型---事件名字，有on
    参数2:事件处理函数---函数(命名函数,匿名函数)
        document.getElementById(&apos;id名&apos;).attachEvent(&quot;onclick&quot;,function () {
            console.log(&quot;我是点击事件1&quot;);
        });
        document.getElementById(&apos;id名&apos;).attachEvent(&quot;onclick&quot;,function () {
            console.log(&quot;我是点击事件2&quot;);
        });
</code></pre><h3 id="绑定事件兼容代码"><a href="#绑定事件兼容代码" class="headerlink" title="绑定事件兼容代码:"></a>绑定事件兼容代码:</h3><pre><code>//为任意元素.绑定任意的事件, 参数:(任意的元素,事件的类型,事件处理函数)
 function addEventListener(element,type,fn) {
   //判断浏览器是否支持这个方法
   if(element.addEventListener){
     element.addEventListener(type,fn,false);
   }else if(element.attachEvent){
     element.attachEvent(&quot;on&quot;+type,fn);
   }else{
     element[&quot;on&quot;+type]=fn;
   }
 }
 addEventListener(document.getElementById(&apos;id名&apos;),&quot;click&quot;,function () {
   console.log(&quot;哦1&quot;);
 });
 addEventListener(document.getElementById(&apos;id名&apos;),&quot;click&quot;,function () {
   console.log(&quot;哦2&quot;);
 });
 addEventListener(document.getElementById(&apos;id名&apos;),&quot;click&quot;,function () {
   console.log(&quot;哦3&quot;);
 });
</code></pre><h2 id="四-为元素解绑事件写入兼容代码"><a href="#四-为元素解绑事件写入兼容代码" class="headerlink" title="四:为元素解绑事件写入兼容代码:"></a>四:为元素解绑事件写入兼容代码:</h2><pre><code>removeEventListener:谷歌和火狐支持,ie11支持,IE8不支持
detachEvent:谷歌不支持,火狐不支持,ie11不支持,IE8支持,
解绑事件方式:
注意:用什么方式绑定事件,就应该用对应的方式解绑事件
1.解绑事件
    对象.on事件名字=事件处理函数---&gt;绑定事件
    对象.on事件名字=null;
2.解绑事件(注意必须是命名函数,匿名函数会没办法解绑)
    对象.addEventListener(&quot;没有on的事件类型&quot;,命名函数,false);---绑定事件
    对象.removeEventListener(&quot;没有on的事件类型&quot;,函数名字,false);
3.解绑事件(注意必须是命名函数,匿名函数会没办法解绑)
    对象.attachEvent(&quot;on事件类型&quot;,命名函数);---绑定事件
    对象.detachEvent(&quot;on事件类型&quot;,函数名字);
</code></pre><h3 id="解绑事件兼容代码"><a href="#解绑事件兼容代码" class="headerlink" title="解绑事件兼容代码:"></a>解绑事件兼容代码:</h3><pre><code> //为任意元素解绑任意的事件, 参数:(任意的元素,事件的类型,命名函数)
 function removeEventListener(element,type,fnName){
     if(element.removeEventListener){
         element.removeEventListener(type,fnName,false);
     }else if(element.detachEvent){
         element.detachEvent(&apos;on&apos;+type,fnName);
     }else{
         element[&apos;on&apos;+type]=null;
     }
 }
removeEventListener(document.getElementById(&apos;id名&apos;),&apos;click&apos;,fnName);
function fnName(){
    console.log(&apos;我要被解绑了&apos;);
}
</code></pre><h2 id="五-事件冒泡-事件阶段-事件的完整流程及事件冒泡的兼容性代码"><a href="#五-事件冒泡-事件阶段-事件的完整流程及事件冒泡的兼容性代码" class="headerlink" title="五:事件冒泡,事件阶段,事件的完整流程及事件冒泡的兼容性代码:"></a>五:事件冒泡,事件阶段,事件的完整流程及事件冒泡的兼容性代码:</h2><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡:"></a>事件冒泡:</h3><pre><code>原理:多个元素嵌套,有层次关系,这些元素都注册了相同的事件,如果里面的元素的事件触发了,
外面的元素的该事件自动的触发了.
如何阻止事件冒泡:
    window.event.cancelBubble=true;IE特有的,谷歌支持,火狐不支持
    e.stopPropagation(); 谷歌和火狐支持,
    e.stopProgation()是火狐支持的,原理是正确的,e代表了处理事件,在处理事件上增加一个方法来禁用事件冒泡
    window.event.cancelBubble=true是ie支持的,因为:
        addEventListener中的this是指向当前绑定事件对象,(火狐)
        attachEvent中的this指向window(ie),
    ie的this指向的是window,所以使用了window.event,其实和火狐的e代表的是一样的,都是事件触发对象,
    不过火狐用的e(是对象).方法来阻止事件冒泡,ie用的是window.event(是对象).属性来阻止事件冒泡,所以
    兼容性代码的原理也是如此:
    function f1(e){
        //在火狐浏览器下,会用e对象,在ie浏览器下没有e会用window.event对象,这样就解决了兼容性问题
        var e=window.event||e;
    }
</code></pre><h3 id="事件阶段"><a href="#事件阶段" class="headerlink" title="事件阶段:"></a>事件阶段:</h3><pre><code> 事件有三个阶段:
1.事件捕获阶段  :从外向内
2.事件目标阶段  :最开始选择的那个
3.事件冒泡阶段  : 从里向外
</code></pre><h3 id="一个元素绑定事件的完整流程"><a href="#一个元素绑定事件的完整流程" class="headerlink" title="一个元素绑定事件的完整流程:"></a>一个元素绑定事件的完整流程:</h3><pre><code>* addEventListener(&quot;没有on的事件类型&quot;,事件处理函数,控制事件阶段的)
* 事件触发的过程中,可能会出现事件冒泡的效果,为了阻止事件冒泡---&gt;
* window.event.cancelBubble=true;谷歌,IE8支持,火狐不支持
* window.event就是一个对象,是IE中的标准
* e.stopPropagation();阻止事件冒泡----&gt;谷歌和火狐支持
* window.event和e都是事件参数对象,一个是IE的标准,一个是火狐的标准
* 事件参数e在IE8的浏览器中是不存在,此时用window.event来代替
* addEventListener中第三个参数是控制事件阶段的
* 事件的阶段有三个:
* 通过e.eventPhase这个属性可以知道当前的事件是什么阶段的
* 如果这个属性的值是:
* 1----&gt;捕获阶段
* 2----&gt;目标阶段
* 3----&gt;冒泡阶段
    捕获阶段和冒泡阶段只可能出现一个
例如:
   //同时注册点击事件
 var objs = [my$(&quot;dv3&quot;), my$(&quot;dv2&quot;), my$(&quot;dv1&quot;)];
 //遍历注册事件
 objs.forEach(function (ele) {
   //为每个元素绑定事件
   ele.addEventListener(&quot;click&quot;, function (e) {
     console.log(this.id+&quot;====&gt;&quot;+e.eventPhase);
   }, true);
 });
* 一般默认都是冒泡阶段,很少用捕获阶段
* 冒泡阶段:从里向外
* 捕获阶段:从外向内
</code></pre><h2 id="六-获取任意一个元素的任意一个样式属性的值"><a href="#六-获取任意一个元素的任意一个样式属性的值" class="headerlink" title="六:获取任意一个元素的任意一个样式属性的值"></a>六:获取任意一个元素的任意一个样式属性的值</h2><h3 id="存在的兼容问题"><a href="#存在的兼容问题" class="headerlink" title="存在的兼容问题:"></a>存在的兼容问题:</h3><pre><code>my$(&quot;btn&quot;).onclick=function () {
    //获取元素距离左边位置的值
    console.log(my$(&quot;dv&quot;).offsetLeft);
    //谷歌,火狐支持
    console.log(window.getComputedStyle(my$(&quot;dv&quot;),null).left);
    console.log(window.getComputedStyle(my$(&quot;dv&quot;),null)[&quot;left&quot;]);
    //IE8支持
    console.log(my$(&quot;dv&quot;).currentStyle.left);
};
</code></pre><h3 id="兼容代码-1"><a href="#兼容代码-1" class="headerlink" title="兼容代码:"></a>兼容代码:</h3><pre><code>代码1:
function getStyle(element,attr) {
    //判断浏览器是否支持这个方法
    if(window.getComputedStyle){
         return window.getComputedStyle(element,null)[attr];
    }else{
        return element.currentStyle[attr];
    }
}
简化版:
function getStyle(element,attr) {
    //判断浏览器是否支持这个方法
   return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr];
  }
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h3><pre><code>console.log(getStyle(my$(&quot;dv&quot;),&quot;top&quot;))//获取id为dv的元素的top值
</code></pre><h2 id="7-e-clientX-pageX-scrollLeft的兼容性总结"><a href="#7-e-clientX-pageX-scrollLeft的兼容性总结" class="headerlink" title="7:e,clientX,pageX,scrollLeft的兼容性总结"></a>7:e,clientX,pageX,scrollLeft的兼容性总结</h2><h3 id="1-window-event和事件参数对象e的兼容"><a href="#1-window-event和事件参数对象e的兼容" class="headerlink" title="1.window.event和事件参数对象e的兼容"></a>1.window.event和事件参数对象e的兼容</h3><pre><code>    ie不支持e值,只支持window.event;
兼容代码://window.event和事件参数对象e的兼容
        function getEvent(evt) {
          return window.event||evt;
        },
</code></pre><h3 id="2-clientX-clientY"><a href="#2-clientX-clientY" class="headerlink" title="2.clientX,clientY:"></a>2.clientX,clientY:</h3><pre><code>    主要需要兼容的是e和window.event,
兼容代码://可视区域的横坐标的兼容代码
        function getClientX(evt) {
          return getEvent(evt).clientX;
        },
</code></pre><h3 id="3-scrollLeft兼容性"><a href="#3-scrollLeft兼容性" class="headerlink" title="3.scrollLeft兼容性:"></a>3.scrollLeft兼容性:</h3><pre><code>    有的浏览器认为是document卷曲的距离(document.body.scrollLeft),
    有的浏览器认为是body卷曲的距离()document.documentElement.scrollLeft,
    有的浏览器认为是window.pageXOffset卷曲的距离
兼容代码://页面向左卷曲出去的横坐标
        function getScrollLeft() {
          return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0;
        },
</code></pre><h3 id="4-pageX和pageY在谷歌和火狐可以使用-IE8不能用"><a href="#4-pageX和pageY在谷歌和火狐可以使用-IE8不能用" class="headerlink" title="4.pageX和pageY在谷歌和火狐可以使用,IE8不能用;"></a>4.pageX和pageY在谷歌和火狐可以使用,IE8不能用;</h3><pre><code>    pageX和pageY在谷歌和火狐可以直接使用:
    在ie要这样使用:
        可视区域横坐(window.event.clientX+)+向左(上)卷曲出去的横坐标(getScrollLeft())
兼容代码:
    //相对于页面的横坐标(pageX或者是clientX+scrollLeft)
    getPageX:function (evt) {
      return this.getEvent(evt).pageX? this.getEvent(evt).pageX:this.getClientX(evt)+this.getScrollLeft();
    },
</code></pre><h3 id="把这四个方法放到一个对象中封装的代码"><a href="#把这四个方法放到一个对象中封装的代码" class="headerlink" title="把这四个方法放到一个对象中封装的代码:"></a>把这四个方法放到一个对象中封装的代码:</h3><pre><code>//把代码放在一个对象中
var evt={
    //window.event和事件参数对象e的兼容
    getEvent:function (evt) {
      return window.event||evt;
    },
    //可视区域的横坐标的兼容代码
    getClientX:function (evt) {
      return this.getEvent(evt).clientX;
    },
    //可视区域的纵坐标的兼容代码
    getClientY:function (evt) {
      return this.getEvent(evt).clientY;
    },
    //页面向左卷曲出去的横坐标
    getScrollLeft:function () {
      return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0;
    },
    //页面向上卷曲出去的纵坐标
    getScrollTop:function () {
      return window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0;
    },
    //相对于页面的横坐标(pageX或者是clientX+scrollLeft)
    getPageX:function (evt) {
      return this.getEvent(evt).pageX? this.getEvent(evt).pageX:this.getClientX(evt)+this.getScrollLeft();
    },
    //相对于页面的纵坐标(pageY或者是clientY+scrollTop)
    getPageY:function (evt) {
      return this.getEvent(evt).pageY?this.getEvent(evt).pageY:this.getClientY(evt)+this.getScrollTop();
    }
};
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/vue遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/vue遇到的问题/" itemprop="url">vue  M站开发总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-05T17:22:32+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-本次m站开发是基于m站一期进行开发的-涉及的知识点有限-总结下开发流程"><a href="#一-本次m站开发是基于m站一期进行开发的-涉及的知识点有限-总结下开发流程" class="headerlink" title="一:本次m站开发是基于m站一期进行开发的,涉及的知识点有限,总结下开发流程"></a>一:本次m站开发是基于m站一期进行开发的,涉及的知识点有限,总结下开发流程</h2><h3 id="1-首先是下载一个vue脚手架工具作为底层架构-其次进行本地环境-测试环境-预发布环境-生产环境的配置-最后配置完成后即可进行开发"><a href="#1-首先是下载一个vue脚手架工具作为底层架构-其次进行本地环境-测试环境-预发布环境-生产环境的配置-最后配置完成后即可进行开发" class="headerlink" title="1.首先是下载一个vue脚手架工具作为底层架构,其次进行本地环境,测试环境,预发布环境,生产环境的配置,最后配置完成后即可进行开发"></a>1.首先是下载一个vue脚手架工具作为底层架构,其次进行本地环境,测试环境,预发布环境,生产环境的配置,最后配置完成后即可进行开发</h3><h3 id="2-配置和文件介绍"><a href="#2-配置和文件介绍" class="headerlink" title="2.配置和文件介绍:"></a>2.配置和文件介绍:</h3><pre><code>利用vue-cli下载的模板文件夹目录层级如下:
</code></pre><p><img src="/2018/12/05/vue遇到的问题/mulujiegou.png" alt="Alt text"><br>            本次项目在原有目录基础上会根据需要增加结构如下:<br><img src="/2018/12/05/vue遇到的问题/xiangmujiegou1.jpg" alt="Alt text"><br><img src="/2018/12/05/vue遇到的问题/xiangmujiegou2.jpg" alt="Alt text"><br>            在build目录下:<br>                存放的是package.json中npm run xxx里面调用的js文件如:<br>                  “dev”: “cross-env NODE_ENV=dev webpack-dev-server –inline –progress –config build/webpack.dev.conf.js”,<br>                        执行的就是webpack.dev.conf.js文件夹下的代码,(本地起一个服务<br>                        cross-env能跨平台地设置及使用环境变量<br>                            大多数情况下，在windows平台下使用类似于: NODE_ENV=production的命令行指令会卡住，windows平台与<br>                            POSIX在使用命令行时有许多区别（例如在POSIX，使用$ENV_VAR,在windows，使用%ENV_VAR%。。。）<br>                        NODE_ENV:设置环境变量,在config目录下的xxx.env.js中有定义<br>                   “build”: “cross-env NODE_ENV=prod node build/build.js”,<br>                        执行的是build.js下的代码(用来打包生成dist文件)<br>            在src/api目录下:<br>                app.js是把app有交互的方法封装在了改页面中,<br>                index.js是把h5页面中要调的接口方法封装在了改页面中,<br>            在src/assets目录下:<br>                存放的是css引入的reset.css,用来初始化样式的<br>            在components目录下:<br>                本次存放的是公共的组件,如toast,popup等组件,<br>            在page目录下:<br>                存的都是页面的组件<br>            在public目录下:<br>                 放入引入的css和图片等<br>            在router目录下:<br>                存放的是设置的路由路径<br>            在store目录下:<br>                存放的vuex的变量,<br>                    index.js:设置store中的state值,<br>                    getters.js:获取store中的state值,<br>                    mutations.js:改变store中的值 mutaion提交的是同步函数<br>                    action.js:<br>                        Action 类似于 mutation，不同在于：<br>                        Action 提交的是 mutation，而不是直接变更状态。<br>                        Action 可以包含任意异步操作。<br>            在utils目录下:<br>                    存放的是与app交互的文件或者是封装的公用的js函数<br>            在static目录下:<br>                    可以存放网站的favicon.ico在改目录下<br>            .babelrc:<br>                    babel的配置<br>            .postcssrc.js:<br>                    postcss的配置<br>            package.json:<br>                    vue插件等  </p>
<h2 id="二-遇到的问题"><a href="#二-遇到的问题" class="headerlink" title="二:遇到的问题:"></a>二:遇到的问题:</h2><h3 id="1-input输入框type-”number”和type-”tel”在移动端都可以唤醒数字键盘-但是他们都还是可以输入小数点-并且"><a href="#1-input输入框type-”number”和type-”tel”在移动端都可以唤醒数字键盘-但是他们都还是可以输入小数点-并且" class="headerlink" title="1. input输入框type=”number”和type=”tel”在移动端都可以唤醒数字键盘,但是他们都还是可以输入小数点,+,-,并且,"></a>1. input输入框type=”number”和type=”tel”在移动端都可以唤醒数字键盘,但是他们都还是可以输入小数点,+,-,并且,</h3><pre><code>type=&quot;number&quot;输入的小数点在视图上可以看到,但是在控制台结果输出是没有的,这个时候如果用正则表达式截取小
数点以前的数字就会出现问题,无法获取到想要的数据,type=&quot;number&quot;输入的小数点在视图上可以看到,在控制
台结果也是有的,此时用正则表达式截取是完全ok的,
参考:https://blog.csdn.net/qq_22509715/article/details/78993912
</code></pre><h3 id="2-加密方式"><a href="#2-加密方式" class="headerlink" title="2. 加密方式:"></a>2. 加密方式:</h3><pre><code>参考:https://www.jianshu.com/p/3eaa7a527871
base64加密属于可逆性的加密，意思就是既可以加密，也可以解密。而MD5加密属于不可逆性的加密，只能够给我们提供加密的方
式，却没有解密的方式，一般情况多应用与登录注册界面。
在vue中安装:
    npm install --save js-base64
    npm install --save js-md5
引入和使用
    引入:
    import md5 from &apos;js-md5&apos;;
    let Base64 = require(&apos;js-base64&apos;).Base64;
    使用:
    Base64.encode(&apos;dankogai&apos;);  // ZGFua29nYWk=
    md5(&apos;中文&apos;); // a7bac2239fcdcb3a067903d8077c4a07
</code></pre><h3 id="3-图形验证码"><a href="#3-图形验证码" class="headerlink" title="3.图形验证码:"></a>3.图形验证码:</h3><pre><code>data表示取得数据的协定名称，image/png 是数据类型名称，base64 是数据的编码方法，逗号后面就是这个image/
png文件base64编码后的数据。
根据接口返回的base64的图片,在调接口的时候拿到这个base64图片字段,然后添加到html中,
注意:是base64格式的必须要加data:image/png;base64,+接口返回的字段,
如在vue中&lt;img :src=&quot;base64Image&quot;&gt; base64Image=data:image/png;base64,+接口返回的字段,
可参考:html img Src base64 图片显示(https://www.cnblogs.com/x-st/p/5220282.html)
</code></pre><h3 id="4-Vue-nextTick-的原理和用途"><a href="#4-Vue-nextTick-的原理和用途" class="headerlink" title="4.Vue.nextTick 的原理和用途"></a>4.Vue.nextTick 的原理和用途</h3><pre><code>详细参考:(https://segmentfault.com/a/1190000012861862)
用法:在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
疑问:
    1.DOM 更新循环是指什么？
    2.下次更新循环是什么时候？
    3.修改数据之后使用，是加快了数据更新进度吗？
    4.在什么情况下要用到？
异步说明:Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。
具体来说，异步执行的运行机制如下:
    （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
    （2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，
        就在&quot;任务队列&quot;之中放置一个事件。
    （3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。
        那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
    （4）主线程不断重复上面的第三步。
事件循环说明:
    简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，
    再统一进行视图更新。
例子:(点击获取元素宽度)
    &lt;div id=&quot;app&quot;&gt;
        &lt;p ref=&quot;myWidth&quot; v-if=&quot;showMe&quot;&gt;{{ message }}&lt;/p&gt;
        &lt;button @click=&quot;getMyWidth&quot;&gt;获取p元素宽度&lt;/button&gt;
    &lt;/div&gt;
        getMyWidth() {
            this.showMe = true;
            //this.message = this.$refs.myWidth.offsetWidth;
            //报错 TypeError: this.$refs.myWidth is undefined
            this.$nextTick(()=&gt;{
                //dom元素更新后执行，此时能拿到p元素的属性
                this.message = this.$refs.myWidth.offsetWidth;
          })
        }
</code></pre><h3 id="5-vuex中store存的数据"><a href="#5-vuex中store存的数据" class="headerlink" title="5.vuex中store存的数据:"></a>5.vuex中store存的数据:</h3><pre><code>把vuex注册在根组件下,它的属性可以在单页面中任何地方使用,比如在登录页把手机号和验证码保存在vuex中,
通过点击由去到别的页面,再回到登录页仍然可以通过vuex去到手机号和验证码,但是一刷新整个页面,属性值都
会变成初始化状态
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/17/html-css知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/17/html-css知识点/" itemprop="url">html+css相关知识点梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-17T13:29:34+08:00">
                2018-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="一-清除浮动的四种方法"><a href="#一-清除浮动的四种方法" class="headerlink" title="一:清除浮动的四种方法:"></a>一:清除浮动的四种方法:</h3><pre><code>清除浮动的本质是为了父元素因为子元素浮动导致父元素内部高度为0的问题
    &lt;div class=&quot;father&quot;&gt;
        &lt;div style=&quot;float:left;width:200px;height:200px;&quot;&gt;左浮动&lt;/div&gt;
        &lt;div style=&quot;float:left;width:200px;height:200px;&quot;&gt;左浮动&lt;/div&gt;
        &lt;div class=&quot;empty&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
1:在浮动标签最后添加一个空的标签设置属性:clear:both;
    .empty{clear:both;}
    优点:通俗易懂,书写方便
    缺点:添加许多无意义标签,结构比较差
2:父级添加overflow属性方法;
    给父级添加overflow方法如:overflow:hidden|auto|scroll 都可
    .father{overflow:hidden}(前提父元素没有设置高度,如果设置了高度是不用清除的)
    优点:
    缺点:内容增多时候容易造成不会自动换行导致内容被隐藏掉,无法显示需要溢出的元素
3:伪元素清除浮动:(父元素加)
    :after方式为空元素的升级版,好处是不用单独加标签了
    使用方法:(可以把下面代码写到reset.css中)
        .clearfix:after{content:&apos;&apos;;display:block;height:0px;clear:both;visibility:hidden;}
        .clearfix{*zoom:1;}/*IE6,7专有*/
    优点:符合闭合浮动的思想,结构语义化正确
    缺点:由于ie6,7不支持:after,需要使用zoom:1触发haslayout
4:使用before和after双伪元素清除浮动
    使用方法:
        .clearfix:before, .clearfix:after{
            content:&quot;&quot;;
            display:table;/*这句话可以触发BFC,BFC可以清除浮动*/
        }
        .clearfix:after{
            clear:both;
        }
        .clearfix{*zoom:1;}
        优点:代码更简洁
        缺点:由于IE6-7不支持:after,使用zoom:1触发haslayout
</code></pre><h3 id="二-有趣的边框显示demo"><a href="#二-有趣的边框显示demo" class="headerlink" title="二:有趣的边框显示demo:"></a>二:有趣的边框显示demo:</h3><pre><code>/*需求:一列表格,边框为1px,(相邻的边框也是1px),鼠标经过的时候显示#f04颜色的边框(四个边都是#f04)*/
css:
    div{
        width:250px;
        height:300px;
        border:1px solid #ccc;
        float:left;
        margin-left:-1px;/*处理相邻边框的border为1px,不加相邻边框border为2px*/
    }
    div:hover{
        border:1px solid #f04;
        position:relative;/*处理hover时候四个边框都是f04,相对定位的元素不会脱离文档流。但是如果div已经有了position:relative,这时候再hover的时候不需要再加相对定位秩序加一个z-index:1提升显示层级即可*/
    }
html:
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
效果:
</code></pre><p><img src="/2018/10/17/html-css知识点/border_demo.png" alt="Alt text"></p>
<h3 id="三-显示隐藏"><a href="#三-显示隐藏" class="headerlink" title="三:显示隐藏:"></a>三:显示隐藏:</h3><pre><code>display:隐藏后不再保留位置
visibility:hidden|visible 隐藏之后,继续保留原有位置(停薪留职)
opacity:为0之后,继续保留原有位置(停薪留职)
</code></pre><h3 id="四-图片在div中会有3px空白问题"><a href="#四-图片在div中会有3px空白问题" class="headerlink" title="四:图片在div中会有3px空白问题:"></a>四:图片在div中会有3px空白问题:</h3><pre><code>vertical-align:top|middle|baseline|bottom(针对行内块和行内元素,块元素无此属性)
对齐方式图解:
</code></pre><p><img src="/2018/10/17/html-css知识点/vertical_demo.png" alt="Alt text"><br>    3px示意图:<br><img src="/2018/10/17/html-css知识点/vertical_demo_3px.png" alt="Alt text"><br>    原因:图片是行内块状元素,是以基线为对齐方式,所以在div显示会空出基线到底线的距离,为3px;<br>    示例:</p>
<pre><code>css:
    div{
        border:1px solid red;
    }
    img {
        /*方法1:设置图片对齐方式为非vertical-align:baseline即可*/
        vertical-align: middle;
        /*display: block*/
        /*方法2:把img 转换块状元素display:block*/
    }
html:
    &lt;div&gt;
        &lt;img src=&quot;image.jpg&quot;&gt;hello yes
    &lt;/div&gt;
</code></pre><h3 id="五-精灵-雪碧-图的使用"><a href="#五-精灵-雪碧-图的使用" class="headerlink" title="五:精灵(雪碧)图的使用:"></a>五:精灵(雪碧)图的使用:</h3><pre><code>1.为什么要使用精灵图:
    为了有效减少服务器接收和发送请求的的次数,提高页面的加载速度.
2.精灵图技术的本质:
    css精灵图是一种处理网页背景图像的方式,把一个页面设计到的所有零星的背景图像都集中到一个大图中,
    然后将大图应用于网页,这样,当用户访问页面时,只需向服务器发送一次请求,网页中的背景图像即可全部展示
    出来.
注意:小公司,背景图片很少的情况,没有必要使用精灵技术,维护成本太高(修改费劲).
使用:在需要使用背景图的地方写css(利用background-position定位)
    x:需要的背景图片在精灵图中的x轴的位置
    y:需要的背景图片在精灵图中的y轴的位置
    background:url(&apos;xxx.jpg|png&apos;) no-repeat x y;
</code></pre><h3 id="六-滑动门原理"><a href="#六-滑动门原理" class="headerlink" title="六:滑动门原理:"></a>六:滑动门原理:</h3><p>背景图片:<br><img src="/2018/10/17/html-css知识点/slideDoor.png" alt="Alt text"><br>完成效果图:<br><img src="/2018/10/17/html-css知识点/sliderdoor_demo.png" alt="Alt text"><br>    需求:在导航栏中,字体背景图(左右两边分别有一个闭合的标识)显示根据字体多少显示的时候,此时没法单纯的<br>    设置一个固定大小的背景图,只能使用滑动门的效果让背景图根据字体多少显示。<br>    1.原理：在a标签中设置背景图左标识显示的内容,在a标签中嵌套一个span标签,在span标签中显示背景图右侧的<br>    标识,不给a标签,span标签设置宽度,让他们根据字体大小撑开宽度<br>    使用:</p>
<pre><code>css:
    a{
        margin-left:30px;
        height:30px;
        display: inline-block;
        background:url(slideDoor.png) no-repeat;/*设置左侧标识背景图*/
        color:#fff;
        line-height: 30px;
        font-size:16px;
        padding-left:15px;
    }
    span{
        display: inline-block;
        height:30px;
        padding-right:15px;
        background: url(slideDoor.png) no-repeat right;/*设置右侧标识和其他部分背景图*/
    }
html:
    &lt;a&gt;
        &lt;span&gt;首页&lt;/span&gt;
    &lt;/a&gt;
    &lt;a&gt;
        &lt;span&gt;首页啊啊啊啊&lt;/span&gt;
    &lt;/a&gt;
写完之后,当在span中输入不同数量的内容时,背景图一般也能完整的显示出来(除非宽度大于了背景图的长度),
备注:结果图看起来有点错位是因为背景图是截屏截取的,不够准确
</code></pre><h3 id="七-字体图标的使用"><a href="#七-字体图标的使用" class="headerlink" title="七:字体图标的使用"></a>七:字体图标的使用</h3><pre><code>图片是有诸多有点的,但是缺点也很明显,比如图片不但增加了总文件的大小,还增加了很多额外的&quot;http请求&quot;,这都会大大降低网页
的性能,更重要的是图片不能很好的进行缩放,图片缩放会导致失真,然而,字体图标作为矢量图却是可以,改变颜色,自由缩放且不失真的
字体图标的优点:
    可以做出跟图片一样可以做的事情,改变透明度,旋转等
    但是本质是文字,可以随意改变颜色,阴影,透明效果等..(因为是字体,改变大小用font-size)
    本身体积更小,但携带的信息并没有削减
    几乎支持所有的浏览器
    移动端设备必备良药
字体图标使用流程图:
</code></pre><p><img src="/2018/10/17/html-css知识点/icon_demo.png" alt="Alt text"><br>    使用方法:<br>    1.如果设计给了svg,需要将svg图片转成文字图标样式。<br>        1.打开<a href="https://icomoon.io" target="_blank" rel="noopener">https://icomoon.io</a> 点击右上角iconMoon App<br>        2.进入新的页面后点击左上角import icons把svg图片导入进入生成icon图标<br>        3.选中图标,点击右下角generate font查看每个图标对应的class<br>        4.点击右下角download下载生成的内容载解压缩,找到style.css,存储的即为所需字体图标class样式<br>        5.在需要的地方 <i class="xxx"></i>即可<br>    2.如何实际没有个svg图,需要自己找。<br>        在第2步自己找到需要的图标继续操作即可<br>    注意:下载的sell-icon里共有如下文件夹:<br><img src="/2018/10/17/html-css知识点/sell-icon.png" alt="Alt text"><br>    fonts:存放的是四种字体的不同格式,(如果想在页面使用,需在合适的路径引入这个文件的内容)<br>    demo.html:存放的是下载的所以字体图标的对应编号(可以选择赋值空格来引入图标,也可以选择引入class来引入图标(style.css里有使用示例))<br>    selection.json:存放的是本次下载的图标所以的集合,在增加新图标的时候,可以导入这个文件获取以前的图标,然后在此基础上增加新图标<br>    style.css:存放的是引入fonts的路径和给每个图标写一个class类,可以直接引入html使用其中的class</p>
<h3 id="八-初始化css样式文件"><a href="#八-初始化css样式文件" class="headerlink" title="八:初始化css样式文件:"></a>八:初始化css样式文件:</h3><pre><code>normalize.css和reset.css(可以去github上搜索并下载即可)
    Normalize.css只是一个很小的css文件，但它在磨人的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS 
reset,Normalize.css是一种现代的、为HTML5准备的优质替代方案。总之，Normalize.css是一种CSS reset的替代方案。
normalize与CSS Reset的区别:
    1:保留有用的浏览器默认值，而不是删除它们。
    2:规范化各种HTML元素的样式。
    3:纠正错误和常见的浏览器不一致
    4:通过微妙的改进提高可用性。
    5:用注释和详细的文档来。
注意：Normalize支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表哥都进行了一般化。
尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。
</code></pre><h3 id="九-三大标签的优化-SEO优化"><a href="#九-三大标签的优化-SEO优化" class="headerlink" title="九:三大标签的优化(SEO优化):"></a>九:三大标签的优化(SEO优化):</h3><pre><code>1.title标签:
    网页标题title:title具有不可替代性,是我们的内页第一个重要的标签,是搜索引擎了解网页的入口,搜索引擎就很大部分是依靠网站title来判断你网站是关于什么内容的
    如京东:
    &lt;title&gt;京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！&lt;/title&gt;
2.meta标签的 description:
    description功能让搜索引擎是判断整个页面内容的，当中要写入的内容是你页面内容的简介。description一般不超过100个字符。
    如京东:
    &lt;meta name=&quot;description&quot; content=&quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、
    服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot;&gt;
3.meta标签的 Keyword关键字:
    Keywords是页面关键字,是搜索引擎关注点之一。Keywords应该限制在6~8个关键字左右
    如京东:
    &lt;meta name=&quot;Keywords&quot; content=&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东&quot;&gt;
</code></pre><h3 id="十-伪元素after和before用法"><a href="#十-伪元素after和before用法" class="headerlink" title="十:伪元素after和before用法:"></a>十:伪元素after和before用法:</h3><pre><code>css:
    div::before{
        content:&quot;我是before添加的内容&quot;;/*这个是必须要有的一个属性,以下的可有可无*/
        display:block;/*通过伪元素添加的盒子是个行内盒子,可以转成块状盒子*/
        width:50px;
        height:50px;
    }
    通过before和after添加的盒子在div内部,并且div::before也可以写成div:before,如果要利用after清除浮动可以把高度设置为0
html:
    &lt;div&gt;before和after的用法&lt;/div&gt;
</code></pre><h3 id="十一-转换网页title栏的ico图标"><a href="#十一-转换网页title栏的ico图标" class="headerlink" title="十一:转换网页title栏的ico图标:"></a>十一:转换网页title栏的ico图标:</h3><pre><code>1.先切图,尽量是透明图片png格式
2.把图片转换为图标 http://www.bitbug.net/(在这个网站上转图片)
3.当成功生成favicon.ico图像文件后,浏览器会自动弹出一个zip的压缩文件将压缩文件中的favicon.ico图像
放在根目录下(也可以是其他目录)在页面源文件的&lt;head&gt;&lt;/head&gt;标签之间插入
&lt;link rel=&quot;shortcut icon&quot; href=&quot; /favicon.ico&quot; /&gt; 
</code></pre><h3 id="十二-css3的flex布局-弹性布局"><a href="#十二-css3的flex布局-弹性布局" class="headerlink" title="十二:css3的flex布局(弹性布局)"></a>十二:css3的flex布局(弹性布局)</h3><pre><code>使用flex布局需要考虑到兼容性问题,pc端兼容性不好,移动端兼容性很好,在移动端使用较多,
1.通常使用flex布局来实现均分一行或者一列的元素,缩放时也保持对应比例
    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;1&lt;/div&gt;
        &lt;div&gt;2&lt;/div&gt;
        &lt;div&gt;3&lt;/div&gt;
    &lt;/div
    .father{
        display:flex;/*规定.father元素使用felx布局*/
    }
    .father div{
        flex:1;/*在一行内显示并且均分*/
    }
2.也可以固定.son的宽度,其他的div按着felx布局显示
    .son{width:200px}
3.flex布局默认水平分布,也改更改为垂直分布:
    flex-direction:column;/*水平分布*/
    flex-direction:row;/*垂直分布*/
4.其他使用可以参考官方文档即可
</code></pre><h3 id="十三-background-size背景缩放-css3"><a href="#十三-background-size背景缩放-css3" class="headerlink" title="十三:background-size背景缩放(css3)"></a>十三:background-size背景缩放(css3)</h3><pre><code>1.background-size:80px 100px;/*背景图宽高分别为80px 100px*/
2.background-size:80px/*背景图宽为80px,高auto(自动根据比例缩放)*/
3.background-size:cover;/*按背景图比例缩放,以最小的宽或者高为基准,直到最小的那个铺满div才停止缩放,div一定被背景图铺满*/
4.background-size:contain/*按背景图比例缩放,以最大的宽或者高为基准,直到最大的那个铺满div才停止缩放,div不一定被背景图铺满*/
注意:
    如果在开发中遇到了精灵图是实际需要的图的2倍的时候(ios,安卓差异),可以利用background-size:104px;
把背景图宽高设置成精灵图的一半,然后用background:url(images/xxx.png) no-repeat x y;/*x(y)缩小后
需要使用图片的x(y)轴上的位置)*/
例如:原精灵图宽208px高自动,我们需要宽104px的精灵图
    background:url(images/xxx.png) no-repeat x y;
    background-size:104px;
</code></pre><h3 id="十四-多背景-css3"><a href="#十四-多背景-css3" class="headerlink" title="十四:多背景(css3)"></a>十四:多背景(css3)</h3><pre><code>div{
    background:url(images/xxx.png) no-repeat , url(images/xxx.png) no-repeat;
}
以逗号分隔可以设置多背景,可用于自适应布局。
注意:如果div本身还有背景色,此时应该在下面继续写background:blue;不能把这个颜色写在url那行,因为会重叠覆盖
例子:
    background: url(images/paopao.png)  no-repeat top left, url(images/paopao.png) no-repeat right bottom;
    background-color: blue;  /*多背景颜色写到下面 防止被叠加*/
</code></pre><h3 id="十五-浏览器前缀"><a href="#十五-浏览器前缀" class="headerlink" title="十五:浏览器前缀"></a>十五:浏览器前缀</h3><pre><code>浏览器前缀                浏览器
-webkit-                 google Chrome,safari,Android Browser
-moz-                    Firfox
-o-                        Opera
-ms-                    Internet Explorer,Edge
-khtml-                    Konqueror
</code></pre><h3 id="十六-盒子半透明"><a href="#十六-盒子半透明" class="headerlink" title="十六:盒子半透明"></a>十六:盒子半透明</h3><pre><code>在没有css3的background:rgba(255,255,255,0.5)的时候,盒子半透明是使用opacity:0.5,但是这样使用会把盒子内的
文字也半透明,以前的处理方法是在div中嵌套一个div和一个p标签,把div中的div大小设置和外层div一样大,设置
opacity:0.5,把p标签定位到内层div上,这样就可以实现div半透明,而里面的字不是半透明的效果,在有css3的情况下我们
可以直接background:rgba(255,255,255,0.5);即可
html结构:&lt;div&gt;
            &lt;div&gt;&lt;/div&gt;
            &lt;p&gt;hello&lt;/p&gt;
        &lt;/div&gt;
</code></pre><h3 id="十七-css盒子模型"><a href="#十七-css盒子模型" class="headerlink" title="十七:css盒子模型:"></a>十七:css盒子模型:</h3><pre><code>CSS盒子模型：网页设计中CSS技术所使用的一种思维模型。
CSS盒子模型组成：外边距（margin）、边框（border）、内边距（padding）、内容（content）。
CSS盒子模型分为：标准W3C盒子模型，IE盒子模型，注意在两种模型中宽（width）和高（height）包括属性的不同。
</code></pre><h4 id="W3C模型中："><a href="#W3C模型中：" class="headerlink" title="W3C模型中："></a>W3C模型中：</h4><pre><code>W3C模型中content的宽度和高度就是content的宽和高
　　CSS中的宽（width）=内容（content）的宽
CSS中的高（height）=内容（content）的高
</code></pre><h4 id="IE模型中："><a href="#IE模型中：" class="headerlink" title="IE模型中："></a>IE模型中：</h4><pre><code>        IE盒模型中content的宽度和高度包括了border和padding。
 　   CSS中的宽（width）=内容（content）的宽+（border+padding）*2
        CSS中的高（height）=内容（content）的高+（border+padding）*2

margin（外边界）虽不可见，但是它确实在文档中占据了空间，我们要区分两个概念即：盒子所占空间（计入margin ）
和盒子实际的大小（不计入margin） 。
</code></pre><h4 id="实例区分两种盒模型"><a href="#实例区分两种盒模型" class="headerlink" title="实例区分两种盒模型:"></a>实例区分两种盒模型:</h4><pre><code>        下面举个例子来区分两种盒模型：
            一个盒子的 margin 为 20px，border 为 2px，padding 为 10px，content 的宽为 200px、高为 50px。
        ie盒子模型:
            盒子所占空间：width=20ｘ2+200=240      　　          height=20ｘ2+50=90
            盒子实际大小：width=200        　　　　　　　            height=50
        标准w3c盒子模型:
            盒子所占空间：width=20ｘ2+2ｘ2+10ｘ2+200=264  　  height=20ｘ2+２ｘ2+10ｘ2 +50=114
            盒子实际大小：width=200 +2ｘ2+10ｘ2 =224  　　　    height=50+2ｘ2+10ｘ2=74
box-sizing和两种盒模型:
        box-sizing有三个取值：
                1、content-box:使元素遵循标准 w3c 盒子模型（默认值）。(width+padding+border)
                2、border-box:使元素遵循ie 盒子模型。(width)
                3、 inherit： 规定应从父元素继承 box-sizing 属性的值
        当我们设置box-sizing:content-box时候,如果设置div宽为200px,在设置border,padding等,实际宽度会是200+(border+padding)*2;
        当我们设置box-sizing:border-box时候,如果设置div宽度为200px,在设置border,padding等,实际宽度会是就是200,只不过内容空间
        变成了减去(padding+border)*2,
现在还在用IE6以下的浏览器的用户已经很少了，所以目前浏览器大部分元素都是基于W3C标准盒子模型 上。所以我们平常说的盒子模型
一般就是标准w3c 盒子模型 （但对于input、button元素默认border-box ，还是基于传统的ie 盒子模型）。一定有人会问，那我们怎样
让我们的元素都遵循W3C标准盒子模型呢？哈哈，看看你html的文件头部是不是有一个&lt;!DOCTYPE html&gt; ，有这个，就说明你已经遵
循W3C标准盒子模型了。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/12/web存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/web存储/" itemprop="url">cookies、sessionStorage和localStorage解释及区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-12T10:13:52+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-HTML4的本地存储-cookie"><a href="#一-HTML4的本地存储-cookie" class="headerlink" title="一.HTML4的本地存储 (cookie)"></a>一.HTML4的本地存储 (cookie)</h2><h3 id="浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie-session等跟服务端进行数据交互"><a href="#浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie-session等跟服务端进行数据交互" class="headerlink" title="浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie,session等跟服务端进行数据交互"></a>浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie,session等跟服务端进行数据交互</h3><h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><pre><code>cookie和session都是用来跟踪浏览器用户身份的会话方式。
</code></pre><h3 id="cookie和session区别："><a href="#cookie和session区别：" class="headerlink" title="cookie和session区别："></a>cookie和session区别：</h3><pre><code>1、保持状态：cookie保存在浏览器端，session保存在服务器端
2、使用方式：
    (1）cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，
    这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，
    cookie数据仍然存在，直到过期时间结束才消失
    Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它
    (2）session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。
    如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建
    新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，
    在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过
    response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；
    当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。
3、存储内容：
    cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的
    对象(session中可含有多个对象)
4、存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制
5、安全性：
    cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。
    原因如下：
        （1）sessionID存储在cookie中，若要攻破session首先要攻破cookie；
        （2）sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；
        （3）第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。
        （4）sessionID是加密的
        （5）综上所述，攻击者必须在短时间内攻破加密的sessionID，这很难。
6、应用场景：
    cookie：
        （1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，
        则每次登录必须从新填写登录的相关信息。
        （2）保存上次登录的时间等信息。
        （3）保存上次查看的页面
        （4）浏览计数
</code></pre><p><img src="/2018/10/12/web存储/cookie.png" alt="Alt text"><br>        session：<br>            Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。<br>            （1）网上商城中的购物车<br>            （2）保存用户登录信息<br>            （3）将某些数据放入session中，供同一用户的不同页面使用<br>            （4）防止用户非法登录<br>     7、缺点：<br>         cookie：<br>             （1）大小受限<br>             （2）用户可以操作（禁用）cookie，使功能受限<br>             （3）安全性较低<br>             （4）有些状态不可能保存在客户端。<br>             （5）每次访问都要传送cookie给服务器，浪费带宽。<br>             （6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。<br>         session：<br>             （1）Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大<br>             （2）依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全<br>            （3）创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量<br>            将会导致代码不可读而且不好维护</p>
<h2 id="HTML5的本地存储web-Storage-localStroage-sessionStorage"><a href="#HTML5的本地存储web-Storage-localStroage-sessionStorage" class="headerlink" title="HTML5的本地存储web Storage(localStroage,sessionStorage)"></a>HTML5的本地存储web Storage(localStroage,sessionStorage)</h2><h3 id="解释一"><a href="#解释一" class="headerlink" title="解释一:"></a>解释一:</h3><h4 id="HTML5中与本地存储相关的两个重要内容："><a href="#HTML5中与本地存储相关的两个重要内容：" class="headerlink" title="HTML5中与本地存储相关的两个重要内容："></a>HTML5中与本地存储相关的两个重要内容：</h4><pre><code>    Web Storage与本地数据库。其中，Web Storage存储机制是对HTML4中cookie存储机制的一个改善。
由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的WebStorage存储机制。本地
数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器
端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访
问数据的速度。
</code></pre><h4 id="本文主要来讲解Web-Storage"><a href="#本文主要来讲解Web-Storage" class="headerlink" title="本文主要来讲解Web Storage:"></a>本文主要来讲解Web Storage:</h4><pre><code>我们知道，在HTML4中可以使用cookie在客户端保存诸如用户名等简单的用户信息，但是，通过长期的使用，
你会发现，用cookie存储永久数据存在以下几个问题:
1.大小：cookie的大小被限制在4KB。
2.带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。
3.复杂性：要正确的操纵cookie是很困难的。
针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是Web Storage。
具体来说，Web Storage又分为两种：
1.sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到
浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内
所要求保存的任何数据。
2.localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被
关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。
这两者的区别在于，sessionStorage为临时保存，而localStorage为永久保存。
到目前为止，Firefox3.6以上、Chrome6以上、Safari 5以上、Pera10.50以上、IE8以上版本的浏览器支持sessionStorage与localStorage的使用。
</code></pre><h3 id="解释二"><a href="#解释二" class="headerlink" title="解释二:"></a>解释二:</h3><pre><code>WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。
</code></pre><h4 id="WebStorage两个主要目标："><a href="#WebStorage两个主要目标：" class="headerlink" title="WebStorage两个主要目标："></a>WebStorage两个主要目标：</h4><pre><code>（1）提供一种在cookie之外存储会话数据的路径。
（2）提供一种存储大量可以跨会话存在的数据的机制。
</code></pre><h4 id="HTML5的WebStorage提供了两种API："><a href="#HTML5的WebStorage提供了两种API：" class="headerlink" title="HTML5的WebStorage提供了两种API："></a>HTML5的WebStorage提供了两种API：</h4><pre><code>localStorage（本地存储）和sessionStorage（会话存储）。
1、生命周期：
    localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。
    localStorage除非主动删除数据，否则数据永远不会消失。

    sessionStorage:sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”
    的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入
    同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口
    同一个页面，sessionStorage也是不一样的
2、存储大小：
    localStorage和sessionStorage的存储数据大小一般都是：5MB
3、存储位置：
    localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。
4、存储内容类型：
    localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理
5、获取方式：
    localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。
6、应用场景：
    localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；
</code></pre><h4 id="WebStorage的优点："><a href="#WebStorage的优点：" class="headerlink" title="WebStorage的优点："></a>WebStorage的优点：</h4><pre><code>（1）存储空间更大：cookie为4KB，而WebStorage是5MB；
（2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，
    所以减少了客户端和服务器端的交互，节省了网络流量；
（3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；
（4）快速显示：
    有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；
（5）安全性：
        WebStorage不会随着HTTPheader发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；
（6）WebStorage提供了一些方法，数据操作比cookie方便；
        setItem (key, value) ——  保存数据，以键值对的方式储存信息。
        getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。
        removeItem (key) ——  删除单个数据，根据键值移除对应的信息。
        clear () ——  删除所有的数据
        key (index) —— 获取某个索引的key
</code></pre><h2 id="cookie-、sessionStorage与localStorage的区别"><a href="#cookie-、sessionStorage与localStorage的区别" class="headerlink" title="cookie 、sessionStorage与localStorage的区别"></a>cookie 、sessionStorage与localStorage的区别</h2><p><img src="/2018/10/12/web存储/difference.png" alt="Alt text"></p>
<h3 id="cookie使用示例"><a href="#cookie使用示例" class="headerlink" title="cookie使用示例:"></a>cookie使用示例:</h3><pre><code>存储,获取,删除: 
1.存储cookie值:
    function setCookie(key,value,time){
        var oDate = new Date();//获取系统时间
        oDate.setDate(oDate.getDate()+time);//根据来访着的时间来设置过期时间time单位是天
        document.cookie = key+&apos;=&apos;+value+&apos;;expires= &apos;+oDate.toGMTString();
    }
    setCookie(&apos;sex&apos;,&apos;男&apos;,5);
2.获取存储的cookie值:
    方法1:
    function getCookie(c_name) {
        var that = this;　　　　
        if (document.cookie.length &gt; 0) {
            //检查这个cookie是否存在，不存在就为 -1
            c_start = document.cookie.indexOf(c_name + &quot;=&quot;)
            if (c_start != -1) {
                //获取cookie值的开始位置
                c_start = c_start + c_name.length + 1;
                //通过&quot;;&quot;号是否存在来判断结束位置
                c_end = document.cookie.indexOf(&quot;;&quot;, c_start);
                if (c_end == -1){
                    c_end = document.cookie.length;
                }
                //通过substring()得到了值
                return unescape(document.cookie.substring(c_start, c_end))　　 
            }　　　　
        }　　　　
        return &quot;&quot;　　
    }
    方法2:
    function getCookie(key){  
        var arr1 = document.cookie.split(&apos;;&apos;);  
        for(var i=0; i&lt;arr1.length; i++){
            var arr2 = arr1[i].split(&apos;=&apos;);
            &lt;!-- if(arr2[0]==key){
                return decodeURI(arr2[1]);
            } --&gt;
            /*浏览器截取cookie会给key加一个空格,需要去除*/
            if(arr2[0].trim()==key){
                return decodeURI(arr2[1]);
            }
        }
    }
    alert(getCookie(&apos;sex&apos;));
3.如何删除cookie:
    function  removeCookie(key){
            setCookie(key,&apos;&apos;,-1);
        }
        removeCookie(&apos;sex&apos;);
</code></pre><h3 id="sessionStorage与localStorage的使用示例。"><a href="#sessionStorage与localStorage的使用示例。" class="headerlink" title="sessionStorage与localStorage的使用示例。"></a>sessionStorage与localStorage的使用示例。</h3><pre><code>下面具体看一下读写数据时使用的基本方法
</code></pre><h4 id="1-sessionStorage"><a href="#1-sessionStorage" class="headerlink" title="(1)sessionStorage:"></a>(1)sessionStorage:</h4><pre><code>保存数据的方法：
    sessionStorage.setItem(&quot;key&quot;,&quot;value&quot;);
    //或者写成
    sessionStorage.key=&quot;value&quot;;
读取数据的方法：
    变量=sessionStorage.getItem(&quot;key&quot;);
    //或者写成
    变量=sessionStorage.key;
</code></pre><h4 id="2-localStorage"><a href="#2-localStorage" class="headerlink" title="(2)localStorage:"></a>(2)localStorage:</h4><pre><code>    保存数据的方法：
        localStorage.setItem(&quot;key&quot;,&quot;value&quot;);
        //或者写成
        localStorage.key=&quot;value&quot;;
    读取数据的方法：
        变量=localStorage.getItem(&quot;key&quot;);
        //或者写成
        变量=localStorage.key;
    在保存数据时，若使用sessionStorage读取或保存数据，则使用sessionStorage对象并调用该对象的读写方法；
    若使用localStorage读取或保存数据，则使用localStorage对象并调用该对象的读写方法。

    在进行读写时，不管是哪个对象，都可以通过该对象的getItem方法来读取数据，也可以该对象的自定义属性值读取数据；
    可以通过该对象的setItem方法保存数据，也可以通过该对象的自定义属性值保存数据。保存数据时按“键名/键值”的形式
    进行保存。当通过该对象的getItem方法读取数据时，将参数指定为键名，该方法返回键值；当通过该对象的自定义属性值
    读取数据时，可以将该对象的某个自定义属性名作为键名，访问该自定义属性的属性值即可得到键值；当通过该对象的
    setItem方法保存数据时，将第一个参数指定为键名，将第二个参数指定为键值；当通过该对象的自定义属性值保存数据时，
    可以将该对象的某个自定义属性名作为键名，然后直接将该自定义属性值设置为键值。

    在保存数据时不允许重复保存相同的键名。保存后可以修改键值，但不允许修改键名(只能重新取键名，然后再保存键值)。


首先，准备一个用来保存数据和显示数据的网页
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Web Storage 示例&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;h1&gt;Web Storage 示例&lt;/h1&gt;
    &lt;p id=&quot;msg&quot;&gt;&lt;/p&gt;
    &lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;保存数据&quot; onclick=&quot;saveStorage(&apos;input&apos;);&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;读取数据&quot; onclick=&quot;loadStorage(&apos;msg&apos;);&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;删除数据&quot; onclick=&quot;removeStorage(&apos;msg&apos;);&quot; /&gt;
    &lt;/body&gt;
&lt;/html&gt;
单击&quot;保存数据&quot;按钮时调用saveStorage方法保存数据，单击&quot;读取数据&quot;按钮时调用loadStorage方法调用数据，
这两个方法均在脚本文件script.js中，如下：
//sessionStorage 示例  (保存一个会话周期:从打开浏览器——到关闭浏览器窗口)
function saveStorage(id){
    var target=document.getElementById(id);
    var str=target.value;
    sessionStorage.setItem(&quot;message&quot;,str);
    //或者sessionStorage.message=str;
}
function loadStorage(id){
    var target=document.getElementById(id);
    var msg=sessionStorage.getItem(&quot;message&quot;);
    //或者var msg=sessionStorage.message;
    target.innerHTML=msg;
}
function removeStorage(id){
    var target=document.getElementById(&quot;msg&quot;);
    var msg=sessionStorage.removeItem (&quot;message&quot;);
    //或者var msg=localStorage.message;
    target.innerHTML=&quot;&quot;;
}
//localStorage 示例(可永久保存)    
function saveStorage(id){
    var target=document.getElementById(id);
    var str=target.value;
    localStorage.setItem(&quot;message&quot;,str);
    //或者localStorage.message=str;
}
function loadStorage(id){
    var target=document.getElementById(&quot;msg&quot;);
    var msg=localStorage.getItem(&quot;message&quot;);
    //或者var msg=localStorage.message;
    target.innerHTML=msg;
}
function removeStorage(id){
    var target=document.getElementById(&quot;msg&quot;);
    var msg=localStorage.removeItem (&quot;message&quot;);
    //或者var msg=localStorage.message;
    target.innerHTML=&quot;&quot;;
}
这个脚本文件分别使用了sessionStorage与localStorage两种方法。这两种方法都是当用户在input文本框中
输入内容后单击&quot;保存数据&quot;按钮保存数据，单击&quot;读取数据&quot;按钮读取保存后的数据。但是两种方法对数据的处理
方式不一样，在使用sessionStorage方法时，如果关闭了浏览器，这个数据就丢失了，下一次打开浏览器单击
&quot;读取数据&quot;按钮时，读取不到任何数据。在使用localStorage方法时，即使浏览器关闭了，下次打开浏览器时
仍然能够读取保存的数据。不过，数据保存是按不同的浏览器分别进行保存的，也就是说，打开别的浏览器是读
取不到在这个浏览器中保存的数据的。
</code></pre><h4 id="来源"><a href="#来源" class="headerlink" title="来源:"></a>来源:</h4><p><a href="https://www.cnblogs.com/pengc/p/8714475.html" target="_blank" rel="noopener">cookies、sessionStorage和localStorage解释及区别</a><br>参考:<br><a href="https://happyjeannie.github.io/2018/06/27/Session%E3%80%81LocalStorage%E3%80%81Cache-Control/" target="_blank" rel="noopener">Session、LocalStorage、Cache-Control</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/10/Object-assign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/10/Object-assign/" itemprop="url">es6语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-10T22:38:59+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign():"></a>Object.assign():</h1><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法:"></a>1.语法:</h2><pre><code>Object.assign(target, ...sources)
参数:target(目标对象),sources(源对象,源对象可以有多个) 返回值:目标对象
</code></pre><h2 id="2-描述"><a href="#2-描述" class="headerlink" title="2.描述:"></a>2.描述:</h2><pre><code>如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后来的源对象的属性将类似地覆盖早先的属性。

    Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，
所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合
将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 
String类型和 Symbol 类型的属性都会被拷贝。
在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。
注意，Object.assign 不会跳过那些值为 null 或 undefined 的源对象。
</code></pre><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例:"></a>3.示例:</h2><pre><code>1.复制一个对象:
    var obj = { a: 1 };
    var copy = Object.assign({}, obj);
    console.log(copy); // { a: 1 }
2.深拷贝问题:(如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这
    是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。)
    针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。
    function test() {
      //把obj1的属性拷贝到obj2空对象中
      let obj1 = { a: 0 , b: { c: 0}};
      let obj2 = Object.assign({}, obj1);
      console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}

      //修改obj1中的a属性,obj2中的a属性值不会变,因为拷贝的属性值不是一个指向对象的引用,而是一个确定的值
      obj1.a = 1;
      console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}
      console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}

      //同理,修改obj2中的a属性的值,obj1中的a的属性值也不会变
      obj2.a = 2;
      console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}
      console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}

      //修改obj2.b.c的值,obj1.b.c的值也变了,因为obj2拷贝的是obj1.b的对象的引用地址,引用的地址是一样,改变地址内c的值,b指向的值也改变,这是浅拷贝
      obj2.b.c = 3;
      console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}}
      console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}}

      // Deep Clone深拷贝 把obj1的所有属性先转成字符串格式,然后在转成json数组赋值给obj3,此时obj3.b和obj1.b的引用地址不同,所以修改obj1.b.c的值,obj3.b.c不会改变
      obj1 = { a: 0 , b: { c: 0}};
      let obj3 = JSON.parse(JSON.stringify(obj1));
      obj1.a = 4;
      obj1.b.c = 4;
      console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}
    }

    test();
3.合并对象:
    var o1 = { a: 1 };
    var o2 = { b: 2 };
    var o3 = { c: 3 };

    var obj = Object.assign(o1, o2, o3);
    console.log(obj); // { a: 1, b: 2, c: 3 }
    console.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。
4.合并具有相同属性的对象:(属性被后续参数中具有相同属性的其他对象覆盖。)
    var o1 = { a: 1, b: 1, c: 1 };
    var o2 = { b: 2, c: 2 };
    var o3 = { c: 3 };

    var obj = Object.assign({}, o1, o2, o3);
    console.log(obj); // { a: 1, b: 2, c: 3 }
5.拷贝 symbol 类型的属性:
    var o1 = { a: 1 };
    var o2 = { [Symbol(&apos;foo&apos;)]: 2 };

    var obj = Object.assign({}, o1, o2);
    console.log(obj); // { a : 1, [Symbol(&quot;foo&quot;)]: 2 } (cf. bug 1207182 on Firefox)
    Object.getOwnPropertySymbols(obj); // [Symbol(foo)]
6.继承属性和不可枚举属性是不能拷贝的:
    var obj = Object.create({foo: 1}, { // foo 是个继承属性。
        bar: {
            value: 2  // bar 是个不可枚举属性。
        },
        baz: {
            value: 3,
            enumerable: true  // baz 是个自身可枚举属性。
        }
    });

    var copy = Object.assign({}, obj);
    console.log(copy); // { baz: 3 }
7.原始类型会被包装为对象:
    var v1 = &quot;abc&quot;;
    var v2 = true;
    var v3 = 10;
    var v4 = Symbol(&quot;foo&quot;)

    var obj = Object.assign({}, v1, null, v2, undefined, v3, v4); 
    // 原始类型会被包装，null 和 undefined 会被忽略。
    // 注意，只有字符串的包装对象才可能有自身可枚举属性。
    console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }
8.异常会打断后续拷贝任务:
    var target = Object.defineProperty({}, &quot;foo&quot;, {
        value: 1,
        writable: false
    }); // target 的 foo 属性是个只读属性。

    Object.assign(target, {bar: 2}, {foo2: 3, foo: 3, foo3: 3}, {baz: 4});
    // TypeError: &quot;foo&quot; is read-only
    // 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。

    console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。
    console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。
    console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。
    console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。
    console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。
9.拷贝访问器:
var obj = {
  foo: 1,
  get bar() {
    return 2;
  }
};

var copy = Object.assign({}, obj); 
// { foo: 1, bar: 2 }
// copy.bar的值来自obj.bar的getter函数的返回值 
console.log(copy); 

// 下面这个函数会拷贝所有自有属性的属性描述符
function completeAssign(target, ...sources) {
  sources.forEach(source =&gt; {
    let descriptors = Object.keys(source).reduce((descriptors, key) =&gt; {
      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors;
    }, {});

    // Object.assign 默认也会拷贝可枚举的Symbols
    Object.getOwnPropertySymbols(source).forEach(sym =&gt; {
      let descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}

var copy = completeAssign({}, obj);
console.log(copy);
// { foo:1, get bar() { return 2 } }
</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">点击查看参考网址</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/项目中关于url截取和rem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/项目中关于url截取和rem/" itemprop="url">url截取和rem</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-11T11:17:12+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-关于截取url参数的方法"><a href="#1-关于截取url参数的方法" class="headerlink" title="1.关于截取url参数的方法:"></a>1.关于截取url参数的方法:</h3><pre><code>//当url传递参数加密带有等号的时候处理如下:
//url地址Wie:www.baidu.com?adviserId=qTe+oWBY2QNNf/eRZ/9t6w==&amp;userId=ZA15nBxtd2iAWXFetHGzaJ0IJvB+pTXeJ45tRhXiCRFxmE8aSMm6w0YJLHzqPjMd
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">	params:&#123;&#125;,</span><br><span class="line">	init:function()&#123;</span><br><span class="line">		this.getParams();</span><br><span class="line">		&#125;,</span><br><span class="line">	getParams:function()&#123;</span><br><span class="line">          // 获取参数</span><br><span class="line">          //不存在参数的时候return掉</span><br><span class="line">          if(window.location.href.indexOf(&apos;?&apos;) === -1)&#123;</span><br><span class="line">                  return</span><br><span class="line">           &#125;</span><br><span class="line">          let data = window.location.href.split(&apos;?&apos;)[1];</span><br><span class="line">          let arr = data.split(&apos;&amp;&apos;);</span><br><span class="line">          console.log(arr);</span><br><span class="line">          let params = &#123;&#125;;</span><br><span class="line">          for(let i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">              params[arr[i].slice(0,arr[i].indexOf(&apos;=&apos;))]=arr[i].slice(arr[i].indexOf(&apos;=&apos;)+1,arr[i].length);</span><br><span class="line">          &#125;</span><br><span class="line">          this.params = params;</span><br><span class="line">          console.log(params);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.init();</span><br></pre></td></tr></table></figure>
<pre><code> 返回的结果是:
     //{adviserId: &quot;qTe+oWBY2QNNf/eRZ/9t6w==&quot;, userId: &quot;ZA15nBxtd2iAWXFetHGzaJ0IJvB+pTXeJ45tRhXiCRFxmE8aSMm6w0YJLHzqPjMd&quot;}
这时候调接口的时候就可以吧this.params传进去即可.
</code></pre><h3 id="2-rem布局"><a href="#2-rem布局" class="headerlink" title="2.rem布局:"></a>2.rem布局:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">	在用rem布局h5页面时,根据手机浏览器大小动态改变rem的大小,这里1rem=100px</span><br><span class="line">	每个页面加载时调用</span><br><span class="line">	/*注意,</span><br><span class="line">	1.有时候用rem回去屏幕宽度还会获取不到宽度显示0,这个时候需要给加个setTimeout延迟获取下,</span><br><span class="line">	    参考:(移动端rem布局，加载瞬间页面缩小)https://blog.csdn.net/maggie_live/article/details/80262312</span><br><span class="line">	2.一开始让body隐藏,初始化完rem的html字体大小后再显示body,可以防止head中的css样式和body中的并行加载</span><br><span class="line">	    参考:(Head标签中JS和CSS前后关系执行效率对比)https://blog.csdn.net/uohzoaix/article/details/7299054</span><br><span class="line">	*/</span><br><span class="line">	    /*动态调整rem值,除以100*/</span><br><span class="line">```$xslt</span><br><span class="line">      function setsize() &#123;</span><br><span class="line">          var winW = document.documentElement.clientWidth,</span><br><span class="line">              winH = document.documentElement.clientHeight,</span><br><span class="line">              baseFontSize = 100,</span><br><span class="line">              baseWidth = 750,</span><br><span class="line">              winWidthSize = Math.min(winW, winH);</span><br><span class="line">          if (winWidthSize &lt; 270) &#123;</span><br><span class="line">              winWidthSize = 270;</span><br><span class="line">          &#125;</span><br><span class="line">          var _html = document.getElementsByTagName(&apos;html&apos;)[0];</span><br><span class="line">          _html.style.fontSize =winWidthSize / baseWidth * baseFontSize + &apos;px&apos;;</span><br><span class="line">            /*处理rem偶尔获取不到屏幕宽度问题*/</span><br><span class="line">                  setTimeout(function()&#123;</span><br><span class="line">                    document.getElementsByTagName(&apos;body&apos;)[0].style.visibility=&apos;visible&apos;;</span><br><span class="line">                  &#125;,1)</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(setsize,1);</span><br><span class="line">      &lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">        &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</span><br><span class="line">        &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">        &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">        &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">          /*动态调整rem值,除以100*/</span><br><span class="line">          function setsize() &#123;</span><br><span class="line">            var winW = document.documentElement.clientWidth,</span><br><span class="line">              winH = document.documentElement.clientHeight,</span><br><span class="line">              baseFontSize = 100,</span><br><span class="line">              baseWidth = 750,</span><br><span class="line">              winWidthSize = Math.min(winW, winH);</span><br><span class="line">            if (winWidthSize &lt; 270) &#123;</span><br><span class="line">              winWidthSize = 270;</span><br><span class="line">            &#125;else if(winWidthSize &gt; 750)&#123;</span><br><span class="line">              winWidthSize = 750;</span><br><span class="line">            &#125;</span><br><span class="line">            var _html = document.getElementsByTagName(&apos;html&apos;)[0];</span><br><span class="line">            _html.style.fontSize = winWidthSize / baseWidth * baseFontSize + &apos;px&apos;;</span><br><span class="line">            /*处理rem偶尔获取不到屏幕宽度问题*/</span><br><span class="line">                              setTimeout(function()&#123;</span><br><span class="line">                                document.getElementsByTagName(&apos;body&apos;)[0].style.visibility=&apos;visible&apos;;</span><br><span class="line">                              &#125;,1)</span><br><span class="line">          &#125;</span><br><span class="line">           setTimeout(setsize,1);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">      &lt;/head&gt;</span><br><span class="line">      &lt;body style=&quot;visibility:hidden;&quot;&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-h5页面上拉刷新加载更多数据"><a href="#3-h5页面上拉刷新加载更多数据" class="headerlink" title="3.h5页面上拉刷新加载更多数据:"></a>3.h5页面上拉刷新加载更多数据:</h3><p><a href="https://www.cnblogs.com/zuobaiquan01/p/8874305.html" target="_blank" rel="noopener">借鉴H5下拉刷新和上拉加载实现原理浅析</a><br>  (function(window) {<br>     // 获取当前滚动条的位置<br>        function getScrollTop() {<br>            var scrollTop = 0;<br>            if (document.documentElement &amp;&amp; document.documentElement.scrollTop) {<br>                scrollTop = document.documentElement.scrollTop;<br>            } else if (document.body) {<br>                scrollTop = document.body.scrollTop;<br>            }<br>            return scrollTop;<br>        }</p>
<pre><code>// 获取当前可视范围的高度
function getClientHeight() {
    var clientHeight = 0;
    if (document.body.clientHeight &amp;&amp; document.documentElement.clientHeight) {
        clientHeight = Math.min(document.body.clientHeight, document.documentElement.clientHeight);
    }
    else {
        clientHeight = Math.max(document.body.clientHeight, document.documentElement.clientHeight);
    }
    return clientHeight;
}

// 获取文档完整的高度
function getScrollHeight() {
    return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
}

var _text = document.querySelector(&apos;.refreshText&apos;),
    _container = document.querySelector(&apos;.loan-content&apos;);

// 节流函数
var throttle = function(method, context){
    clearTimeout(method.tId);
    method.tId = setTimeout(function(){
        method.call(context);
    }, 1000);
}
function fetchData() {
  //loanList.pageNumber当前页,loanList.pageTotal总页数
    if(loanList.pageNumber&lt;=loanList.pageTotal){
        customerLendList({
            data:{data:{
                    xxxx
                }},
            success:function(res){
                console.log(&apos;xxx请求成功&apos;);
                console.log(res)
                  ......
                  .......
            },
            fail:function(){
                console.log(&apos;请求失败&apos;);
            }
        })
    }else{
        _text.innerText = &apos;没有数据啦，加油推广吧~&apos;;
        loanList.loading=false;
    }
}
window.onscroll = function() {
  //首次加载完所有数据后loanList.loading为false
    if(loanList.loading){
        if (getScrollTop() + getClientHeight()+10 &gt;= getScrollHeight()) {
                _text.innerText = &apos;加载中...&apos;;
            throttle(fetchData);
        }
    }
};
</code></pre><p>  })(window)</p>
<h3 id="4-Array-filter-方法"><a href="#4-Array-filter-方法" class="headerlink" title="4.Array.filter()方法:"></a>4.Array.filter()方法:</h3><pre><code>利用array.filter()方法过滤符合条件的数据
如:过滤年龄大于20岁的数据
var data=[
  {age:20,name:&apos;lcl&apos;},
  {age:18,name:&apos;lcl&apos;},
  {age:19,name:&apos;lcl&apos;},
  {age:21,name:&apos;lcl&apos;},
  {age:22,name:&apos;lcl&apos;}
]
var result=data.filter(function(item){
  return data.age&gt;20;
  })
  console.log(result);
  //{age: 21, name: &quot;lcl&quot;},{age: 22, name: &quot;lcl&quot;}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
