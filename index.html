<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/js高级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/js高级/" itemprop="url">js高级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-05T18:19:36+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>学习目标:</p>
<ul>
<li>理解面向对象开发思想</li>
<li>掌握 JavaScript 面向对象开发相关模式</li>
<li>掌握在 JavaScript 中使用正则表达式</li>
<li>typora-copy-images-to media</li>
</ul>
<hr>
<h1 id="JavaScript-高级"><a href="#JavaScript-高级" class="headerlink" title="JavaScript 高级"></a>JavaScript 高级</h1><p><img src="/2019/03/05/js高级/Unofficial_JavaScript_logo_2.svg.png" alt="Alt text">;</p>
<h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><h3 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h3><p>在线地址：<a href="http://naotu.baidu.com/file/5bcd79bc4f1eaf83f96d1ad23baab345?token=d22135c63546f5ee" target="_blank" rel="noopener">JavaScript 高级</a></p>
<p><img src="/2019/03/05/js高级/课程大纲.png" alt="Alt text"></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>理解面向对象开发思想</li>
<li>掌握 JavaScript 面向对象开发相关模式</li>
<li>掌握在 JavaScript 中使用正则表达式</li>
</ul>
<h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><ul>
<li><a href="https://lipengzhou.github.io/new-snake/" target="_blank" rel="noopener">贪吃蛇</a></li>
</ul>
<hr>
<h2 id="基本概念复习"><a href="#基本概念复习" class="headerlink" title="基本概念复习"></a>基本概念复习</h2><blockquote>
<p>由于 JavaScript 高级还是针对 JavaScript 语言本身的一个进阶学习，所以在开始之前我们先对以前所学过的 JavaScript 相关知识点做一个快速复习总结。</p>
</blockquote>
<h3 id="重新介绍-JavaScript"><a href="#重新介绍-JavaScript" class="headerlink" title="重新介绍 JavaScript"></a>重新介绍 JavaScript</h3><h4 id="JavaScript-是什么"><a href="#JavaScript-是什么" class="headerlink" title="JavaScript 是什么"></a>JavaScript 是什么</h4><ul>
<li>解析执行：轻量级解释型的，或是 JIT 编译型的程序设计语言</li>
<li>语言特点：动态，头等函数 (First-class Function)<ul>
<li>又称函数是 JavaScript 中的一等公民</li>
</ul>
</li>
<li>执行环境：在宿主环境（host environment）下运行，浏览器是最常见的 JavaScript 宿主环境<ul>
<li>但是在很多非浏览器环境中也使用 JavaScript ，例如 node.js</li>
</ul>
</li>
<li>编程范式：基于原型、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如：函数式编程）编程风格</li>
</ul>
<h4 id="JavaScript-与浏览器的关系"><a href="#JavaScript-与浏览器的关系" class="headerlink" title="JavaScript 与浏览器的关系"></a>JavaScript 与浏览器的关系</h4><p><img src="/2019/03/05/js高级/media/browser-js.png" alt=""></p>
<h4 id="JavaScript-的组成"><a href="#JavaScript-的组成" class="headerlink" title="JavaScript 的组成"></a>JavaScript 的组成</h4><table>
<thead>
<tr>
<th>组成部分</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ecmascript</td>
<td>描述了该语言的语法和基本对象</td>
</tr>
<tr>
<td>DOM</td>
<td>描述了处理网页内容的方法和接口</td>
</tr>
<tr>
<td>BOM</td>
<td>描述了与浏览器进行交互的方法和接口</td>
</tr>
</tbody>
</table>
<h4 id="JavaScript-可以做什么"><a href="#JavaScript-可以做什么" class="headerlink" title="JavaScript 可以做什么"></a>JavaScript 可以做什么</h4><blockquote>
<p>Any application that can be written in JavaScript, will eventually be written in JavaScript.<br>凡是能用 JavaScript 写出来的，最终都会用 JavaScript 写出来</p>
</blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/20796866" target="_blank" rel="noopener">知乎 - JavaScript 能做什么，该做什么？</a></li>
<li><a href="https://github.com/phodal/articles/issues/1" target="_blank" rel="noopener">最流行的编程语言 JavaScript 能做什么？</a></li>
</ul>
<h4 id="JavaScript-发展历史"><a href="#JavaScript-发展历史" class="headerlink" title="JavaScript 发展历史"></a>JavaScript 发展历史</h4><blockquote>
<p><a href="http://javascript.ruanyifeng.com/introduction/history.html" target="_blank" rel="noopener">JavaScript 标准参考教程 - JavaScript 语言的历史</a></p>
</blockquote>
<ul>
<li>JavaScript 的诞生</li>
<li>JavaScript 与 Ecmascript 的关系</li>
<li>JavaScript 与 Java 的关系</li>
<li>JavaScript 的版本</li>
<li>JavaScript 周边大事记</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>本小节快速过即可，主要是对学过的内容做知识点梳理。</p>
</blockquote>
<ul>
<li>语法<ul>
<li>区分大小写</li>
<li>标识符</li>
<li>注释</li>
<li>严格模式</li>
<li>语句</li>
</ul>
</li>
<li>关键字和保留字</li>
<li>变量</li>
<li>数据类型<ul>
<li>typeof 操作符</li>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Object</li>
</ul>
</li>
<li>操作符</li>
<li>流程控制语句</li>
<li>函数</li>
</ul>
<h3 id="JavaScript-中的数据类型"><a href="#JavaScript-中的数据类型" class="headerlink" title="JavaScript 中的数据类型"></a>JavaScript 中的数据类型</h3><p>JavaScript 有 5 种简单数据类型：<code>Undefined、Null、Boolean、Number、String</code> 和 1 种复杂数据类型 <code>Object</code> 。</p>
<h4 id="基本类型（值类型）"><a href="#基本类型（值类型）" class="headerlink" title="基本类型（值类型）"></a>基本类型（值类型）</h4><ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ul>
<h4 id="复杂类型（引用类型）"><a href="#复杂类型（引用类型）" class="headerlink" title="复杂类型（引用类型）"></a>复杂类型（引用类型）</h4><ul>
<li>Object</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Function</li>
<li>基本包装类型<ul>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ul>
</li>
<li>单体内置对象<ul>
<li>Global</li>
<li>Math</li>
</ul>
</li>
</ul>
<h4 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h4><ul>
<li><code>typeof</code></li>
<li><code>instanceof</code></li>
<li><code>Object.prototype.toString.call()</code></li>
</ul>
<h4 id="值类型和引用类型在内存中的存储方式（画图说明）"><a href="#值类型和引用类型在内存中的存储方式（画图说明）" class="headerlink" title="值类型和引用类型在内存中的存储方式（画图说明）"></a>值类型和引用类型在内存中的存储方式（画图说明）</h4><ul>
<li>值类型按值存储</li>
<li>引用类型按引用存储</li>
</ul>
<h4 id="值类型复制和引用类型复制（画图说明）"><a href="#值类型复制和引用类型复制（画图说明）" class="headerlink" title="值类型复制和引用类型复制（画图说明）"></a>值类型复制和引用类型复制（画图说明）</h4><ul>
<li>值类型按值复制</li>
<li>引用类型按引用复制</li>
</ul>
<h4 id="值类型和引用类型参数传递（画图说明）"><a href="#值类型和引用类型参数传递（画图说明）" class="headerlink" title="值类型和引用类型参数传递（画图说明）"></a>值类型和引用类型参数传递（画图说明）</h4><ul>
<li>值类型按值传递</li>
<li>引用类型按引用传递</li>
</ul>
<h4 id="值类型与引用类型的差别"><a href="#值类型与引用类型的差别" class="headerlink" title="值类型与引用类型的差别"></a>值类型与引用类型的差别</h4><ul>
<li>基本类型在内存中占据固定大小的空间，因此被保存在栈内存中</li>
<li>从一个变量向另一个变量复制基本类型的值，复制的是值的副本</li>
<li>引用类型的值是对象，保存在堆内存</li>
<li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针</li>
<li>从一个变量向另一个变量复制引用类型的值的时候，复制是引用指针，因此两个变量最终都指向同一个对象</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>类型检测方式</li>
<li>值类型和引用类型的存储方式</li>
<li>值类型复制和引用类型复制</li>
<li>方法参数中 值类型数据传递 和 引用类型数据传递</li>
</ul>
<h3 id="JavaScript-执行过程"><a href="#JavaScript-执行过程" class="headerlink" title="JavaScript 执行过程"></a>JavaScript 执行过程</h3><p>JavaScript 运行分为两个阶段：</p>
<ul>
<li>预解析<ul>
<li>全局预解析（所有变量和函数声明都会提前；同名的函数和变量函数的优先级高）</li>
<li>函数内部预解析（所有的变量、函数和形参都会参与预解析）<ul>
<li>函数</li>
<li>形参</li>
<li>普通变量</li>
</ul>
</li>
</ul>
</li>
<li>执行</li>
</ul>
<p>先预解析全局作用域，然后执行全局作用域中的代码，<br>在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码。</p>
<hr>
<h2 id="JavaScript-面向对象编程"><a href="#JavaScript-面向对象编程" class="headerlink" title="JavaScript 面向对象编程"></a>JavaScript 面向对象编程</h2><p><img src="/2019/03/05/js高级/mxdxkf.png" alt="Alt text">;</p>
<h3 id="面向对象介绍"><a href="#面向对象介绍" class="headerlink" title="面向对象介绍"></a>面向对象介绍</h3><h4 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h4><blockquote>
<p>Everything is object （万物皆对象）</p>
</blockquote>
<p><img src="/2019/03/05/js高级/20160823024542444.jpg" alt="Alt text">;<br>对象到底是什么，我们可以从两次层次来理解。</p>
<p><strong>(1) 对象是单个事物的抽象。</strong></p>
<p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p>
<p><strong>(2) 对象是一个容器，封装了属性（property）和方法（method）。</strong></p>
<p>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p>
<p>在实际开发中，对象是一个抽象的概念，可以将其简单理解为：<strong>数据集或功能集</strong>。</p>
<p>ECMAScript-262 把对象定义为：<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>。<br>严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都<br>映射到一个值。</p>
<p class="tip"><br>  提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。<br></p>

<h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><blockquote>
<p>面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。</p>
</blockquote>
<p><img src="/2019/03/05/js高级/664ba37eeee9f4623c06c066867f1d38_r.jpg" alt="Alt text">;<br>面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。<br>它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。<br>因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p>
<p>面向对象与面向过程：</p>
<ul>
<li>面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊</li>
<li>面向对象就是找一个对象，指挥得结果</li>
<li>面向对象将执行者转变成指挥者</li>
<li>面向对象不是面向过程的替代，而是面向过程的封装</li>
</ul>
<p>面向对象的特性：</p>
<ul>
<li>封装性</li>
<li>继承性</li>
<li>[多态性]</li>
</ul>
<p>扩展阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">维基百科 - 面向对象程序设计</a></li>
<li><a href="https://www.zhihu.com/question/19854505" target="_blank" rel="noopener">知乎：如何用一句话说明什么是面向对象思想？</a></li>
<li><a href="https://www.zhihu.com/question/31021366" target="_blank" rel="noopener">知乎：什么是面向对象编程思想？</a></li>
</ul>
<h4 id="程序中面向对象的基本体现"><a href="#程序中面向对象的基本体现" class="headerlink" title="程序中面向对象的基本体现"></a>程序中面向对象的基本体现</h4><p>在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。<br>自定义的对象数据类型就是面向对象中的类（ Class ）的概念。</p>
<p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。</p>
<p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个对象表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> std1 = &#123; <span class="attr">name</span>: <span class="string">'Michael'</span>, <span class="attr">score</span>: <span class="number">98</span> &#125;</span><br><span class="line"><span class="keyword">var</span> std2 = &#123; <span class="attr">name</span>: <span class="string">'Bob'</span>, <span class="attr">score</span>: <span class="number">81</span> &#125;</span><br></pre></td></tr></table></figure>
<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printScore</span> (<span class="params">student</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'姓名：'</span> + student.name + <span class="string">'  '</span> + <span class="string">'成绩：'</span> + student.score)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，<br>而是 <code>Student</code> 这种数据类型应该被视为一个对象，这个对象拥有 <code>name</code> 和 <code>score</code> 这两个属性（Property）。<br>如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 <code>printScore</code> 消息，让对象自己把自己的数据打印出来。</p>
<p>抽象数据行为模板（Class）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, score</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.score = score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.printScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'姓名：'</span> + <span class="keyword">this</span>.name + <span class="string">'  '</span> + <span class="string">'成绩：'</span> + <span class="keyword">this</span>.score)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据模板创建具体实例对象（Instance）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> std1 = <span class="keyword">new</span> Student(<span class="string">'Michael'</span>, <span class="number">98</span>)</span><br><span class="line"><span class="keyword">var</span> std2 = <span class="keyword">new</span> Student(<span class="string">'Bob'</span>, <span class="number">81</span>)</span><br></pre></td></tr></table></figure>
<p>实例对象具有自己的具体行为（给对象发消息）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std1.printScore() <span class="comment">// =&gt; 姓名：Michael  成绩：98</span></span><br><span class="line">std2.printScore() <span class="comment">// =&gt; 姓名：Bob  成绩 81</span></span><br></pre></td></tr></table></figure>
<p>面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。<br>Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念，<br>而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。</p>
<p>所以，面向对象的设计思想是：</p>
<ul>
<li>抽象出 Class</li>
<li>根据 Class 创建 Instance</li>
<li>指挥 Instance 得结果</li>
</ul>
<p>面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="简单方式"><a href="#简单方式" class="headerlink" title="简单方式"></a>简单方式</h4><p>我们可以直接通过 <code>new Object()</code> 创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">'Jack'</span></span><br><span class="line">person.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次创建通过 <code>new Object()</code> 比较麻烦，所以可以通过它的简写形式对象字面量来创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的写法固然没有问题，但是假如我们要生成两个 <code>person</code> 实例对象呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Mike'</span>,</span><br><span class="line">  age: <span class="number">16</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。</p>
<h4 id="简单方式的改进：工厂函数"><a href="#简单方式的改进：工厂函数" class="headerlink" title="简单方式的改进：工厂函数"></a>简单方式的改进：工厂函数</h4><p>我们可以写一个函数，解决代码重复问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后生成实例对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">'Jack'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">'Mike'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>这样封装确实爽多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题，<br>但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>内容引导：</p>
<ul>
<li>构造函数语法</li>
<li>分析构造函数</li>
<li>构造函数和实例对象的关系<ul>
<li>实例的 constructor 属性</li>
<li>instanceof 操作符</li>
</ul>
</li>
<li>普通函数调用和构造函数调用的区别</li>
<li>构造函数的返回值</li>
<li>构造函数的静态成员和实例成员<ul>
<li>函数也是对象</li>
<li>实例成员</li>
<li>静态成员</li>
</ul>
</li>
<li>构造函数的问题</li>
</ul>
<h4 id="更优雅的工厂函数：构造函数"><a href="#更优雅的工厂函数：构造函数" class="headerlink" title="更优雅的工厂函数：构造函数"></a>更优雅的工厂函数：构造函数</h4><p>一种更优雅的工厂函数就是下面这样，构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">18</span>)</span><br><span class="line">p1.sayName() <span class="comment">// =&gt; Jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Mike'</span>, <span class="number">23</span>)</span><br><span class="line">p2.sayName() <span class="comment">// =&gt; Mike</span></span><br></pre></td></tr></table></figure>
<h4 id="解析构造函数代码的执行"><a href="#解析构造函数代码的执行" class="headerlink" title="解析构造函数代码的执行"></a>解析构造函数代码的执行</h4><p>在上面的示例中，<code>Person()</code> 函数取代了 <code>createPerson()</code> 函数，但是实现效果是一样的。<br>这是为什么呢？</p>
<p>我们注意到，<code>Person()</code> 中的代码与 <code>createPerson()</code> 有以下几点不同之处：</p>
<ul>
<li>没有显示的创建对象</li>
<li>直接将属性和方法赋给了 <code>this</code> 对象</li>
<li>没有 <code>return</code> 语句</li>
<li>函数名使用的是大写的 <code>Person</code></li>
</ul>
<p>而要创建 <code>Person</code> 实例，则必须使用 <code>new</code> 操作符。<br>以这种方式调用构造函数会经历以下 4 个步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ol>
<p>下面是具体的伪代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象</span></span><br><span class="line">  <span class="comment">// var instance = &#123;&#125;</span></span><br><span class="line">  <span class="comment">// 然后让内部的 this 指向 instance 对象</span></span><br><span class="line">  <span class="comment">// this = instance</span></span><br><span class="line">  <span class="comment">// 接下来所有针对 this 的操作实际上操作的就是 instance</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在函数的结尾处会将 this 返回，也就是 instance</span></span><br><span class="line">  <span class="comment">// return this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数和实例对象的关系"><a href="#构造函数和实例对象的关系" class="headerlink" title="构造函数和实例对象的关系"></a>构造函数和实例对象的关系</h4><p>使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。<br>在每一个实例对象中的__proto__中同时有一个 <code>constructor</code> 属性，该属性指向创建该实例的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1.constructor === Person) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor === Person) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor === p2.constructor) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>对象的 <code>constructor</code> 属性最初是用来标识对象类型的，<br>但是，如果要检测对象的类型，还是使用 <code>instanceof</code> 操作符更可靠一些：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>构造函数是根据具体的事物抽象出来的抽象模板</li>
<li>实例对象是根据抽象的构造函数模板得到的具体实例对象</li>
<li>每一个实例对象都具有一个 <code>constructor</code> 属性，指向创建该实例的构造函数<ul>
<li>注意： <code>constructor</code> 是实例的属性的说法不严谨，具体后面的原型会讲到</li>
</ul>
</li>
<li>可以通过实例的 <code>constructor</code> 属性判断实例和构造函数之间的关系<ul>
<li>注意：这种方式不严谨，推荐使用 <code>instanceof</code> 操作符，后面学原型会解释为什么</li>
</ul>
</li>
</ul>
<h4 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h4><p>使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'human'</span></span><br><span class="line">  <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'lpz'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>在该示例中，从表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。<br>那就是对于每一个实例对象，<code>type</code> 和 <code>sayHello</code> 都是一模一样的内容，<br>每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>
<p>对于这种问题我们可以把需要共享的函数定义到构造函数外部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> = <span class="title">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hello '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name</span><br><span class="line">      <span class="keyword">this</span>.age = age</span><br><span class="line">      <span class="keyword">this</span>.type = <span class="string">'human'</span></span><br><span class="line">      <span class="keyword">this</span>.sayHello = sayHello</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'lpz'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>这样确实可以了，但是如果有多个需要共享的函数的话就会造成全局命名空间冲突的问题。</p>
<p>你肯定想到了可以把多个函数放到一个对象中用来避免全局命名空间冲突的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fns = &#123;</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  sayAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'human'</span></span><br><span class="line">  <span class="keyword">this</span>.sayHello = fns.sayHello</span><br><span class="line">  <span class="keyword">this</span>.sayAge = fns.sayAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'lpz'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayAge === p2.sayAge) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>至此，我们利用自己的方式基本上解决了构造函数的内存浪费问题。<br>但是代码看起来还是那么的格格不入，那有没有更好的方式呢？</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>构造函数语法</li>
<li>分析构造函数</li>
<li>构造函数和实例对象的关系<ul>
<li>实例的 constructor 属性</li>
<li>instanceof 操作符</li>
</ul>
</li>
<li>构造函数的问题</li>
</ul>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>内容引导：</p>
<ul>
<li>使用 prototype 原型对象解决构造函数的问题</li>
<li>分析 构造函数、prototype 原型对象、实例对象 三者之间的关系</li>
<li>属性成员搜索原则：原型链</li>
<li>实例对象读写原型对象中的成员</li>
<li>原型对象的简写形式</li>
<li>原生对象的原型<ul>
<li>Object</li>
<li>Array</li>
<li>String</li>
<li>…</li>
</ul>
</li>
<li>原型对象的问题</li>
<li>构造的函数和原型对象使用建议</li>
</ul>
<h4 id="更好的解决方案：-prototype"><a href="#更好的解决方案：-prototype" class="headerlink" title="更好的解决方案： prototype"></a>更好的解决方案： <code>prototype</code></h4><p>Javascript 规定，每一个构造函数都有一个 <code>prototype</code> 属性，指向另一个对象。<br>这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 <code>prototype</code> 对象上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line"></span><br><span class="line">Person.prototype.type = <span class="string">'human'</span></span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(...)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(...)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>这时所有实例的 <code>type</code> 属性和 <code>sayName()</code> 方法，<br>其实都是同一个内存地址，指向 <code>prototype</code> 对象，因此就提高了运行效率。</p>
<h4 id="构造函数、实例、原型三者之间的关系"><a href="#构造函数、实例、原型三者之间的关系" class="headerlink" title="构造函数、实例、原型三者之间的关系"></a>构造函数、实例、原型三者之间的关系</h4><p><img src="/2019/03/05/js高级/构造函数-实例-原型之间的关系.png" alt="Alt text">;<br>任何函数都具有一个 <code>prototype</code> 属性，该属性是一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(F.prototype) <span class="comment">// =&gt; object</span></span><br><span class="line"></span><br><span class="line">F.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数的 <code>prototype</code> 对象默认都有一个 <code>constructor</code> 属性，指向 <code>prototype</code> 对象所在函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(F.constructor === F) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> F()</span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__ === F.prototype) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p class="tip"><br>  <code>__proto__</code> 是非标准属性。<br></p>

<p>实例对象可以直接访问原型对象成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.sayHi() <span class="comment">// =&gt; hi!</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>任何函数都具有一个 <code>prototype</code> 属性，该属性是一个对象</li>
<li>构造函数的 <code>prototype</code> 对象默认都有一个 <code>constructor</code> 属性，指向 <code>prototype</code> 对象所在函数</li>
<li>通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code></li>
<li>所有实例都直接或间接继承了原型对象的成员</li>
</ul>
<h4 id="属性成员的搜索原则：原型链"><a href="#属性成员的搜索原则：原型链" class="headerlink" title="属性成员的搜索原则：原型链"></a>属性成员的搜索原则：原型链</h4><p>了解了 <strong>构造函数-实例-原型对象</strong> 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。</p>
<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性</p>
<ul>
<li>搜索首先从对象实例本身开始</li>
<li>如果在实例中找到了具有给定名字的属性，则返回该属性的值</li>
<li>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性</li>
<li>如果在原型对象中找到了这个属性，则返回该属性的值</li>
</ul>
<p>也就是说，在我们调用 <code>person1.sayName()</code> 的时候，会先后执行两次搜索：</p>
<ul>
<li>首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。</li>
<li>”然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。</li>
<li>”于是，它就读取那个保存在原型对象中的函数。</li>
<li>当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。</li>
</ul>
<p>而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p>
<p>总结：</p>
<ul>
<li>先在自己身上找，找到即返回</li>
<li>自己身上找不到，则沿着原型链向上查找，找到即返回</li>
<li>如果一直到原型链的末端还没有找到，则返回 <code>undefined</code></li>
</ul>
<h4 id="实例对象读写原型对象成员"><a href="#实例对象读写原型对象成员" class="headerlink" title="实例对象读写原型对象成员"></a>实例对象读写原型对象成员</h4><p>读取：</p>
<ul>
<li>先在自己身上找，找到即返回</li>
<li>自己身上找不到，则沿着原型链向上查找，找到即返回</li>
<li>如果一直到原型链的末端还没有找到，则返回 <code>undefined</code></li>
</ul>
<p>值类型成员写入（<code>实例对象.值类型成员 = xx</code>）：</p>
<ul>
<li>当实例期望重写原型对象中的某个普通数据成员时实际上会把该成员添加到自己身上</li>
<li>也就是说该行为实际上会屏蔽掉对原型对象成员的访问</li>
</ul>
<p>引用类型成员写入（<code>实例对象.引用类型成员 = xx</code>）：</p>
<ul>
<li>同上</li>
</ul>
<p>复杂类型修改（<code>实例对象.成员.xx = xx</code>）：</p>
<ul>
<li>同样会先在自己身上找该成员，如果自己身上找到则直接修改</li>
<li>如果自己身上找不到，则沿着原型链继续查找，如果找到则修改</li>
<li>如果一直到原型链的末端还没有找到该成员，则报错（<code>实例对象.undefined.xx = xx</code>）</li>
</ul>
<h4 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h4><p>我们注意到，前面例子中每添加一个属性和方法就要敲一遍 <code>Person.prototype</code> 。<br>为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  type: <span class="string">'human'</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name + <span class="string">'，我今年'</span> + <span class="keyword">this</span>.age + <span class="string">'岁了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该示例中，我们将 <code>Person.prototype</code> 重置到了一个新的对象。<br>这样做的好处就是为 <code>Person.prototype</code> 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 <code>constructor</code> 成员。</p>
<p>所以，我们为了保持 <code>constructor</code> 的指向正确，建议的写法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person, // =&gt; 手动将 <span class="keyword">constructor</span> 指向正确的构造函数</span><br><span class="line">  type: 'human',</span><br><span class="line">  sayHello: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name + <span class="string">'，我今年'</span> + <span class="keyword">this</span>.age + <span class="string">'岁了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h4><p class="tip"><br>  所有函数都有 prototype 属性对象。<br></p>

<ul>
<li>Object.prototype</li>
<li>Function.prototype</li>
<li>Array.prototype</li>
<li>String.prototype</li>
<li>Number.prototype</li>
<li>Date.prototype</li>
<li>…</li>
</ul>
<p>练习：为数组对象和字符串对象扩展原型方法。</p>
<h4 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h4><ul>
<li>共享数组</li>
<li>共享对象</li>
</ul>
<p>如果真的希望可以被实例对象之间共享和修改这些共享数据那就不是问题。但是如果不希望实例之间共享和修改这些共享数据则就是问题。</p>
<p>一个更好的建议是，最好不要让实例之间互相共享这些数组或者对象成员，一旦修改的话会导致数据的走向很不明确而且难以维护。</p>
<h4 id="原型对象使用建议"><a href="#原型对象使用建议" class="headerlink" title="原型对象使用建议"></a>原型对象使用建议</h4><ul>
<li>私有成员（一般就是非函数成员）放到构造函数中</li>
<li>共享成员（一般就是函数）放到原型对象中</li>
<li>如果重置了 <code>prototype</code> 记得修正 <code>constructor</code> 的指向<h3 id="实例对象-构造函数-原型对象图"><a href="#实例对象-构造函数-原型对象图" class="headerlink" title="实例对象,构造函数,原型对象图"></a>实例对象,构造函数,原型对象图</h3></li>
</ul>
<h4 id="逆推继承看原型"><a href="#逆推继承看原型" class="headerlink" title="逆推继承看原型:"></a>逆推继承看原型:</h4><p><img src="/2019/03/05/js高级/逆推继承看原型.png" alt="Alt text">;</p>
<h4 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链:"></a>原型及原型链:</h4><p><img src="/2019/03/05/js高级/原型及原型链.png" alt="Alt text">;</p>
<h4 id="原型链的图解"><a href="#原型链的图解" class="headerlink" title="原型链的图解:"></a>原型链的图解:</h4><p><img src="/2019/03/05/js高级/原型链的图解.png" alt="Alt text">;</p>
<h4 id="原型链指向改变"><a href="#原型链指向改变" class="headerlink" title="原型链指向改变:"></a>原型链指向改变:</h4><p><img src="/2019/03/05/js高级/原型链指向改变.png" alt="Alt text">;</p>
<h4 id="原型指向后的图解"><a href="#原型指向后的图解" class="headerlink" title="原型指向后的图解:"></a>原型指向后的图解:</h4><p><img src="/2019/03/05/js高级/原型指向后的图解.png" alt="Alt text">;</p>
<h4 id="原型最终的指向"><a href="#原型最终的指向" class="headerlink" title="原型最终的指向:"></a>原型最终的指向:</h4><p><img src="/2019/03/05/js高级/原型最终的指向.png" alt="Alt text">;</p>
<h3 id="案例：随机方块"><a href="#案例：随机方块" class="headerlink" title="案例：随机方块"></a>案例：随机方块</h3><hr>
<h2 id="面向对象游戏案例：贪吃蛇"><a href="#面向对象游戏案例：贪吃蛇" class="headerlink" title="面向对象游戏案例：贪吃蛇"></a>面向对象游戏案例：贪吃蛇</h2><p>案例相关源码以上传到 GitHub ：<a href="https://github.com/lipengzhou/new-snake" target="_blank" rel="noopener">https://github.com/lipengzhou/new-snake</a></p>
<h3 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h3><h4 id="游戏演示"><a href="#游戏演示" class="headerlink" title="游戏演示"></a>游戏演示</h4><p>在线演示地址：<a href="https://lipengzhou.github.io/new-snake/" target="_blank" rel="noopener">贪吃蛇</a></p>
<h4 id="案例目标"><a href="#案例目标" class="headerlink" title="案例目标"></a>案例目标</h4><p>游戏的目的是用来体会js高级语法的使用 不需要具备抽象对象的能力，使用面向对象的方式分析问题，需要一个漫长的过程。</p>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><h4 id="搭建页面"><a href="#搭建页面" class="headerlink" title="搭建页面"></a>搭建页面</h4><p>放一个容器盛放游戏场景 div#map，设置样式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#map</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析对象"><a href="#分析对象" class="headerlink" title="分析对象"></a>分析对象</h4><ul>
<li>游戏对象</li>
<li>蛇对象</li>
<li>食物对象</li>
</ul>
<h4 id="创建食物对象"><a href="#创建食物对象" class="headerlink" title="创建食物对象"></a>创建食物对象</h4><ul>
<li><p>Food</p>
<ul>
<li><p>属性</p>
<ul>
<li>x       </li>
<li>y</li>
<li>width</li>
<li>height</li>
<li>color       </li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>render       随机创建一个食物对象，并输出到map上</li>
</ul>
</li>
</ul>
</li>
<li><p>创建Food的构造函数，并设置属性</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> position = <span class="string">'absolute'</span>;</span><br><span class="line"><span class="keyword">var</span> elements = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">x, y, width, height, color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = y || <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 食物的宽度和高度(像素)</span></span><br><span class="line">  <span class="keyword">this</span>.width = width || <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">this</span>.height = height || <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// 食物的颜色</span></span><br><span class="line">  <span class="keyword">this</span>.color = color || <span class="string">'green'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过原型设置render方法，实现随机产生食物对象，并渲染到map上</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Food.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 随机食物的位置，map.宽度/food.宽度，总共有多少分food的宽度，随机一下。然后再乘以food的宽度</span></span><br><span class="line">  <span class="keyword">this</span>.x = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * map.offsetWidth / <span class="keyword">this</span>.width) * <span class="keyword">this</span>.width;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * map.offsetHeight / <span class="keyword">this</span>.height) * <span class="keyword">this</span>.height;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 动态创建食物对应的div</span></span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  map.appendChild(div);</span><br><span class="line">  div.style.position = position;</span><br><span class="line">  div.style.left = <span class="keyword">this</span>.x + <span class="string">'px'</span>;</span><br><span class="line">  div.style.top = <span class="keyword">this</span>.y + <span class="string">'px'</span>;</span><br><span class="line">  div.style.width = <span class="keyword">this</span>.width + <span class="string">'px'</span>;</span><br><span class="line">  div.style.height = <span class="keyword">this</span>.height + <span class="string">'px'</span>;</span><br><span class="line">  div.style.backgroundColor = <span class="keyword">this</span>.color;</span><br><span class="line">  elements.push(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过自调用函数，进行封装，通过window暴露Food对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.Food = Food;</span><br></pre></td></tr></table></figure>
<h4 id="创建蛇对象"><a href="#创建蛇对象" class="headerlink" title="创建蛇对象"></a>创建蛇对象</h4><ul>
<li><p>Snake</p>
</li>
<li><p>属性</p>
<ul>
<li>width    蛇节的宽度 默认20</li>
<li>height   蛇节的高度 默认20</li>
<li>body     数组，蛇的头部和身体，第一个位置是蛇头</li>
<li>direction    蛇运动的方向  默认right  可以是 left  top bottom</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>render  把蛇渲染到map上</li>
</ul>
</li>
<li><p>Snake构造函数</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> position = <span class="string">'absolute'</span>;</span><br><span class="line"><span class="keyword">var</span> elements = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Snake</span>(<span class="params">width, height, direction</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置每一个蛇节的宽度</span></span><br><span class="line">  <span class="keyword">this</span>.width = width || <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">this</span>.height = height || <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// 蛇的每一部分, 第一部分是蛇头</span></span><br><span class="line">  <span class="keyword">this</span>.body = [</span><br><span class="line">    &#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">color</span>: <span class="string">'red'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">color</span>: <span class="string">'red'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">color</span>: <span class="string">'red'</span>&#125;</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">this</span>.direction = direction || <span class="string">'right'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>render方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Snake.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.body.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">this</span>.body[i];</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    map.appendChild(div);</span><br><span class="line">    div.style.left = obj.x * <span class="keyword">this</span>.width + <span class="string">'px'</span>;</span><br><span class="line">    div.style.top = obj.y * <span class="keyword">this</span>.height + <span class="string">'px'</span>;</span><br><span class="line">    div.style.position = position;</span><br><span class="line">    div.style.backgroundColor = obj.color;</span><br><span class="line">    div.style.width = <span class="keyword">this</span>.width + <span class="string">'px'</span>;</span><br><span class="line">    div.style.height = <span class="keyword">this</span>.height + <span class="string">'px'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在自调用函数中暴露Snake对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.Snake = Snake;</span><br></pre></td></tr></table></figure>
<h4 id="创建游戏对象"><a href="#创建游戏对象" class="headerlink" title="创建游戏对象"></a>创建游戏对象</h4><p>游戏对象，用来管理游戏中的所有对象和开始游戏</p>
<ul>
<li><p>Game</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>food</p>
</li>
<li><p>snake</p>
</li>
<li><p>map</p>
</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>start            开始游戏（绘制所有游戏对象）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>构造函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Game</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.food = <span class="keyword">new</span> Food();</span><br><span class="line">  <span class="keyword">this</span>.snake = <span class="keyword">new</span> Snake();</span><br><span class="line">  <span class="keyword">this</span>.map = map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>开始游戏，渲染食物对象和蛇对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Game.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.food.render(<span class="keyword">this</span>.map);</span><br><span class="line">  <span class="keyword">this</span>.snake.render(<span class="keyword">this</span>.map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="游戏的逻辑"><a href="#游戏的逻辑" class="headerlink" title="游戏的逻辑"></a>游戏的逻辑</h3><h4 id="写蛇的move方法"><a href="#写蛇的move方法" class="headerlink" title="写蛇的move方法"></a>写蛇的move方法</h4><ul>
<li>在蛇对象(snake.js)中，在Snake的原型上新增move方法</li>
</ul>
<ol>
<li>让蛇移动起来，把蛇身体的每一部分往前移动一下</li>
<li>蛇头部分根据不同的方向决定 往哪里移动</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Snake.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params">food, map</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 让蛇身体的每一部分往前移动一下</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="keyword">this</span>.body.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">this</span>.body[i].x = <span class="keyword">this</span>.body[i - <span class="number">1</span>].x;</span><br><span class="line">    <span class="keyword">this</span>.body[i].y = <span class="keyword">this</span>.body[i - <span class="number">1</span>].y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据移动的方向，决定蛇头如何处理</span></span><br><span class="line">  <span class="keyword">switch</span>(<span class="keyword">this</span>.direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'left'</span>: </span><br><span class="line">      <span class="keyword">this</span>.body[<span class="number">0</span>].x -= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'right'</span>:</span><br><span class="line">      <span class="keyword">this</span>.body[<span class="number">0</span>].x += <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'top'</span>:</span><br><span class="line">      <span class="keyword">this</span>.body[<span class="number">0</span>].y -= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'bottom'</span>:</span><br><span class="line">      <span class="keyword">this</span>.body[<span class="number">0</span>].y += <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在game中测试</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.snake.move(<span class="keyword">this</span>.food, <span class="keyword">this</span>.map);</span><br><span class="line"><span class="keyword">this</span>.snake.render(<span class="keyword">this</span>.map);</span><br></pre></td></tr></table></figure>
<h4 id="让蛇自己动起来"><a href="#让蛇自己动起来" class="headerlink" title="让蛇自己动起来"></a>让蛇自己动起来</h4><ul>
<li><p>私有方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">什么是私有方法？</span><br><span class="line">  不能被外部访问的方法</span><br><span class="line">如何创建私有方法？</span><br><span class="line">  使用自调用函数包裹</span><br></pre></td></tr></table></figure>
</li>
<li><p>在game.js中 添加runSnake的私有方法，开启定时器调用蛇的move和render方法，让蛇动起来</p>
</li>
<li>判断蛇是否撞墙</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runSnake</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timerId = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.snake.move(<span class="keyword">this</span>.food, <span class="keyword">this</span>.map);</span><br><span class="line">    <span class="comment">// 在渲染前，删除之前的蛇</span></span><br><span class="line">    <span class="keyword">this</span>.snake.render(<span class="keyword">this</span>.map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断蛇是否撞墙</span></span><br><span class="line">    <span class="keyword">var</span> maxX = <span class="keyword">this</span>.map.offsetWidth / <span class="keyword">this</span>.snake.width;</span><br><span class="line">    <span class="keyword">var</span> maxY = <span class="keyword">this</span>.map.offsetHeight / <span class="keyword">this</span>.snake.height;</span><br><span class="line">    <span class="keyword">var</span> headX = <span class="keyword">this</span>.snake.body[<span class="number">0</span>].x;</span><br><span class="line">    <span class="keyword">var</span> headY = <span class="keyword">this</span>.snake.body[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">if</span> (headX &lt; <span class="number">0</span> || headX &gt;= maxX) &#123;</span><br><span class="line">      clearInterval(timerId);</span><br><span class="line">      alert(<span class="string">'Game Over'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (headY &lt; <span class="number">0</span> || headY &gt;= maxY) &#123;</span><br><span class="line">      clearInterval(timerId);</span><br><span class="line">      alert(<span class="string">'Game Over'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;.bind(that), <span class="number">150</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在snake中添加删除蛇的私有方法，在render中调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 删除渲染的蛇</span></span><br><span class="line">  <span class="keyword">var</span> i = elements.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 删除页面上渲染的蛇</span></span><br><span class="line">    elements[i].parentNode.removeChild(elements[i]);</span><br><span class="line">    <span class="comment">// 删除elements数组中的元素</span></span><br><span class="line">    elements.splice(i, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在game中通过键盘控制蛇的移动方向</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindKey</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">'keydown'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e.keyCode) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        <span class="keyword">this</span>.snake.direction = <span class="string">'left'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">38</span>:</span><br><span class="line">        <span class="comment">// top</span></span><br><span class="line">        <span class="keyword">this</span>.snake.direction = <span class="string">'top'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">39</span>:</span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        <span class="keyword">this</span>.snake.direction = <span class="string">'right'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">        <span class="comment">// bottom</span></span><br><span class="line">        <span class="keyword">this</span>.snake.direction = <span class="string">'bottom'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.bind(that), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在start方法中调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindKey();</span><br></pre></td></tr></table></figure>
<h4 id="判断蛇是否吃到食物"><a href="#判断蛇是否吃到食物" class="headerlink" title="判断蛇是否吃到食物"></a>判断蛇是否吃到食物</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Snake的move方法中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在移动的过程中判断蛇是否吃到食物</span></span><br><span class="line"><span class="comment">// 如果蛇头和食物的位置重合代表吃到食物</span></span><br><span class="line"><span class="comment">// 食物的坐标是像素，蛇的坐标是几个宽度，进行转换</span></span><br><span class="line"><span class="keyword">var</span> headX = <span class="keyword">this</span>.body[<span class="number">0</span>].x * <span class="keyword">this</span>.width;</span><br><span class="line"><span class="keyword">var</span> headY = <span class="keyword">this</span>.body[<span class="number">0</span>].y * <span class="keyword">this</span>.height;</span><br><span class="line"><span class="keyword">if</span> (headX === food.x &amp;&amp; headY === food.y) &#123;</span><br><span class="line">  <span class="comment">// 吃到食物，往蛇节的最后加一节</span></span><br><span class="line">  <span class="keyword">var</span> last = <span class="keyword">this</span>.body[<span class="keyword">this</span>.body.length - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">this</span>.body.push(&#123;</span><br><span class="line">    x: last.x,</span><br><span class="line">    y: last.y,</span><br><span class="line">    color: last.color</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 把现在的食物对象删除，并重新随机渲染一个食物对象</span></span><br><span class="line">  food.render(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它处理"><a href="#其它处理" class="headerlink" title="其它处理"></a>其它处理</h3><h4 id="把html中的js代码放到index-js中"><a href="#把html中的js代码放到index-js中" class="headerlink" title="把html中的js代码放到index.js中"></a>把html中的js代码放到index.js中</h4><p>避免html中出现js代码</p>
<h4 id="自调用函数的参数"><a href="#自调用函数的参数" class="headerlink" title="自调用函数的参数"></a>自调用函数的参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">document</span> = <span class="built_in">window</span>.document;</span><br><span class="line"></span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="literal">undefined</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>传入window对象</li>
</ul>
<p>将来代码压缩的时候，可以吧 function (window)  压缩成 function (w)</p>
<ul>
<li>传入undefined</li>
</ul>
<p>在将来会看到别人写的代码中会把undefined作为函数的参数(当前案例没有使用)<br>因为在有的老版本的浏览器中 undefined可以被重新赋值，防止undefined 被重新赋值</p>
<h4 id="整理代码"><a href="#整理代码" class="headerlink" title="整理代码"></a>整理代码</h4><p>现在的代码结构清晰，谁出问题就找到对应的js文件即可。<br>通过自调用函数，已经防止了变量命名污染的问题</p>
<p>但是，由于js文件数较多，需要在页面上引用，会产生文件依赖的问题(先引入那个js，再引入哪个js)<br>将来通过工具把js文件合并并压缩。现在手工合并js文件演示</p>
<ul>
<li>问题1</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存在多个自调用函数要用分号分割，否则语法错误</span></span><br><span class="line"><span class="comment">// 下面代码会报错</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;())</span><br><span class="line"><span class="comment">// 所以代码规范中会建议在自调用函数之前加上分号</span></span><br><span class="line"><span class="comment">// 下面代码没有问题</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<ul>
<li>问题2 </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当自调用函数 前面有函数声明时，会把自调用函数作为参数</span></span><br><span class="line"><span class="comment">// 所以建议自调用函数前，加上;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'11'</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'22'</span>);</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><ul>
<li>现实生活中的继承</li>
<li>程序中的继承</li>
</ul>
<h3 id="1-通过原型实现继承"><a href="#1-通过原型实现继承" class="headerlink" title="1.通过原型实现继承:"></a>1.通过原型实现继承:</h3><pre><code>缺点:改变原型的指向,属性在初始化的时候就已经固定了,如果是多个对象实例化,
    那么每个实例对象的属性的值在初始化的时候都是一样的
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是通过原型实现继承'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">score</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score=score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数student的prototype指向原型对象(新的实例对象) 实例对象stu可以使用原型对象中的属性和方法</span></span><br><span class="line">Student.prototype=<span class="keyword">new</span> Person(<span class="string">'lcl'</span>,<span class="string">'18'</span>);</span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">'100分'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.name);<span class="comment">//lcl</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.age);<span class="comment">//18</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.score);<span class="comment">//100分</span></span><br><span class="line">stu.say();<span class="comment">//我是通过原型实现继承</span></span><br></pre></td></tr></table></figure>
<h3 id="2-借用构造函数继承"><a href="#2-借用构造函数继承" class="headerlink" title="2.借用构造函数继承:"></a>2.借用构造函数继承:</h3><pre><code>缺点:不能继承方法
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是通过构造函数实现继承'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,score</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score=score;</span><br><span class="line">    <span class="comment">// Person.call(this,name,age);</span></span><br><span class="line">    Person.apply(<span class="keyword">this</span>,[name,age]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">'lcl'</span>,<span class="string">'18'</span>,<span class="string">'100分'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.name); <span class="comment">//lcl</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.age); <span class="comment">//18</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.score); <span class="comment">//100分</span></span><br><span class="line">stu.say();<span class="comment">//stu.say is not a function 借用构造函数使用apply或者calll不能继承方法;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-组合继承-可以解决属性和方法的继承的问题-原型继承和构造函数继承的结合"><a href="#3-组合继承-可以解决属性和方法的继承的问题-原型继承和构造函数继承的结合" class="headerlink" title="3.组合继承:可以解决属性和方法的继承的问题 原型继承和构造函数继承的结合"></a>3.组合继承:可以解决属性和方法的继承的问题 原型继承和构造函数继承的结合</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是组合继承'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用构造函数继承属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,score</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score=score;</span><br><span class="line">    <span class="comment">// Person.call(this,name,age);</span></span><br><span class="line">    Person.apply(<span class="keyword">this</span>,[name,age]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用原型继承方法,改变原型指向</span></span><br><span class="line">Student.prototype=<span class="keyword">new</span> Person();<span class="comment">//不传值</span></span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">'lcl'</span>,<span class="string">'18'</span>,<span class="string">'100分'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.name); <span class="comment">//lcl</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.age); <span class="comment">//18</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.score); <span class="comment">//100分</span></span><br><span class="line">stu.say();<span class="comment">//我是组合继承</span></span><br></pre></td></tr></table></figure>
<h3 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4.拷贝继承:"></a>4.拷贝继承:</h3><pre><code>就是把一个对象中的原型中的所有的属性和方法复制一份给另一个对象或者利用构造函数继承属性,利用for-in就成方法
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我通过拷贝继承'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.listen=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我可以听到说话'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数和call方法继承属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,score</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score=score;</span><br><span class="line">    Person.call(<span class="keyword">this</span>,name,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过for循环把构造函数指向的原型对象的方法指向Student的原型对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> Person.prototype)&#123;</span><br><span class="line">    Student.prototype[key]=Person.prototype[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">'lcl'</span>,<span class="string">'18'</span>,<span class="string">'100分'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.name);<span class="comment">//lcl</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.age);<span class="comment">//18</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.score);<span class="comment">//100分</span></span><br><span class="line">stu.say();<span class="comment">//我通过拷贝继承</span></span><br><span class="line">stu.listen();<span class="comment">//我可以听到说话</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a>函数的定义方式</h3><ul>
<li>函数声明</li>
<li>函数表达式</li>
<li><code>new Function</code></li>
</ul>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数声明与函数表达式的区别"><a href="#函数声明与函数表达式的区别" class="headerlink" title="函数声明与函数表达式的区别"></a>函数声明与函数表达式的区别</h4><ul>
<li>函数声明必须有名字</li>
<li>函数声明会函数提升，在预解析阶段就已创建，声明前后都可以调用</li>
<li>函数表达式类似于变量赋值</li>
<li>函数表达式可以没有名字，例如匿名函数</li>
<li>函数表达式没有变量提升，在执行阶段创建，必须在表达式执行之后才可以调用</li>
</ul>
<p>下面是一个根据条件定义函数的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果在不同浏览器中结果不一致。</p>
<p>不过我们可以使用函数表达式解决上面的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h3><ul>
<li>普通函数</li>
<li>构造函数</li>
<li>对象方法</li>
</ul>
<h3 id="函数内-this-指向的不同场景"><a href="#函数内-this-指向的不同场景" class="headerlink" title="函数内 this 指向的不同场景"></a>函数内 <code>this</code> 指向的不同场景</h3><p>函数的调用方式决定了 <code>this</code> 指向的不同：</p>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>非严格模式</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通函数调用</td>
<td>window</td>
<td>严格模式下是 undefined</td>
</tr>
<tr>
<td>构造函数调用</td>
<td>实例对象</td>
<td>原型方法中 this 也是实例对象</td>
</tr>
<tr>
<td>对象方法调用</td>
<td>该方法所属对象</td>
<td>紧挨着的对象</td>
</tr>
<tr>
<td>事件绑定方法</td>
<td>绑定事件对象</td>
<td></td>
</tr>
<tr>
<td>定时器函数</td>
<td>window</td>
</tr>
</tbody>
</table>
<p>这就是对函数内部 this 指向的基本整理，写代码写多了自然而然就熟悉了。</p>
<h3 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h3><ul>
<li>所有函数都是 <code>Function</code> 的实例</li>
</ul>
<h3 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h3><p>那了解了函数 this 指向的不同场景之后，我们知道有些情况下我们为了使用某种特定环境的 this 引用，<br>这时候时候我们就需要采用一些特殊手段来处理了，例如我们经常在定时器外部备份 this 引用，然后在定时器函数内部使用外部 this 的引用。<br>然而实际上对于这种做法我们的 JavaScript 为我们专门提供了一些函数方法用来帮我们更优雅的处理函数内部 this 指向问题。<br>这就是接下来我们要学习的 call、apply、bind 三个函数方法。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p><code>call()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值和分别地提供的参数(参数的列表)。</p>
<p class="danger"><br>  注意：该方法的作用和 <code>apply()</code> 方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是若干个参数的列表，而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。<br></p>

<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p><code>thisArg</code></p>
<ul>
<li>在 fun 函数运行时指定的 this 值</li>
<li>如果指定了 null 或者 undefined 则内部 this 指向 window</li>
</ul>
</li>
<li><p><code>arg1, arg2, ...</code></p>
<ul>
<li>指定的参数列表</li>
</ul>
</li>
</ul>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p><code>apply()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值，以及作为一个数组（或类似数组的对象）提供的参数。</p>
<p class="danger"><br>  注意：该方法的作用和 <code>call()</code> 方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是若干个参数的列表，而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。<br></p>

<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><code>thisArg</code></li>
<li><code>argsArray</code></li>
</ul>
<p><code>apply()</code> 与 <code>call()</code> 非常相似，不同之处在于提供参数的方式。<br><code>apply()</code> 使用参数数组而不是一组参数列表。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(<span class="keyword">this</span>, [<span class="string">'eat'</span>, <span class="string">'bananas'</span>])</span><br></pre></td></tr></table></figure>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。<br>当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。<br>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.bind(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>thisArg</p>
<ul>
<li>当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</li>
</ul>
</li>
<li><p>arg1, arg2, …</p>
<ul>
<li>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li>
</ul>
</li>
</ul>
<p>返回值：</p>
<p>返回由指定的this值和初始化参数改造的原函数拷贝。</p>
<p>示例1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.x = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">// 返回 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line">retrieveX(); <span class="comment">// 返回 9, 在这种情况下，"this"指向全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新函数，将"this"绑定到module对象</span></span><br><span class="line"><span class="comment">// 新手可能会被全局的x变量和module里的属性x所迷惑</span></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line">boundGetX(); <span class="comment">// 返回 81</span></span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LateBloomer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.petalCount = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">12</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare bloom after a delay of 1 second</span></span><br><span class="line">LateBloomer.prototype.bloom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="keyword">this</span>.declare.bind(<span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LateBloomer.prototype.declare = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I am a beautiful flower with '</span> +</span><br><span class="line">    <span class="keyword">this</span>.petalCount + <span class="string">' petals!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flower = <span class="keyword">new</span> LateBloomer();</span><br><span class="line">flower.bloom();  <span class="comment">// 一秒钟后, 调用'declare'方法</span></span><br></pre></td></tr></table></figure>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>call 和 apply 特性一样</p>
<ul>
<li>都是用来调用函数，而且是立即调用</li>
<li>但是可以在调用函数的同时，通过第一个参数指定函数内部 <code>this</code> 的指向</li>
<li>call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可</li>
<li>apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递</li>
<li>如果第一个参数指定了 <code>null</code> 或者 <code>undefined</code> 则内部 this 指向 window</li>
</ul>
</li>
<li><p>bind</p>
<ul>
<li>可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数</li>
<li>它和 call、apply 最大的区别是：bind 不会调用</li>
<li>bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递<ul>
<li><ol>
<li>在 bind 的同时，以参数列表的形式进行传递</li>
</ol>
</li>
<li><ol start="2">
<li>在调用的时候，以参数列表的形式进行传递</li>
</ol>
</li>
<li>那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准</li>
<li>两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="函数的其它成员"><a href="#函数的其它成员" class="headerlink" title="函数的其它成员"></a>函数的其它成员</h3><ul>
<li>arguments<ul>
<li>实参集合</li>
</ul>
</li>
<li>caller<ul>
<li>函数的调用者</li>
</ul>
</li>
<li>length<ul>
<li>形参的个数</li>
</ul>
</li>
<li>name<ul>
<li>函数的名称</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn.length) <span class="comment">// =&gt; 形参的个数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) <span class="comment">// 伪数组实参参数集合</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === fn) <span class="comment">// 函数本身</span></span><br><span class="line">  <span class="built_in">console</span>.log(fn.caller) <span class="comment">// 函数的调用者</span></span><br><span class="line">  <span class="built_in">console</span>.log(fn.name) <span class="comment">// =&gt; 函数的名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul>
<li>函数可以作为参数</li>
<li>函数可以作为返回值</li>
</ul>
<h4 id="作为参数"><a href="#作为参数" class="headerlink" title="作为参数"></a>作为参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eat</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'吃完了'</span>)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eat(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'去唱歌'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="作为返回值"><a href="#作为返回值" class="headerlink" title="作为返回值"></a>作为返回值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genFun</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === type</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isArray = genFun(<span class="string">'[object Array]'</span>)</span><br><span class="line"><span class="keyword">var</span> isObject = genFun(<span class="string">'[object Object]'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isArray([])) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(isArray(&#123;&#125;)) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<h3 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getCount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(count)</span><br><span class="line">    &#125;,</span><br><span class="line">    setCount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fns = fn()</span><br><span class="line"></span><br><span class="line">fns.getCount() <span class="comment">// =&gt; 0</span></span><br><span class="line">fns.setCount()</span><br><span class="line">fns.getCount() <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<h4 id="作用域、作用域链、预解析"><a href="#作用域、作用域链、预解析" class="headerlink" title="作用域、作用域链、预解析"></a>作用域、作用域链、预解析</h4><ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li><strong>没有块级作用域</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p>作用域链示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">30</span></span><br><span class="line">    <span class="built_in">console</span>.log(a + b + c)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">40</span></span><br><span class="line">    <span class="built_in">console</span>.log(c + d)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn1()</span><br><span class="line">  fn2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内层作用域可以访问外层作用域，反之不行</li>
</ul>
<h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h4><p>闭包就是能够读取其他函数内部变量的函数，<br>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，<br>因此可以把闭包简单理解成 “定义在一个函数内部的函数”。<br>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。<br><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">js闭包的理解 阮一峰</a><br>闭包的用途：</p>
<ul>
<li>可以在函数外部读取函数内部成员</li>
<li>让函数内成员始终存活在内存中</li>
</ul>
<h4 id="一些关于闭包的例子"><a href="#一些关于闭包的例子" class="headerlink" title="一些关于闭包的例子"></a>一些关于闭包的例子</h4><p>示例1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">  arr[i]() <span class="comment">//0 ,1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">//三个 3</span></span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">222</span>)</span><br></pre></td></tr></table></figure>
<p>示例3：投票<br>    点击各自按钮不影响其他按钮的改变</p>
<pre><code>&lt;ul&gt;
  &lt;li&gt;&lt;img src=&quot;images/ly.jpg&quot; alt=&quot;&quot;&gt;&lt;br/&gt;&lt;input type=&quot;button&quot; value=&quot;赞(1)&quot;&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;images/lyml.jpg&quot; alt=&quot;&quot;&gt;&lt;br/&gt;&lt;input type=&quot;button&quot; value=&quot;赞(1)&quot;&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;images/fj.jpg&quot; alt=&quot;&quot;&gt;&lt;br/&gt;&lt;input type=&quot;button&quot; value=&quot;赞(1)&quot;&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;images/bd.jpg&quot; alt=&quot;&quot;&gt;&lt;br/&gt;&lt;input type=&quot;button&quot; value=&quot;赞(1)&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">//根据标签名字获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my$</span>(<span class="params">tagName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.getElementsByTagName(tagName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//闭包缓存数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//每一次点击的时候,都应该改变当前点击按钮的value值</span></span><br><span class="line">    <span class="keyword">this</span>.value=<span class="string">"赞("</span>+(value++)+<span class="string">")"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取所有的按钮</span></span><br><span class="line"><span class="keyword">var</span> btnObjs=my$(<span class="string">"input"</span>);</span><br><span class="line"><span class="comment">//循环遍历每个按钮,注册点击事件</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;btnObjs.length;i++)&#123;</span><br><span class="line">  <span class="comment">//注册事件</span></span><br><span class="line">  btnObjs[i].onclick=getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例4：判断类型</p>
<p>示例5：沙箱模式</p>
<h4 id="闭包的思考题"><a href="#闭包的思考题" class="headerlink" title="闭包的思考题"></a>闭包的思考题</h4><p>思考题 1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()())<span class="comment">//The Window</span></span><br></pre></td></tr></table></figure>
<p>思考题 2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;　　</span><br><span class="line"><span class="keyword">var</span> object = &#123;　　　　</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()())<span class="comment">//My Object</span></span><br><span class="line"><span class="comment">//执行原理:执行objext.getNameFunc()的时候,会先把this(指向的是object)赋值给that,并且返回一个函数,</span></span><br><span class="line"><span class="comment">// 执行object.getNameFunc()()的时候该函数调用,返回that.name ,输出的就是My Object;</span></span><br></pre></td></tr></table></figure>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><h3 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h3><h4 id="递归执行模型"><a href="#递归执行模型" class="headerlink" title="递归执行模型"></a>递归执行模型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">  fn2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn1'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>)</span><br><span class="line">  fn3()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">333</span>)</span><br><span class="line">  fn4()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn3'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn4</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">444</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn4'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1()</span><br></pre></td></tr></table></figure>
<h4 id="举个栗子：计算阶乘的递归函数"><a href="#举个栗子：计算阶乘的递归函数" class="headerlink" title="举个栗子：计算阶乘的递归函数"></a>举个栗子：计算阶乘的递归函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归应用场景"><a href="#递归应用场景" class="headerlink" title="递归应用场景"></a>递归应用场景</h4><ul>
<li>深拷贝</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝:拷贝还是复制,深:把一个对象中所有的属性或者方法,一个一个的找到.并且在另一个对象中开辟相应的空间,一个一个的存储到另一个对象中</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> obj1=&#123;</span><br><span class="line">     age:<span class="number">10</span>,</span><br><span class="line">     sex:<span class="string">"男"</span>,</span><br><span class="line">     car:[<span class="string">"奔驰"</span>,<span class="string">"宝马"</span>,<span class="string">"特斯拉"</span>,<span class="string">"奥拓"</span>],</span><br><span class="line">     dog:&#123;</span><br><span class="line">       name:<span class="string">"大黄"</span>,</span><br><span class="line">       age:<span class="number">5</span>,</span><br><span class="line">       color:<span class="string">"黑白色"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> obj2=&#123;&#125;;<span class="comment">//空对象</span></span><br><span class="line">   <span class="comment">//通过函数实现,把对象a中的所有的数据深拷贝到对象b中</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> a)&#123;</span><br><span class="line">       <span class="comment">//先获取a对象中每个属性的值</span></span><br><span class="line">       <span class="keyword">var</span> item=a[key];</span><br><span class="line">       <span class="comment">//判断这个属性的值是不是数组</span></span><br><span class="line">       <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">         <span class="comment">//如果是数组,那么在b对象中添加一个新的属性,并且这个属性值也是数组</span></span><br><span class="line">         b[key]=[];</span><br><span class="line">         <span class="comment">//调用这个方法，把a对象中这个数组的属性值一个一个的复制到b对象的这个数组属性中</span></span><br><span class="line">         extend(item,b[key]);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;<span class="comment">//判断这个值是不是对象类型的</span></span><br><span class="line">    <span class="comment">//如果是对象类型的,那么在b对象中添加一个属性,是一个空对象</span></span><br><span class="line">         b[key]=&#123;&#125;;</span><br><span class="line">         <span class="comment">//再次调用这个函数,把a对象中的属性对象的值一个一个的复制到b对象的这个属性对象中</span></span><br><span class="line">         extend(item,b[key]);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//如果值是普通的数据,直接复制到b对象的这个属性中</span></span><br><span class="line">         b[key]=item;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>菜单树</li>
<li><p>遍历 DOM 树</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;遍历DOM树&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;h1&gt;遍历 DOM 树&lt;/h1&gt;
&lt;p style=&quot;color: green;&quot;&gt;Tip: 可以在遍历的回调函数中任意定制需求&lt;/p&gt;
&lt;div&gt;
  &lt;ul&gt;
    &lt;li&gt;123&lt;/li&gt;
    &lt;li&gt;456&lt;/li&gt;
    &lt;li&gt;789&lt;/li&gt;
  &lt;/ul&gt;
  &lt;div&gt;
    &lt;div&gt;
      &lt;span&gt;haha&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;demo_node&quot;&gt;
  &lt;ul&gt;
    &lt;li&gt;123&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;hello&lt;/p&gt;
  &lt;h2&gt;world&lt;/h2&gt;
  &lt;div&gt;
    &lt;p&gt;dsa&lt;/p&gt;
    &lt;h3&gt;
      &lt;span&gt;dsads&lt;/span&gt;
    &lt;/h3&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">//获取页面中的根节点--根标签</span></span><br><span class="line">  <span class="keyword">var</span> root=<span class="built_in">document</span>.documentElement;<span class="comment">//html</span></span><br><span class="line">  <span class="comment">//函数遍历DOM树</span></span><br><span class="line">  <span class="comment">//根据根节点,调用fn的函数,显示的是根节点的名字</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">forDOM</span>(<span class="params">root1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//调用f1,显示的是节点的名字</span></span><br><span class="line">   <span class="comment">// f1(root1);</span></span><br><span class="line">    <span class="comment">//获取根节点中所有的子节点</span></span><br><span class="line">    <span class="keyword">var</span> children=root1.children;</span><br><span class="line">    <span class="comment">//调用遍历所有子节点的函数</span></span><br><span class="line">    forChildren(children);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//给我所有的子节点,我把这个子节点中的所有的子节点显示出来</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">forChildren</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//遍历所有的子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;children.length;i++)&#123;</span><br><span class="line">      <span class="comment">//每个子节点</span></span><br><span class="line">      <span class="keyword">var</span> child=children[i];</span><br><span class="line">      <span class="comment">//显示每个子节点的名字</span></span><br><span class="line">      f1(child);</span><br><span class="line">      <span class="comment">//判断child下面有没有子节点,如果还有子节点,那么就继续的遍历</span></span><br><span class="line">      child.children&amp;&amp;forDOM(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//函数调用,传入根节点</span></span><br><span class="line">  forDOM(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"节点的名字:"</span>+node.nodeName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//节点:nodeName,nodeType,nodeValue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  第一个函数:给我根节点,我会找到所有的子节点:forDOM(根节点)</span></span><br><span class="line"><span class="comment">//  获取这个根节点的子节点</span></span><br><span class="line"><span class="comment">//  var children=根节点的.children</span></span><br><span class="line"><span class="comment">//  调用第二个函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  第二个函数:给我所有的子节点,我把每个子节点的名字显示出来(children)</span></span><br><span class="line"><span class="comment">//  for(var i=0;i&lt;children.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//    每个子节点</span></span><br><span class="line"><span class="comment">//    var child=children[i];</span></span><br><span class="line"><span class="comment">//    f1(child);给我节点,我显示该节点的名字</span></span><br><span class="line"><span class="comment">//    child是子节点,但是如果child里面还有子节点,此时child就是爹了</span></span><br><span class="line"><span class="comment">//    child.children&amp;&amp;第一个函数(child)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li>了解正则表达式基本语法</li>
<li>能够使用JavaScript的正则对象</li>
</ul>
<h3 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h3><h4 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h4><p>正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。<br>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>
<h4 id="正则表达式的作用"><a href="#正则表达式的作用" class="headerlink" title="正则表达式的作用"></a>正则表达式的作用</h4><ol>
<li>给定的字符串是否符合正则表达式的过滤逻辑(匹配)</li>
<li>可以通过正则表达式，从字符串中获取我们想要的特定部分(提取)</li>
<li>强大的字符串替换能力(替换)</li>
</ol>
<h4 id="正则表达式的特点"><a href="#正则表达式的特点" class="headerlink" title="正则表达式的特点"></a>正则表达式的特点</h4><ol>
<li>灵活性、逻辑性和功能性非常的强</li>
<li>可以迅速地用极简单的方式达到字符串的复杂控制</li>
<li>对于刚接触的人来说，比较晦涩难懂</li>
</ol>
<h3 id="正则表达式的测试"><a href="#正则表达式的测试" class="headerlink" title="正则表达式的测试"></a>正则表达式的测试</h3><ul>
<li><a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">在线测试正则</a></li>
<li>工具中使用正则表达式<ul>
<li>sublime/vscode/word</li>
<li>演示替换所有的数字</li>
</ul>
</li>
</ul>
<h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h3><ul>
<li>普通字符</li>
<li>特殊字符(元字符)：正则表达式中有特殊意义的字符</li>
</ul>
<p>示例演示：</p>
<ul>
<li><code>\d</code> 匹配数字</li>
<li><code>ab\d</code> 匹配 ab1、ab2</li>
</ul>
<h3 id="元字符串"><a href="#元字符串" class="headerlink" title="元字符串"></a>元字符串</h3><p>通过测试工具演示下面元字符的使用</p>
<h4 id="常用元字符串"><a href="#常用元字符串" class="headerlink" title="常用元字符串"></a>常用元字符串</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线(非特殊字符)</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线(特殊字符)</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符以外的任意单个字符</td>
</tr>
<tr>
<td>^</td>
<td>表示匹配行首的文本(以谁开始)</td>
</tr>
<tr>
<td>$</td>
<td>表示匹配行尾的文本(以谁结束)</td>
</tr>
</tbody>
</table>
<h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table>
<thead>
<tr>
<th>限定符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思</span><br><span class="line">[^]  匹配除中括号以内的内容</span><br><span class="line">\ 转义符</span><br><span class="line">| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱</span><br><span class="line">() 从两个直接量中选择一个，分组</span><br><span class="line">   eg：gr(a|e)y匹配gray和grey</span><br><span class="line">[\u4e00-\u9fa5]  匹配汉字</span><br></pre></td></tr></table></figure>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>验证手机号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">11</span>&#125;$</span><br></pre></td></tr></table></figure>
<p>验证邮编：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">6</span>&#125;$</span><br></pre></td></tr></table></figure>
<p>验证日期 2012-5-01</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;$</span><br></pre></td></tr></table></figure>
<p>验证邮箱 <a href="mailto:xxx@itcast.cn" target="_blank" rel="noopener">xxx@itcast.cn</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\w+@\w+\.\w+$</span><br></pre></td></tr></table></figure>
<p>验证IP地址 192.168.1.10</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;\(.\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)&#123;<span class="number">3</span>&#125;$</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript-中使用正则表达式"><a href="#JavaScript-中使用正则表达式" class="headerlink" title="JavaScript 中使用正则表达式"></a>JavaScript 中使用正则表达式</h2><h3 id="创建正则对象"><a href="#创建正则对象" class="headerlink" title="创建正则对象"></a>创建正则对象</h3><p>方式1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> Regex(<span class="string">'\d'</span>, <span class="string">'i'</span>);</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> Regex(<span class="string">'\d'</span>, <span class="string">'gi'</span>);</span><br></pre></td></tr></table></figure>
<p>方式2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/i</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/gi</span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>g</td>
<td>全局匹配</td>
</tr>
<tr>
<td>gi</td>
<td>全局匹配+忽略大小写</td>
</tr>
</tbody>
</table>
<h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配日期</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">'2015-10-10'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(dateStr));</span><br></pre></td></tr></table></figure>
<p>###匹配正则表达式<br>//        console.log(/./.test(“除了回车换行以外的任意字符”));//true<br>//        console.log(/.*/.test(“0个到多个”));//true<br>//        console.log(/.+/.test(“1个到多个”));//true<br>//        console.log(/.?/.test(“哈哈”));//true<br>//        console.log(/[0-9]/.test(“9527”));//true<br>//        console.log(/[a-z]/.test(“what”));//true<br>//        console.log(/[A-Z]/.test(“Are”));//true<br>//        console.log(/[a-zA-Z]/.test(“干啥子”));//false<br>//        console.log(/[0-9a-zA-Z]/.test(“9ebg”));//true<br>//        console.log(/b|(ara)/.test(“abra”));//true<br>//        console.log(/[a-z]{2,3}/.test(“arfsf”));//true</p>
<pre><code>console.log(/\d/.test(&quot;998&quot;));//true
console.log(/\d*/.test(&quot;998&quot;));//true
console.log(/\d+/.test(&quot;998&quot;));//true
console.log(/\d{0,}/.test(&quot;998&quot;));//true
console.log(/\d{2,3}/.test(&quot;998&quot;));//true
console.log(/\D/.test(&quot;eat&quot;));//true
console.log(/\s/.test(&quot;  &quot;));//true
console.log(/\S/.test(&quot;嘎嘎&quot;));//true
console.log(/\w/.test(&quot;_&quot;));//true
console.log(/\W/.test(&quot;_&quot;));//true
</code></pre><p>###正则表达式案例<br>1.验证密码强弱<br>2.验证邮箱：[0-9a-zA-Z_.-]+[@][0-9a-zA-Z._-]+([.][a-zA-Z]+){1,2}<br>3.验证中文名字[\u4e00-\u9fa5]</p>
<h3 id="正则提取"><a href="#正则提取" class="headerlink" title="正则提取"></a>正则提取</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 提取工资</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"张三：1000，李四：5000，王五：8000。"</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提取email地址</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com..."</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\w+@\w+\.\w+(\.\w+)?/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 分组提取  </span></span><br><span class="line"><span class="comment">// 3. 提取日期中的年部分  2015-5-10</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">'2016-1-5'</span>;</span><br><span class="line"><span class="comment">// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(dateStr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提取邮件中的每一部分</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w+)@(\w+)\.(\w+)(\.\w+)?/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"123123@xx.com"</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 替换所有空白</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"   123AD  asadf   asadfasf  adf "</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/\s/g</span>,<span class="string">"xx"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 替换所有,|，</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"abc,efg,123，abc,123，a"</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/,|，/g</span>, <span class="string">"."</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>
<h3 id="案例：表单验证"><a href="#案例：表单验证" class="headerlink" title="案例：表单验证"></a>案例：表单验证</h3><pre><code>QQ号：&lt;input type=&quot;text&quot; id=&quot;txtQQ&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;
邮箱：&lt;input type=&quot;text&quot; id=&quot;txtEMail&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;
手机：&lt;input type=&quot;text&quot; id=&quot;txtPhone&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;
生日：&lt;input type=&quot;text&quot; id=&quot;txtBirthday&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取文本框</span></span><br><span class="line"><span class="keyword">var</span> txtQQ = <span class="built_in">document</span>.getElementById(<span class="string">"txtQQ"</span>);</span><br><span class="line"><span class="keyword">var</span> txtEMail = <span class="built_in">document</span>.getElementById(<span class="string">"txtEMail"</span>);</span><br><span class="line"><span class="keyword">var</span> txtPhone = <span class="built_in">document</span>.getElementById(<span class="string">"txtPhone"</span>);</span><br><span class="line"><span class="keyword">var</span> txtBirthday = <span class="built_in">document</span>.getElementById(<span class="string">"txtBirthday"</span>);</span><br><span class="line"><span class="keyword">var</span> txtName = <span class="built_in">document</span>.getElementById(<span class="string">"txtName"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">txtQQ.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前文本框对应的span</span></span><br><span class="line">  <span class="keyword">var</span> span = <span class="keyword">this</span>.nextElementSibling;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;5,12&#125;$/</span>;</span><br><span class="line">  <span class="comment">//判断验证是否成功</span></span><br><span class="line">  <span class="keyword">if</span>(!reg.test(<span class="keyword">this</span>.value) )&#123;</span><br><span class="line">    <span class="comment">//验证不成功</span></span><br><span class="line">    span.innerText = <span class="string">"请输入正确的QQ号"</span>;</span><br><span class="line">    span.style.color = <span class="string">"red"</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//验证成功</span></span><br><span class="line">    span.innerText = <span class="string">""</span>;</span><br><span class="line">    span.style.color = <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//txtEMail</span></span><br><span class="line">txtEMail.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前文本框对应的span</span></span><br><span class="line">  <span class="keyword">var</span> span = <span class="keyword">this</span>.nextElementSibling;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/^\w+@\w+\.\w+(\.\w+)?$/</span>;</span><br><span class="line">  <span class="comment">//判断验证是否成功</span></span><br><span class="line">  <span class="keyword">if</span>(!reg.test(<span class="keyword">this</span>.value) )&#123;</span><br><span class="line">    <span class="comment">//验证不成功</span></span><br><span class="line">    span.innerText = <span class="string">"请输入正确的EMail地址"</span>;</span><br><span class="line">    span.style.color = <span class="string">"red"</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//验证成功</span></span><br><span class="line">    span.innerText = <span class="string">""</span>;</span><br><span class="line">    span.style.color = <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>表单验证部分，封装成函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regBirthday = <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span>;</span><br><span class="line">addCheck(txtBirthday, regBirthday, <span class="string">"请输入正确的出生日期"</span>);</span><br><span class="line"><span class="comment">//给文本框添加验证</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCheck</span>(<span class="params">element, reg, tip</span>) </span>&#123;</span><br><span class="line">  element.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前文本框对应的span</span></span><br><span class="line">    <span class="keyword">var</span> span = <span class="keyword">this</span>.nextElementSibling;</span><br><span class="line">    <span class="comment">//判断验证是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(!reg.test(<span class="keyword">this</span>.value) )&#123;</span><br><span class="line">      <span class="comment">//验证不成功</span></span><br><span class="line">      span.innerText = tip;</span><br><span class="line">      span.style.color = <span class="string">"red"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//验证成功</span></span><br><span class="line">      span.innerText = <span class="string">""</span>;</span><br><span class="line">      span.style.color = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过给元素增加自定义验证属性对表单进行验证：</p>
<pre><code>&lt;form id=&quot;frm&quot;&gt;
  QQ号：&lt;input type=&quot;text&quot; name=&quot;txtQQ&quot; data-rule=&quot;qq&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;
  邮箱：&lt;input type=&quot;text&quot; name=&quot;txtEMail&quot; data-rule=&quot;email&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;
  手机：&lt;input type=&quot;text&quot; name=&quot;txtPhone&quot; data-rule=&quot;phone&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;
  生日：&lt;input type=&quot;text&quot; name=&quot;txtBirthday&quot; data-rule=&quot;date&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;
  姓名：&lt;input type=&quot;text&quot; name=&quot;txtName&quot; data-rule=&quot;cn&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;
&lt;/form&gt;
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的验证规则</span></span><br><span class="line"><span class="keyword">var</span> rules = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'qq'</span>,</span><br><span class="line">    reg: <span class="regexp">/^\d&#123;5,12&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">"请输入正确的QQ"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'email'</span>,</span><br><span class="line">    reg: <span class="regexp">/^\w+@\w+\.\w+(\.\w+)?$/</span>,</span><br><span class="line">    tip: <span class="string">"请输入正确的邮箱地址"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'phone'</span>,</span><br><span class="line">    reg: <span class="regexp">/^\d&#123;11&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">"请输入正确的手机号码"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'date'</span>,</span><br><span class="line">    reg: <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">"请输入正确的出生日期"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'cn'</span>,</span><br><span class="line">    reg: <span class="regexp">/^[\u4e00-\u9fa5]&#123;2,4&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">"请输入正确的姓名"</span></span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">addCheck(<span class="string">'frm'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//给文本框添加验证</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCheck</span>(<span class="params">formId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">      len = <span class="number">0</span>,</span><br><span class="line">      frm =<span class="built_in">document</span>.getElementById(formId);</span><br><span class="line">  len = frm.children.length;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = frm.children[i];</span><br><span class="line">    <span class="comment">// 表单元素中有name属性的元素添加验证</span></span><br><span class="line">    <span class="keyword">if</span> (element.name) &#123;</span><br><span class="line">      element.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 使用dataset获取data-自定义属性的值</span></span><br><span class="line">        <span class="keyword">var</span> ruleName = <span class="keyword">this</span>.dataset.rule;</span><br><span class="line">        <span class="keyword">var</span> rule =getRuleByRuleName(rules, ruleName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> span = <span class="keyword">this</span>.nextElementSibling;</span><br><span class="line">        <span class="comment">//判断验证是否成功</span></span><br><span class="line">        <span class="keyword">if</span>(!rule.reg.test(<span class="keyword">this</span>.value) )&#123;</span><br><span class="line">          <span class="comment">//验证不成功</span></span><br><span class="line">          span.innerText = rule.tip;</span><br><span class="line">          span.style.color = <span class="string">"red"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//验证成功</span></span><br><span class="line">          span.innerText = <span class="string">""</span>;</span><br><span class="line">          span.style.color = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则的名称获取规则对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRuleByRuleName</span>(<span class="params">rules, ruleName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">      len = rules.length;</span><br><span class="line">  <span class="keyword">var</span> rule = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rules[i].name == ruleName) &#123;</span><br><span class="line">      rule = rules[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="伪数组和数组"><a href="#伪数组和数组" class="headerlink" title="伪数组和数组"></a>伪数组和数组</h3><p>在JavaScript中，除了5种原始数据类型之外，其他所有的都是对象，包括函数（Function）。</p>
<h4 id="对象与数组的关系"><a href="#对象与数组的关系" class="headerlink" title="对象与数组的关系"></a>对象与数组的关系</h4><p>在说区别之前，需要先提到另外一个知识，就是 JavaScript 的原型继承。<br>所有 JavaScript 的内置构造函数都是继承自 <code>Object.prototype</code> 。<br>在这个前提下，可以理解为使用 <code>new Array()</code> 或 <code>[]</code> 创建出来的数组对象，都会拥有 <code>Object.prototype</code> 的属性值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;<span class="comment">// 拥有 Object.prototype 的属性值</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="comment">//使用数组直接量创建的数组，由于 Array.prototype 的属性继承自 Object.prototype，</span></span><br><span class="line"><span class="comment">//那么，它将同时拥有 Array.prototype 和 Object.prototype 的属性值</span></span><br></pre></td></tr></table></figure>
<p>可以得到对象和数组的第一个区别：对象没有数组 Array.prototype 的属性值。</p>
<h4 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h4><p>数组具有一个最基本特征：索引，这是对象所没有的，下面来看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"> </span><br><span class="line">obj[<span class="number">2</span>] = <span class="string">'a'</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">'a'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="number">2</span>]); <span class="comment">// =&gt; a</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">2</span>]); <span class="comment">// =&gt; a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.length); <span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>obj[2]输出’a’，是因为对象就是普通的键值对存取数据</li>
<li>而arr[2]输出’a’ 则不同，数组是通过索引来存取数据，arr[2]之所以输出’a’，是因为数组arr索引2的位置已经存储了数据</li>
<li>obj.length并不具有数组的特性，并且obj没有保存属性length，那么自然就会输出undefined</li>
<li>而对于数组来说，length是数组的一个内置属性，数组会根据索引长度来更改length的值</li>
<li>为什么arr.length输出3，而不是1<ul>
<li>在给数组添加元素时，并没有按照连续的索引添加，所以导致数组的索引不连续，那么就导致索引长度大于元素个数</li>
</ul>
</li>
</ul>
<h4 id="什么是伪数组"><a href="#什么是伪数组" class="headerlink" title="什么是伪数组"></a>什么是伪数组</h4><ol>
<li>拥有 length 属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)</li>
<li>不具有数组所具有的方法</li>
</ol>
<p>伪数组，就是像数组一样有 <code>length</code> 属性，也有 <code>0、1、2、3</code> 等属性的对象，看起来就像数组一样，但不是数组，比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fakeArray = &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="string">"first"</span>,</span><br><span class="line">  <span class="string">"1"</span>: <span class="string">"second"</span>,</span><br><span class="line">  <span class="string">"2"</span>: <span class="string">"third"</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fakeArray.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fakeArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(fakeArray,<span class="string">'+'</span>);</span><br></pre></td></tr></table></figure>
<p>常见的伪数组有：</p>
<ul>
<li>函数内部的 <code>arguments</code></li>
<li>DOM 对象列表（比如通过 <code>document.getElementsByTags</code> 得到的列表）</li>
<li>jQuery 对象（比如 <code>$(&quot;div&quot;)</code> ）</li>
</ul>
<p>伪数组是一个 Object，而真实的数组是一个 Array。</p>
<p>伪数组存在的意义，是可以让普通的对象也能正常使用数组的很多方法，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 循环arguments对象</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// push</span></span><br><span class="line"><span class="comment">// some</span></span><br><span class="line"><span class="comment">// every</span></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>以上在借用数组的原型方法的时候都可以通过数组直接量来简化使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;[].push.call(obj, <span class="string">'d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([].slice.call(obj))</span><br><span class="line"></span><br><span class="line">;[].forEach.call(obj, <span class="function"><span class="keyword">function</span> (<span class="params">num, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul>
<li>对象没有数组 Array.prototype 的属性值，类型是 Object ，而数组类型是 Array</li>
<li>数组是基于索引的实现， length 会自动更新，而对象是键值对</li>
<li>使用对象可以创建伪数组，伪数组可以正常使用数组的大部分方法</li>
</ul>
<h3 id="JavaScript-垃圾回收机制"><a href="#JavaScript-垃圾回收机制" class="headerlink" title="JavaScript 垃圾回收机制"></a>JavaScript 垃圾回收机制</h3><h3 id="JavaScript-运行机制：Event-Loop"><a href="#JavaScript-运行机制：Event-Loop" class="headerlink" title="JavaScript 运行机制：Event Loop"></a>JavaScript 运行机制：Event Loop</h3><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><ul>
<li>Object.assign()</li>
<li>Object.create()</li>
<li>Object.keys()</li>
<li>Object.defineProperty()</li>
</ul>
<h4 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h4><ul>
<li>constructor</li>
<li>hasOwnProperty()</li>
<li>isPrototypeOf</li>
<li>propertyIsEnumerable()</li>
<li>toString()</li>
<li>valueOf()</li>
</ul>
<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="A-代码规范"><a href="#A-代码规范" class="headerlink" title="A 代码规范"></a>A 代码规范</h3><h4 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h4><ul>
<li><a href="https://github.com/feross/standard" target="_blank" rel="noopener">JavaScript Standard Style </a></li>
<li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb JavaScript Style Guide() {</a></li>
</ul>
<h4 id="校验工具"><a href="#校验工具" class="headerlink" title="校验工具"></a>校验工具</h4><ul>
<li><a href="https://github.com/douglascrockford/JSLint" target="_blank" rel="noopener">JSLint</a></li>
<li><a href="https://github.com/jshint/jshint" target="_blank" rel="noopener">JSHint</a></li>
<li><a href="https://github.com/eslint/eslint" target="_blank" rel="noopener">ESLint</a></li>
</ul>
<h3 id="B-Chrome-开发者工具"><a href="#B-Chrome-开发者工具" class="headerlink" title="B Chrome 开发者工具"></a>B Chrome 开发者工具</h3><h3 id="C-文档相关工具"><a href="#C-文档相关工具" class="headerlink" title="C 文档相关工具"></a>C 文档相关工具</h3><ul>
<li>电子文档制作工具: <a href="https://github.com/egoist/docute" target="_blank" rel="noopener">docute</a></li>
<li>流程图工具：<a href="http://logicnet.dk/DiagramDesigner/" target="_blank" rel="noopener">DiagramDesigner</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/15/项目中封装的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/15/项目中封装的方法/" itemprop="url">项目中封装的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-15T11:22:14+08:00">
                2019-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-格式化后台传过来的-quot-lt-gt-等特殊字符"><a href="#一-格式化后台传过来的-quot-lt-gt-等特殊字符" class="headerlink" title="一:格式化后台传过来的&quot;&lt;&gt;等特殊字符"></a>一:格式化后台传过来的&quot;&lt;&gt;等特殊字符</h3><pre><code>有时候后台传入的数据是&amp;quot;&amp;lt;&amp;gt;这种特殊字符,在页面中显示需要转译下
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">formatDetails(str)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">var</span> obj=&#123;</span><br><span class="line">      <span class="string">'&amp;lt;'</span>:<span class="string">'&lt;'</span>,</span><br><span class="line">      <span class="string">'&amp;gt;'</span>:<span class="string">'&gt;'</span>,</span><br><span class="line">      <span class="string">'&amp;quot;'</span>:<span class="string">'"'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      <span class="keyword">while</span>(str.indexOf(key)!=<span class="number">-1</span>)&#123;</span><br><span class="line">        str=str.replace(key,obj[key]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">formatDetails(res.data);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/js之基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/js之基础知识/" itemprop="url">js之基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-08T15:53:22+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-js是一门什么样的语言"><a href="#一-js是一门什么样的语言" class="headerlink" title="一.js是一门什么样的语言:"></a>一.js是一门什么样的语言:</h3><pre><code>js是脚本语言,解释性语言,弱类型语言,基于对象,动态语言
脚本语言:脚本语言是一个不需要显示编译的编程语言
解释性语言:当浏览器解析这行代码的时候,才知道这个变量具体是什么类型,
弱类型语言:声明都用var,没有其他类型的变量声明
基于对象:直接使用系统当中的对象,而不是自己创建对象
动态语言:动态语言是在运行时确定数据类型的语言
 扩展:
   静态语言是指在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型
   编译语言:需要把代码翻译成计算机所认知的二进制语言,才能够执行
</code></pre><h3 id="二-js代码注意问题"><a href="#二-js代码注意问题" class="headerlink" title="二:js代码注意问题:"></a>二:js代码注意问题:</h3><pre><code>1.在一对script的标签中有错误的js代码,那么该错误的代码后面的js代码不会执行
2.如果第一对的script标签中有错误,不会影响后面的script标签中的js代码执行
3.script标签一般是放在body的标签的最后的,这样浏览器渲染时先渲染html文件,之后才走script中的内容,可以提高效率
</code></pre><h3 id="三-js中的数据类型"><a href="#三-js中的数据类型" class="headerlink" title="三:js中的数据类型:"></a>三:js中的数据类型:</h3><pre><code>js中的原始数据类型:number,string,boolean,null,undefined,object
     * number:数字类型(整数和小数)
     * string:字符串类型(的值一般都是用单引号或者是双引号括起来)  &quot;34&quot;
     * boolean:布尔类型(值只有两个,true(真1),false(假0))
     * null:空类型,值只有一个:null,一个对象指向为空了,此时可以赋值为null
     * undefined:未定义,值只有一个:undefined
     * object:对象
基本类型(简单类型),值类型: number,string,boolean
复杂类型(引用类型):object
空类型:undefined,null

值类型的值在哪一块空间中存储? 栈中存储
引用类型的值在哪一块空间中存储?对象在堆上存储,地址在栈上存储

var num=10;//值类型,值在栈上
var obj={};//复杂类型,对象在堆,地址(引用)在栈

值类型之间传递,传递的是值
引用类型之间传递,传递的是地址(引用)

值类型作为函数的参数,传递的是值
引用类型作为函数的参数,传递的是地址

类型转换:
    一:其他类型转数字类型:
           总结:想要转整数用parseInt(),想要转小数用parseFloat()
                    想要转数字:Number();要比上面的两种方式严格
                    例如:
                            1.parseInt();//转整数  console.log(parseInt(&quot;10.98fdsfd&quot;));//10
                            2.parseFloat()//转小数 console.log(parseFloat(&quot;10.98fdsfd&quot;));//10.98
                            3.Number();//转数字  console.log(Number(&quot;10.98fdsfd&quot;));//NaN
    二:其他类型转字符串类型:
           如果变量有意义调用.toString()使用转换
           如果变量没有意义使用String()转换
           例如:
               1.变量无意义
                   var num2;
                   console.log(String(num2));
                   var num3=null;
                   console.log(String(num3));
               2.变量有意义
                   var num2=20;
                   console.log(num2.toString());
    三:其他类型转布尔类型:
        console.log(Boolean(1));//true
        console.log(Boolean(&quot;哈哈&quot;));//true
        console.log(Boolean(0));//false
        console.log(Boolean(&quot;&quot;));//false
        console.log(Boolean(null));//false
        console.log(Boolean(undefined));//false
     break关键字:如果在循环中使用,遇到了break,则立刻跳出当前所在的循环
     continue:在循环中如果遇到continue关键字,直接开始下一次循环
</code></pre><h3 id="四-基本包装类型"><a href="#四-基本包装类型" class="headerlink" title="四:基本包装类型:"></a>四:基本包装类型:</h3><pre><code>//基本包装类型

    //普通变量不能直接调用属性或者方法
    //对象可以直接调用属性和方法

    //基本包装类型:本身是基本类型,但是在执行代码的过程中,如果这种类型的变量调用了属性或者是方法,
    那么这种类型就不再是基本类型了,而是基本包装类型,这个变量也不是普通的变量了,而是基本包装类型对象
    基本包装类型对象:string number boolean
    例子:
        //    var str=&quot;hello&quot;;
        //    str=str.replace(&quot;ll&quot;,&quot;HH&quot;);
        //    console.log(str);

        //    var str=new String(&quot;hello&quot;);
        //    str=str.replace(&quot;ll&quot;,&quot;HH&quot;);
        //    console.log(str);
        //    str=null;

        //    var num=10;//number----&gt;
        //    console.log(num.toString());
</code></pre><h3 id="五-函数的相关知识点"><a href="#五-函数的相关知识点" class="headerlink" title="五:函数的相关知识点:"></a>五:函数的相关知识点:</h3><pre><code>一:函数需要先定义,然后才能使用
    函数名字:要遵循驼峰命名法
    函数一旦重名,后面的会把前面的函数覆盖
    命名函数:函数如果有名字,就是命名函数
     匿名函数:函数如果没有名字,就是匿名函数
    函数定义:
         * 1. 函数声明--函数定义
         * function 函数名(){
         *     函数体
         * }
         2.函数表达式:
              * 把一个函数给一个变量,此时形成了函数表达式
              * var 变量=匿名函数;
              * 例子:
              * var f1=function (){
              *
              * };
              * 如果是函数表达式,那么此时前面的变量中存储的就是一个函数,而这个变量就相当于是一个函数,就可以直接加小括号调用了
              * f1();
         3.函数的自调用,没有名字,调用---声明的同时,直接调用(一次性的)
                (function(){console.log(&quot;嘎嘎&quot;)})();

    1.函数可以作为参数使用,
        如果一个函数作为参数,那么我们说这个参数(函数)可以叫回调函数
       只要是看到一个函数作为参数使用了,那就是回调函数
    2.:函数是可以作为返回值使用的:(闭包)
             function f1() {
                   console.log(&quot;f1函数调用了&quot;);
                   return function () {
                     console.log(&quot;这是一个函数&quot;);
                   };
                 }
                 var ff=f1();//调用
                      //ff就是一个函数了
                 ff();

    Ctrl +鼠标左键----&gt;转到定义
    * 形参:函数定义的时候函数名字后面的小括号里的变量就是参数,是不需要写var
    * 实参:函数在调用的时候小括号里传入的值叫实参,实参可以是变量也可以是值
    * 如果一个函数中有return ,那么这个函数就有返回值
    * 如果一个函数中没有return,那么这个函数就没有返回值
    * 如果一个函数中没有明确的返回值,那么调用的时候接收了,结果就是undefined
    * (没有明确返回值:函数中没有return,函数中有return,但是return后面没有任何内容)
    arguments-----&gt;数组使用------伪数组---
        * arguments-----&gt;可以获取函数调用的时候,传入的实参的个数
        * arguments是一个对象,是一个伪数组
        * arguments.length---&gt;是实参的个数
        * arguments[索引]----&gt;实参的值
    function f1() {
          var sum=0;
          for(var i=0;i&lt;arguments.length;i++){
            sum+=arguments[i];
          }
          return sum;
        }
    console.log(f1(10,20,30));

二:作用域和作用域链:
        1.作用域：变量可以起作用的范围
            作用域:使用范围
            /*
            *
            * 全局变量:声明的变量是使用var声明的,那么这个变量就是全局变量,全局变量可以在页面的任何位置使用
            * 除了函数以外,其他的任何位置定义的变量都是全局变量
            * 局部变量:在函数内部定义的变量,是局部变量,外面不能使用
            * 全局变量,如果页面不关闭,那么就不会释放,就会占空间,消耗内存
            *
            * 全局作用域:全局变量的使用范围
            * 局部作用域:局部变量的使用范围
            *
            * 块级作用域:一对大括号就可以看成是一块,在这块区域中定义的变量,只能在这个区域中使用,但是在js中在这个块级作用域中定义的变量,外面也能使用;
            * 说明:js没有块级作用域,只有函数除外
            *
            * 隐式全局变量:声明的变量没有var,就叫隐式全局变量
            * 全局变量是不能被删除的,隐式全局变量是可以被删除的
            * 定义变量使用var是不会被删除的,没有var是可以删除的
            */
        2.作用域链:
            将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。
             var num=10;
                function f1() {
                  var num=20;
                  function f2() {
                    var num=30;
                    function f3() {
                      var num=50;
                      console.log(num);
                    }
                    f3();
                  }
                  f2();
                }
                f1();
三:预解析:
        1.提前解析代码
            * 预解析:就是在解析代码之前
            * 预解析做什么事?
            * 把变量的声明提前了----提前到当前所在的作用域的最上面
            * 函数的声明也会被提前---提前到当前所在的作用域的最上面
        2.预解析分段问题的局部作用域问题:         
            //预解析中,变量的提升,只会在当前的作用域中提升,提前到当前的作用域的最上面
             //函数中的变量只会提前到函数的作用域中的最前面,不会出去
             //预解析会分段(多对的script标签中函数重名,预解析的时候不会冲突)              
</code></pre><h3 id="六-object-对象-的相关知识"><a href="#六-object-对象-的相关知识" class="headerlink" title="六:object(对象)的相关知识:"></a>六:object(对象)的相关知识:</h3><pre><code>(js高级教程Number,String,Date,Array,Boolean,Math,RegExp)
          什么是对象:
              对象:有属性和方法,特指的某个事物
              对象:一组无序属性的集合的键值对,属性的值可以是任意的类型
      一:创建对象的方法:
              1.调用系统的构造函数创建对象
                   var 变量名= new Object(); Object 是系统的构造函数  Array

              2.自定义构造函数创建对象(结合第一种和需求通过工厂模式创建对象)
               *  //工厂模式创建对象
                      function createObject(name,age) {
                        var obj = new Object();//创建对象
                        //添加属性
                        obj.name = name;
                        obj.age = age;
                        //添加方法
                        obj.sayHi = function () {
                          console.log(&quot;阿涅哈斯诶呦,我叫:&quot; + this.name + &quot;我今年:&quot; + this.age);
                        };
                        return obj;
                      }
                      //创建人的对象
                      var per1 = createObject(&quot;小芳&quot;,20);
                      per1.sayHi();


                   自定义构造函数创建对象,我要自己定义一个构造函数,自定义构造函数,创建对象
                     函数和构造函数的区别；名字是不是大写(首字母是大写)
                      function Person(name,age) {
                        this.name=name;
                        this.age=age;
                        this.sayHi=function () {
                          console.log(&quot;我叫:&quot;+this.name+&quot;,年龄是:&quot;+this.age);
                        };
                      } 
                      //自定义构造函数创建对象:先自定义一个构造函数,创建对象
                      var obj=new Person(&quot;小明&quot;,10);
                      console.log(obj.name);
                      console.log(obj.age);
                      obj.sayHi();

                      自定义构造函数创建对象做了什么事?(new 的执行过程:)
                              * 1. 在内存中开辟(申请一块空闲的空间)空间,存储创建的新的对象
                              * 2. 把this设置为当前的对象
                              * 3. 设置对象的属性和方法的值
                              * 4. 把this这个对象返回

               * 3.字面量的方式创建对象
                      var obj={};
      //遍历对象,是不能通过for循环遍历,因为无序要用for in
          //key是一个变量,这个变量中存储的是该对象的所有的属性的名字
          var json = {
                &quot;name&quot;: &quot;小明&quot;,
                &quot;age&quot;: &quot;10&quot;,
                &quot;sex&quot;: &quot;男&quot;
              };
          for (var key in json) {
            console.log(key + &quot;===========&quot; + json[key]);
          }
</code></pre><h4 id="Math对象-是静态对象"><a href="#Math对象-是静态对象" class="headerlink" title="Math对象;(是静态对象)"></a>Math对象;(是静态对象)</h4><pre><code>实例对象:通过构造函数创建出来,实例化的对象
静态对象:不需要创建,直接就是一个对象,方法(静态方法)直接通过这个对象名字调用,
实例方法必须通过实例对象调用
静态方法必须通过大写的对象调用
    常用的:
    Math.PI----π---
    Math.E----常数的底数
    Math.abs(值)-----绝对值
    Math.ceil(值)----向上取整
    Math.floor(值)---向下取整
    Math.max(x,y,z,...,n)---返回 x,y,z,...,n 中的最高值。
    Math.min(x,y,z,...,n)---返回 x,y,z,...,n 中的最小值。
    Math.pow(x,y)---返回 x 的 y 次幂。
    Math.random()---返回 0 ~ 1 之间的随机数。
    Math.round(x)---四舍五入。
    Math.sqrt(x)---返回数的平方根。
</code></pre><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象:"></a>Date对象:</h4><pre><code>1.创建date对象:
    var dt = new Date(); 
2.常用方法:
     dt.getFullYear();//年
     dt.getMonth();//月---从0开始
     dt.getDate();//日
     dt.getHours();//小时
     dt.getMinutes();//分钟
     dt.getSeconds();//秒
     dt.getDay();//星期---从0开始
     dt.toDateString();//日期
     dt.toLocaleDateString();//日期
     dt.toTimeString();//时间
     dt.toLocaleTimeString();//时间
     dt.valueOf();//毫秒
</code></pre><h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象:"></a>String对象:</h4><pre><code>1.String----&gt;是一个对象
    * 字符串可以看成是字符组成的数组,但是js中没有字符类型
    * 字符是一个一个的,在别的语言中字符用一对单引号括起来
    * 在js中字符串可以使用单引号也可以使用双引号
    * 因为字符串可以看成是数组,所以,可以通过for循环进行遍历
    *
    * 字符串特性:不可变性,字符串的值是不能改变
    *
    * 字符串的值之所以看起来是改变的,那是因为指向改变了,并不是真的值改变了
2.常用属性:
     * 字符串的常用属性:
         * .length------&gt;字符串的长度
         * .charAt(索引),返回值是指定索引位置的字符串,超出索引,结果是空字符串
         * .fromCharCode(数字值,可以是多个参数),返回的是ASCII码对应的值
         * .concat(字符串1,字符串2,...);返回的是拼接之后的新的字符串
         * .indexOf(要找的字符串,从某个位置开始的索引);返回的是这个字符串的索引值,没找到则返回-1
         * .lastIndexOf(要找的字符串);从后向前找,但是索引仍然是从左向右的方式,找不到则返回-1
         * .replace(&quot;原来的字符串&quot;,&quot;新的字符串&quot;);用来替换字符串的
         * .slice(开始的索引,结束的索引); 从索引5的位置开始提取,到索引为10的前一个结束,没有10，并返回这个提取后的字符串
         * .split(&quot;要干掉的字符串&quot;,切割后留下的个数);切割字符串
         * .substr(开始的位置,个数);返回的是截取后的新的字符串
         * .substring(开始的索引,结束的索引),返回截取后的字符串,不包含结束的索引的字符串
         * .toLocaleLowerCase();转小写
         * .toLowerCase();转小写
         * .toLocaleUpperCase()转大写
         * .toUpperCase();转大写
         * .trim();干掉字符串两端的空格
</code></pre><h4 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象:"></a>Array对象:</h4><pre><code>1.数组:一组有序的数据
        数组的作用:可以一次性存储多个数据
        如何创建数组:
            1. 通过构造函数创建数组
                var 数组名=new Array();//定义了一个数组
            2. 通过字面量的方式创建数组
                var 数组名=[];//空数组
        数组可以存储的各种类型:
                var arr=[10,&quot;哈哈&quot;,true,null,undefined,new Object()];
         冒泡排序:上面有示例
2.判断是不是数组2种方法:
    1.Array.isArray(对象)----&gt;判断这个对象是不是数组
    2. instanceof关键字
3.常用属性:
        * .concat(数组,数组,数组,...) 组合一个新的数组
         * .every(函数)--返回值是布尔类型,函数作为参数使用,函数中有三个参数,第一个参数是元素的值，第二个参数是索引值,第三个参数是原来的数组(没用)
         * 如果这个数组中的每个元素的值都符合条件,最后才返回的是true
         *
         * .filter(函数);返回的是数组中每一个元素都复合条件的元素,组成了一个新的数组
         *
         * .push(值);---&gt;把值追加到数组中,加到最后了---返回值也是追加数据之后的数组长度
         * .pop();---&gt;删除数组中最后一个元素,返回值就是删除的这个值
         * .shift();---&gt;删除数组中第一个元素,返回值就是删除的这个值
         * .unshift();---&gt;向数组的第一个元素前面插入一个新的元素,----返回值是插入后的程度
         * .forEach(函数)方法---遍历数组用---相当于for循环
         * .indexOf(元素值);返回的是索引,没有则是-1
         * .join(&quot;字符串&quot;);----返回的是一个字符串
         * .map(函数);---&gt;数组中的每个元素都要执行这个函数,把执行后的结果重新的全部的放在一个新的数组中
         * .reverse();-----&gt;反转数组
         * .sort();---排序的,可能不稳定,如果不稳定,请写MDN中的那个固定的代码
         * .arr.slice(开始的索引,结束的索引);把截取的数组的值放在一个新的数组中,但是不包含结束的索引对应的元素值
         * .splice(开始的位置,要删除的个数,替换的元素的值);一般是用于删除数组中的元素,或者是替换元素,或者是插入元素
</code></pre><p>###七:js学习中三种对象:</p>
<pre><code>* 1.内置对象----js系统自带的对象
        Math, Date, String, Array, Object
* 2.自定义对象---自己定义的构造函数创建的对象
* 3.浏览器对象---
        DOM:Document Object Model 文档对象模型,操作页面元素的
        BOM:Browser Object Model 浏览器对象模型,操作浏览器的
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/js之webapi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/js之webapi/" itemprop="url">js之webapi</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-08T15:44:03+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="webapi的知识点"><a href="#webapi的知识点" class="headerlink" title="webapi的知识点:"></a>webapi的知识点:</h1><h2 id="一-节点-元素-自定义属性相关知识点"><a href="#一-节点-元素-自定义属性相关知识点" class="headerlink" title="一.节点,元素,自定义属性相关知识点:"></a>一.节点,元素,自定义属性相关知识点:</h2><pre><code>文档:document
元素:页面中所有的标签,元素---element,  标签----元素---对象
节点:页面中所有的内容(标签,属性,文本(文字,换行,空格,回车)),Node
根元素:html标签
</code></pre><p>###1.节点的属性:<br>        可以使用标签–元素.出来,可以使用属性节点.出来,文本节点.点出来<br>        nodeType:节点的类型:1—-标签,2—属性,3—文本<br>        nodeName:节点的名字:标签节点–大写的标签名字,属性节点–小写的属性名字,文本节点–#text<br>        nodeValue:节点的值:标签节点—null,属性节点—属性值,文本节点—文本内容<br>        使用:<br>          ulObj=my$(“uu”);ulObj.nodeType,ulObj.nodeName,ulObj.nodeValue,<br>          利用nodeType判断是标签是属性还是文本,<br>          利用nodeName获取指定标签,<br>        获取节点的方法:<br>          //12行代码:都是获取节点和元素的<br>          //ul<br>          var ulObj=document.getElementById(“uu”);<br>          var threeObj=document.getElementById(“three”);<br>          //父级节点<br>          console.log(ulObj.parentNode);<br>          //父级元素<br>          console.log(ulObj.parentElement);<br>          //子节点<br>          console.log(ulObj.childNodes);<br>          //子元素<br>          console.log(ulObj.children);<br>          console.log(“==============================================”);<br>          //第一个子节点<br>          console.log(ulObj.firstChild);//————————IE8中是第一个子元素<br>          //第一个子元素<br>          console.log(ulObj.firstElementChild);//—————–IE8中不支持<br>          //最后一个子节点<br>          console.log(ulObj.lastChild);//————————IE8中是第一个子元素<br>          //最后一个子元素<br>          console.log(ulObj.lastElementChild);//—————–IE8中不支持<br>          //某个元素的前一个兄弟节点<br>          console.log(threeObj.previousSibling);//————————IE8中是第一个子元素<br>          //某个元素的前一个兄弟元素<br>          console.log(threeObj.previousElementSibling);//—————–IE8中不支持<br>          //某个元素的后一个兄弟节点<br>          console.log(threeObj.nextSibling);//————————IE8中是第一个子元素<br>          //某个元素的后一个兄弟元素<br>          console.log(threeObj.nextElementSibling);//—————–IE8中不支持<br>          //总结:凡是获取节点的代码在谷歌和火狐得到的都是  相关的节点<br>          //凡是获取元素的代码在谷歌和火狐得到的都是   相关的元素<br>          //从子节点和兄弟节点开始,凡是获取节点的代码在IE8中得到的是元素,获取元素的相关代码,在IE8中得到的是undefined—-元素的代码,iE中不支持</p>
<p>###2.元素的创建:<br>      元素创建—–为了提高用户的体验<br>      元素创建的三种方式:</p>
<pre><code>1. document.write(&quot;标签的代码及内容&quot;);
  document.write()创建元素,缺陷:如果是在页面加载完毕后,此时通过这种方式创建元素,
  那么页面上存在的所有的内容全部被干掉
2. 对象.innerHTML=&quot;标签及代码&quot;;
    document.getElementById(&apos;idm名&apos;).innerHTML=&quot;&lt;p&gt;窗前明月光,疑是地上霜,举头望明月,低头思故乡&lt;/p&gt;&quot;;
3. document.createElement(&quot;标签的名字&quot;);
  1.首先创建元素(可根据需要在元素中增加内容 元素对象.innerHTML=&apos;xxx&apos;)
  2.把元素追加到父级元素中
  //document.createElement(&quot;标签名字&quot;);
  var pObj = document.createElement(&quot;p&quot;);
   document.getElementById(&apos;id名&apos;).appendChild(pObj);
   父级元素.appendChild(子级元素对象)
    //在父级元素后追加
   父级元素.insertBefore(新的子级元素对象,参照的子级对象);
    //在参照子级元素前添加新子级对象
    父级元素.removeChild(要删除的子级对象);
</code></pre><h3 id="3-自定义属性的操作"><a href="#3-自定义属性的操作" class="headerlink" title="3.自定义属性的操作"></a>3.自定义属性的操作</h3><pre><code>自定义属性:标签原本没有这个属性,为了存储数据,程序员自己添加的属性
自定义属性无法直接通过DOM对象的方式获取或者设置
对象.getAttribute(&quot;自定义属性名字&quot;);获取自定义属性的值
对象.setAttribute(&quot;属性名字&quot;,&quot;值&quot;);设置自定义属性及值
移除自定义属性
对象.removeAttribute(&quot;属性的名字&quot;);    
</code></pre><h2 id="二-JS浏览器BOM对象中的属性和方法"><a href="#二-JS浏览器BOM对象中的属性和方法" class="headerlink" title="二:JS浏览器BOM对象中的属性和方法:"></a>二:JS浏览器BOM对象中的属性和方法:</h2><h3 id="1-location对象"><a href="#1-location对象" class="headerlink" title="1.location对象:"></a>1.location对象:</h3><pre><code>location对象中的属性和方法:console.log(window.location);
</code></pre><p><img src="/2019/01/08/js之webapi/location.jpg" alt="Alt text">;<br>        例如一个地址为:localhost:8080/index.html#12580<br>        地址栏上#及后面的内容:window.location.hash<br>          console.log(window.location.hash);//12580<br>        主机名及端口号:window.location.host<br>          console.log(window.location.host);//localhost:8080<br>        主机名:window.location.hostname<br>          console.log(window.location.hostname);//localhost<br>        文件的路径—相对路径:window.location.pathname<br>          console.log(window.location.pathname);//index.html<br>        端口号:window.location.port<br>          console.log(window.location.port);//8080<br>        协议:window.location.protocol<br>          console.log(window.location.protocol);//http<br>        搜索的内容:window.location.search<br>          console.log(window.location.search);//是url后边?号跟的搜索的内容<br>        设置跳转的页面的地址<br>          location.href=”<a href="http://www.jd.com&quot;;//属性-----&gt;必须记住,有历史记录,浏览器返回按钮呢可点" target="_blank" rel="noopener">http://www.jd.com&quot;;//属性-----&gt;必须记住,有历史记录,浏览器返回按钮呢可点</a><br>          location.assign(“<a href="http://www.jd.com&quot;);//方法--&gt;有历史记录,浏览器返回按钮呢可点" target="_blank" rel="noopener">http://www.jd.com&quot;);//方法--&gt;有历史记录,浏览器返回按钮呢可点</a><br>          location.reload();//重新加载–刷新<br>          location.replace(“<a href="http://www.jd.com&quot;);//没有历史记录,所以浏览器中返回按钮不可点" target="_blank" rel="noopener">http://www.jd.com&quot;);//没有历史记录,所以浏览器中返回按钮不可点</a></p>
<h3 id="2-history对象"><a href="#2-history对象" class="headerlink" title="2.history对象:"></a>2.history对象:</h3><pre><code>/*必须需要先有路径跳转后前进后退才能生效*/
  window.history.forward()//前进
  window.history.back();//后退
  window.history.go();// go()方法只有一个参数，可以是整数、负数。如果是正数，就前进。负数就是后退。
  history.go(-1)和history.back()的区别:
    history.go(-1)表示后退与刷新。如数据有改变也随之改变
    history.back()只是单纯的返回到上一页
</code></pre><h3 id="3-navigator对象"><a href="#3-navigator对象" class="headerlink" title="3.navigator对象:"></a>3.navigator对象:</h3><pre><code>window.navigator.userAgent
/*通过userAgent可以判断用户浏览器的类型*/
window.navigator.platform
/*通过platform可以判断浏览器所在的系统平台类型.*/
</code></pre><h2 id="三-js三大系列-offset系列-scroll系列-client系列"><a href="#三-js三大系列-offset系列-scroll系列-client系列" class="headerlink" title="三:js三大系列:offset系列,scroll系列,client系列"></a>三:js三大系列:offset系列,scroll系列,client系列</h2><h3 id="offset系列"><a href="#offset系列" class="headerlink" title="offset系列:"></a>offset系列:</h3><pre><code>div如果要移动,就需要脱离文档流,(position:absolute)
  注意:如果样式的代码是在style的标签中设置,外面是获取不到:
      &lt;style&gt;
          #dv{
              left:50px;
          }
      &lt;/style&gt;
      &lt;script&gt;
          document.getElementById(&apos;div&apos;).style.left;
          /*这样是获取不到div设置的left值的,除非div的是内联样式而不是在style中
         然而document.getElementById(&apos;div&apos;).offsetLeft;是既可以获取到内联样式的属性值也可以
         获取到style设置的属性值,所以我们要用offset系列的来获取
          */

      &lt;/script&gt;

* offsetHeight:获取元素的高(有边框)
* offsetWidth:获取元素的宽(有边框)
* offsetLeft:获取元素距离左边位置的值
* offsetTop:获取元素距离上面位置的值
没有脱离文档流情况下:
    offsetLeft:父级元素margin+父级元素padding+父级元素的border+自己的margin其实相对于document
    或者body的位置
脱离文档流了:
    主要是自己的left和自己的margin,其实是相对于父级元素的位置
</code></pre><h3 id="scroll系列"><a href="#scroll系列" class="headerlink" title="scroll系列:"></a>scroll系列:</h3><pre><code>* scroll系列:卷曲---滚出去
* scrollWidth:元素中内容的实际的宽(没有边框),如果没有内容就是元素的宽
* scrollHeight:元素中内容的实际的高(没有边框),如果没有内容就是元素的高
    比如一个div高为200px,里面的内容400px,这时内容会超出div高度,使用scrollHeight就是400px
* scrollTop:元素向上卷曲的距离
* scrollLeft:元素向左卷曲的的距离
</code></pre><h3 id="client系列-可视区域"><a href="#client系列-可视区域" class="headerlink" title="client系列:可视区域"></a>client系列:可视区域</h3><pre><code>* clientWidth:可视区域的宽(没有边框),边框内部的宽度
* clientHeight:可视区域的高(没有边框),边框内部的高度
* clientLeft:左边边框的宽度
* clientTop:上面的边框的宽度
* clientX:可视区域的横坐标
* clientY:可视区域的纵坐标
</code></pre><h2 id="四-元素隐藏的不同方式"><a href="#四-元素隐藏的不同方式" class="headerlink" title="四:元素隐藏的不同方式:"></a>四:元素隐藏的不同方式:</h2><pre><code>1.$(&quot;#dv&quot;).style.display=&quot;none&quot;;//不占位
2.$(&quot;#dv&quot;).style.visibility=&quot;hidden&quot;;//占位
3.$(&quot;#dv&quot;).style.opacity=0;//占位
4.$(&quot;#dv&quot;).style.height=&quot;0px&quot;;//占位
  $(&quot;#dv&quot;).style.border=&quot;0px solid red&quot;;
</code></pre><h2 id="五-大量字符串拼接需要注意-优化-的问题"><a href="#五-大量字符串拼接需要注意-优化-的问题" class="headerlink" title="五:大量字符串拼接需要注意(优化)的问题:"></a>五:大量字符串拼接需要注意(优化)的问题:</h2><pre><code>在我们有大量字符串进行拼接的时候,因为字符串具有不可变性,所以每拼接一个字符串的时候都会新开辟内存
空间,这会极大的占用内存,所以这个时候我们可以把它设置成一个数组,把每个字符串加到数组中然后再拼接在
一起,这样就不会占用大量的内存了!(据说在新的浏览器中已经优化了这个问题,可能字符串拼接比数组拼接还好?)
例子:
    /*点击按钮,把在input输入的字符串拼接起来*/
    1.用字符串拼接的办法:(不推荐)
      document.getElementById(&quot;btn&quot;).onclick = function () {
        var str = &quot;&quot;;//声明一个字符串变量
        //获取所有的文本框
        var inputs = document.getElementsByTagName(&quot;input&quot;);
        //每个文本框的value属性值
        for (var i = 0; i &lt; inputs.length; i++) {
          if (inputs[i].type != &quot;button&quot;) {
            str+=inputs[i].value+&quot;|&quot;;
          }
        }
        console.log(str+inputs[inputs.length-1].value);
      };
    2.推荐使用数组的方式拼接大量的字符串
    document.getElementById(&quot;btn&quot;).onclick = function () {
        var str = [];
        //获取所有的文本框
        var inputs = document.getElementsByTagName(&quot;input&quot;);
        //每个文本框的value属性值
        for (var i = 0; i &lt; inputs.length; i++) {
          if (inputs[i].type != &quot;button&quot;) {
            str.push(inputs[i].value);
          }
        }
        console.log(str.join(&quot;|&quot;));//字符串
      };
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/经典案例收集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/经典案例收集/" itemprop="url">经典案例收集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T10:15:01+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="总结了一些自己喜欢的经典案例"><a href="#总结了一些自己喜欢的经典案例" class="headerlink" title="总结了一些自己喜欢的经典案例:"></a>总结了一些自己喜欢的经典案例:</h2><h3 id="1-模拟输入框搜索"><a href="#1-模拟输入框搜索" class="headerlink" title="1.模拟输入框搜索"></a>1.模拟输入框搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    #box &#123;</span><br><span class="line">      width: 450px;</span><br><span class="line">      margin: 200px auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #txt &#123;</span><br><span class="line">      width: 350px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #pop &#123;</span><br><span class="line">      width: 350px;</span><br><span class="line">      border: 1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #pop ul &#123;</span><br><span class="line">      margin: 10px;</span><br><span class="line">      padding: 0px;</span><br><span class="line">      width: 200px;</span><br><span class="line">      list-style-type: none;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #pop ul li &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; id=&quot;txt&quot; value=&quot;&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot; value=&quot;搜索&quot; id=&quot;btn&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">	function my$(id) &#123;</span><br><span class="line">    	return document.getElementById(id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function setInnerText(element, text) &#123;</span><br><span class="line">	    if (typeof element.textContent == &quot;undefined&quot;) &#123;</span><br><span class="line">	        element.innerText = text;</span><br><span class="line">	    &#125; else &#123;</span><br><span class="line">	        element.textContent = text;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  var keyWords = [&quot;小杨才是最纯洁的&quot;, &quot;小杨才是最帅的&quot;, &quot;小段是最猥琐的&quot;, &quot;小超是最龌龊的&quot;, &quot;苹果是个水果&quot;, &quot;苹果很贵啊&quot;, &quot;苹果好吃&quot;, &quot;苹果此次召回还是没有中国&quot;];</span><br><span class="line">  //获取文本框注册键盘抬起事件</span><br><span class="line">  my$(&quot;txt&quot;).onkeyup = function () &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //每一次的键盘抬起都判断页面中有没有这个div</span><br><span class="line">    if(my$(&quot;dv&quot;))&#123;</span><br><span class="line">      //删除一次</span><br><span class="line">      my$(&quot;box&quot;).removeChild(my$(&quot;dv&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    //获取文本框输入的内容</span><br><span class="line">    var text = this.value;</span><br><span class="line">    //临时数组--空数组-------&gt;存放对应上的数据</span><br><span class="line">    var tempArr = [];</span><br><span class="line">    //把文本框输入的内容和数组中的每个数据对比</span><br><span class="line">    for (var i = 0; i &lt; keyWords.length; i++) &#123;</span><br><span class="line">      //是否是最开始出现的</span><br><span class="line">      if (keyWords[i].indexOf(text) == 0) &#123;</span><br><span class="line">        tempArr.push(keyWords[i]);//追加</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果文本框是空的,临时数组是空的,不用创建div</span><br><span class="line">    if (this.value.length == 0 || tempArr.length == 0) &#123;</span><br><span class="line">      //如果页面中有这个div,删除这个div</span><br><span class="line">      if (my$(&quot;dv&quot;)) &#123;</span><br><span class="line">        my$(&quot;box&quot;).removeChild(my$(&quot;dv&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建div,把div加入id为box的div中</span><br><span class="line">    var dvObj = document.createElement(&quot;div&quot;);</span><br><span class="line">    my$(&quot;box&quot;).appendChild(dvObj);</span><br><span class="line">    dvObj.id = &quot;dv&quot;;</span><br><span class="line">    dvObj.style.width = &quot;350px&quot;;</span><br><span class="line">    //dvObj.style.height=&quot;100px&quot;;//肯定是不需要的------</span><br><span class="line">    dvObj.style.border = &quot;1px solid green&quot;;</span><br><span class="line">    //循环遍历临时数组,创建对应的p标签</span><br><span class="line">    for (var i = 0; i &lt; tempArr.length; i++) &#123;</span><br><span class="line">      //创建p标签</span><br><span class="line">      var pObj = document.createElement(&quot;p&quot;);</span><br><span class="line">      //把p加到div中</span><br><span class="line">      dvObj.appendChild(pObj);</span><br><span class="line">      setInnerText(pObj, tempArr[i]);</span><br><span class="line">      pObj.style.margin = 0;</span><br><span class="line">      pObj.style.padding = 0;</span><br><span class="line">      pObj.style.cursor = &quot;pointer&quot;;</span><br><span class="line">      pObj.style.marginTop = &quot;5px&quot;;</span><br><span class="line">      pObj.style.marginLeft = &quot;5px&quot;;</span><br><span class="line">      //鼠标进入</span><br><span class="line">      pObj.onmouseover = function () &#123;</span><br><span class="line">        this.style.backgroundColor = &quot;yellow&quot;;</span><br><span class="line">      &#125;;</span><br><span class="line">      //鼠标离开</span><br><span class="line">      pObj.onmouseout = function () &#123;</span><br><span class="line">        this.style.backgroundColor = &quot;&quot;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/兼容性代码合集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/兼容性代码合集/" itemprop="url">兼容性代码合集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-20T09:58:23+08:00">
                2018-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="这里放的都是关于浏览器兼容性代码的函数封装总结"><a href="#这里放的都是关于浏览器兼容性代码的函数封装总结" class="headerlink" title="这里放的都是关于浏览器兼容性代码的函数封装总结!"></a>这里放的都是关于浏览器兼容性代码的函数封装总结!</h1><h2 id="浏览器兼容性的判断思路"><a href="#浏览器兼容性的判断思路" class="headerlink" title="浏览器兼容性的判断思路:"></a>浏览器兼容性的判断思路:</h2><pre><code>如果这个属性在浏览器中不支持,那么这个属性的类型是undefined
判断这个属性的类型 是不是undefined,就知道浏览器是否支持
</code></pre><h2 id="一-innerText-textContent-innerHTML的区别和兼容性"><a href="#一-innerText-textContent-innerHTML的区别和兼容性" class="headerlink" title="一:innerText,textContent,innerHTML的区别和兼容性"></a>一:innerText,textContent,innerHTML的区别和兼容性</h2><h3 id="1-innerText和textContent兼容代码"><a href="#1-innerText和textContent兼容代码" class="headerlink" title="1.innerText和textContent兼容代码:"></a>1.innerText和textContent兼容代码:</h3><pre><code>    设置标签中的文本内容,应该使用innerText属性,谷歌,火狐,IE8都支持,
    设置标签中的文本内容,应该使用textContent属性,谷歌,火狐支持,IE8不支持
    目前的浏览器都支持innerText,应该是属于ie的标准,textContent本身是火狐支持,IE8不支持
    设置任意的标签中间的任意文本内容,两个参数(标签元素,文本内容)
  function setInnerText(element,text) {
    //判断浏览器是否支持这个属性
    if(typeof element.textContent ==&quot;undefined&quot;){//不支持
      element.innerText=text;
    }else{//支持这个属性
      element.textContent=text;
    }
  }
  setInnerText(document.getElementById(&apos;id名&apos;),&apos;你好啊&apos;);
  //获取任意标签中间的文本内容,一个参数(标签元素)
  function getInnerText(element) {
    if(typeof element.textContent==&quot;undefined&quot;){
     return element.innerText;
    }else{
      return element.textContent;
    }
  }
2.innerText,textContent,innerHTML区别:
    想要设置标签内容(可以带标签),使用innerHTML,想要设置文本内容,innerText或者textContent,
或者innerHTML,推荐用innerHTML
</code></pre><h2 id="二-获取节点和元素的方法以及兼容性代码"><a href="#二-获取节点和元素的方法以及兼容性代码" class="headerlink" title="二:获取节点和元素的方法以及兼容性代码"></a>二:获取节点和元素的方法以及兼容性代码</h2><pre><code>1.获取节点和元素的方法:
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;dv&quot;&gt;哦哦</span><br><span class="line">  &lt;span&gt;这是div中的第一个span标签&lt;/span&gt;</span><br><span class="line">  &lt;p&gt;这是div中的第二个元素,第一个p标签&lt;/p&gt;</span><br><span class="line">  &lt;ul id=&quot;uu&quot;&gt;</span><br><span class="line">    &lt;li&gt;这是ul中的第一个标签&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是ul中的第二个标签&lt;/li&gt;</span><br><span class="line">    &lt;li id=&apos;three&apos;&gt;这是ul中的第三个标签&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是ul中的第四个标签&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是ul中的第五个标签&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<pre><code>//12行代码:都是获取节点和元素的
//ul
var ulObj=document.getElementById(&quot;uu&quot;);
//父级节点
console.log(ulObj.parentNode);//
//父级元素
console.log(ulObj.parentElement);
//子节点
console.log(ulObj.childNodes);
//子元素
console.log(ulObj.children);
console.log(&quot;==============================================&quot;);
//第一个子节点
console.log(ulObj.firstChild);//------------------------IE8中是第一个子元素
//第一个子元素
console.log(ulObj.firstElementChild);//-----------------IE8中不支持
//最后一个子节点
console.log(ulObj.lastChild);//------------------------IE8中是第一个子元素
//最后一个子元素
console.log(ulObj.lastElementChild);//-----------------IE8中不支持
//某个元素的前一个兄弟节点
console.log(threeObj.previousSibling);//------------------------IE8中是第一个子元素
//某个元素的前一个兄弟元素
console.log(threeObj.previousElementSibling);//-----------------IE8中不支持
//某个元素的后一个兄弟节点
console.log(threeObj.nextSibling);//------------------------IE8中是第一个子元素
//某个元素的后一个兄弟元素
console.log(threeObj.nextElementSibling);//-----------------IE8中不支持

总结:凡是获取节点的代码在谷歌和火狐得到的都是相关的节点
    凡是获取元素的代码在谷歌和火狐得到的都是相关的元素
    从子节点和兄弟节点开始,凡是获取节点的代码在IE8中得到的是元素,获取元素的相关代码,在IE8中
    得到的是undefined----元素的代码,iE中不支持
</code></pre><h3 id="兼容代码"><a href="#兼容代码" class="headerlink" title="兼容代码:"></a>兼容代码:</h3><pre><code>以获取第一个子级元素为例写兼容性代码,(其他的都一样):
function getFirstElementChild(element) {
    if(element.firstElementChild){//true---&gt;支持
        return element.firstElementChild;
    }else{
        var node=element.firstChild;//第一个节点
        while (node&amp;&amp;node.nodeType!=1){
            node=node.nextSibling;
        }
        return node;
    }
}
</code></pre><h2 id="三-为元素绑定事件写入兼容代码"><a href="#三-为元素绑定事件写入兼容代码" class="headerlink" title="三:为元素绑定事件写入兼容代码:"></a>三:为元素绑定事件写入兼容代码:</h2><pre><code>为元素绑定事件(DOM):一种,但是不兼容.
addEventListener和attachEvent的区别:
相同点:都可以为元素绑定事件
不同点:
    1.方法名不一样,
    2.参数个数不一样addEventListener三个参数,attachEvent两个参数
    3.谷歌和火狐支持,ie11支持,IE8不支持
        谷歌不支持,火狐不支持,ie11不支持,IE8支持
    4.this指向不同:
        addEventListener中的this是指向当前绑定事件对象,
        attachEvent中的this指向window
    5.addEventListener中事件的类型没有on,attachEvent中的事件类型有on
以onclick事件为例,如果我们需要在一个标签中注入多个点击事件,使用:多个
document.getElementById(&apos;id名&apos;).onclick=function(){}写的话会出现后注册的点击事件覆
盖先注册的点击事件,这个时候我们需要用addEventListener来为元素元素绑定多个事件,然而
addEventListener存在兼容性问题,再ie上需要attachEvent
addEventListener:
    参数1:事件的类型---事件的名字,没有on
    参数2:事件处理函数---函数(命名函数,匿名函数)
    参数3:布尔类型,目前就写false://addEventListener中第三个参数是控制事件阶段的
        document.getElementById(&apos;id名&apos;).addEventListener(&quot;click&quot;,function () {
            console.log(&quot;我是点击事件1&quot;);
        },false);
        document.getElementById(&apos;id名&apos;).addEventListener(&quot;click&quot;,function () {
            console.log(&quot;我是点击事件2&quot;);
        },false);
attachEvent:
    参数1:事件类型---事件名字，有on
    参数2:事件处理函数---函数(命名函数,匿名函数)
        document.getElementById(&apos;id名&apos;).attachEvent(&quot;onclick&quot;,function () {
            console.log(&quot;我是点击事件1&quot;);
        });
        document.getElementById(&apos;id名&apos;).attachEvent(&quot;onclick&quot;,function () {
            console.log(&quot;我是点击事件2&quot;);
        });
</code></pre><h3 id="绑定事件兼容代码"><a href="#绑定事件兼容代码" class="headerlink" title="绑定事件兼容代码:"></a>绑定事件兼容代码:</h3><pre><code>//为任意元素.绑定任意的事件, 参数:(任意的元素,事件的类型,事件处理函数)
 function addEventListener(element,type,fn) {
   //判断浏览器是否支持这个方法
   if(element.addEventListener){
     element.addEventListener(type,fn,false);
   }else if(element.attachEvent){
     element.attachEvent(&quot;on&quot;+type,fn);
   }else{
     element[&quot;on&quot;+type]=fn;
   }
 }
 addEventListener(document.getElementById(&apos;id名&apos;),&quot;click&quot;,function () {
   console.log(&quot;哦1&quot;);
 });
 addEventListener(document.getElementById(&apos;id名&apos;),&quot;click&quot;,function () {
   console.log(&quot;哦2&quot;);
 });
 addEventListener(document.getElementById(&apos;id名&apos;),&quot;click&quot;,function () {
   console.log(&quot;哦3&quot;);
 });
</code></pre><h2 id="四-为元素解绑事件写入兼容代码"><a href="#四-为元素解绑事件写入兼容代码" class="headerlink" title="四:为元素解绑事件写入兼容代码:"></a>四:为元素解绑事件写入兼容代码:</h2><pre><code>removeEventListener:谷歌和火狐支持,ie11支持,IE8不支持
detachEvent:谷歌不支持,火狐不支持,ie11不支持,IE8支持,
解绑事件方式:
注意:用什么方式绑定事件,就应该用对应的方式解绑事件
1.解绑事件
    对象.on事件名字=事件处理函数---&gt;绑定事件
    对象.on事件名字=null;
2.解绑事件(注意必须是命名函数,匿名函数会没办法解绑)
    对象.addEventListener(&quot;没有on的事件类型&quot;,命名函数,false);---绑定事件
    对象.removeEventListener(&quot;没有on的事件类型&quot;,函数名字,false);
3.解绑事件(注意必须是命名函数,匿名函数会没办法解绑)
    对象.attachEvent(&quot;on事件类型&quot;,命名函数);---绑定事件
    对象.detachEvent(&quot;on事件类型&quot;,函数名字);
</code></pre><h3 id="解绑事件兼容代码"><a href="#解绑事件兼容代码" class="headerlink" title="解绑事件兼容代码:"></a>解绑事件兼容代码:</h3><pre><code> //为任意元素解绑任意的事件, 参数:(任意的元素,事件的类型,命名函数)
 function removeEventListener(element,type,fnName){
     if(element.removeEventListener){
         element.removeEventListener(type,fnName,false);
     }else if(element.detachEvent){
         element.detachEvent(&apos;on&apos;+type,fnName);
     }else{
         element[&apos;on&apos;+type]=null;
     }
 }
removeEventListener(document.getElementById(&apos;id名&apos;),&apos;click&apos;,fnName);
function fnName(){
    console.log(&apos;我要被解绑了&apos;);
}
</code></pre><h2 id="五-事件冒泡-事件阶段-事件的完整流程及事件冒泡的兼容性代码"><a href="#五-事件冒泡-事件阶段-事件的完整流程及事件冒泡的兼容性代码" class="headerlink" title="五:事件冒泡,事件阶段,事件的完整流程及事件冒泡的兼容性代码:"></a>五:事件冒泡,事件阶段,事件的完整流程及事件冒泡的兼容性代码:</h2><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡:"></a>事件冒泡:</h3><pre><code>原理:多个元素嵌套,有层次关系,这些元素都注册了相同的事件,如果里面的元素的事件触发了,
外面的元素的该事件自动的触发了.
如何阻止事件冒泡:
    window.event.cancelBubble=true;IE特有的,谷歌支持,火狐不支持
    e.stopPropagation(); 谷歌和火狐支持,
    e.stopProgation()是火狐支持的,原理是正确的,e代表了处理事件,在处理事件上增加一个方法来禁用事件冒泡
    window.event.cancelBubble=true是ie支持的,因为:
        addEventListener中的this是指向当前绑定事件对象,(火狐)
        attachEvent中的this指向window(ie),
    ie的this指向的是window,所以使用了window.event,其实和火狐的e代表的是一样的,都是事件触发对象,
    不过火狐用的e(是对象).方法来阻止事件冒泡,ie用的是window.event(是对象).属性来阻止事件冒泡,所以
    兼容性代码的原理也是如此:
    function f1(e){
        //在火狐浏览器下,会用e对象,在ie浏览器下没有e会用window.event对象,这样就解决了兼容性问题
        var e=window.event||e;
    }
</code></pre><h3 id="事件阶段"><a href="#事件阶段" class="headerlink" title="事件阶段:"></a>事件阶段:</h3><pre><code> 事件有三个阶段:
1.事件捕获阶段  :从外向内
2.事件目标阶段  :最开始选择的那个
3.事件冒泡阶段  : 从里向外
</code></pre><h3 id="一个元素绑定事件的完整流程"><a href="#一个元素绑定事件的完整流程" class="headerlink" title="一个元素绑定事件的完整流程:"></a>一个元素绑定事件的完整流程:</h3><pre><code>* addEventListener(&quot;没有on的事件类型&quot;,事件处理函数,控制事件阶段的)
* 事件触发的过程中,可能会出现事件冒泡的效果,为了阻止事件冒泡---&gt;
* window.event.cancelBubble=true;谷歌,IE8支持,火狐不支持
* window.event就是一个对象,是IE中的标准
* e.stopPropagation();阻止事件冒泡----&gt;谷歌和火狐支持
* window.event和e都是事件参数对象,一个是IE的标准,一个是火狐的标准
* 事件参数e在IE8的浏览器中是不存在,此时用window.event来代替
* addEventListener中第三个参数是控制事件阶段的
* 事件的阶段有三个:
* 通过e.eventPhase这个属性可以知道当前的事件是什么阶段的
* 如果这个属性的值是:
* 1----&gt;捕获阶段
* 2----&gt;目标阶段
* 3----&gt;冒泡阶段
    捕获阶段和冒泡阶段只可能出现一个
例如:
   //同时注册点击事件
 var objs = [my$(&quot;dv3&quot;), my$(&quot;dv2&quot;), my$(&quot;dv1&quot;)];
 //遍历注册事件
 objs.forEach(function (ele) {
   //为每个元素绑定事件
   ele.addEventListener(&quot;click&quot;, function (e) {
     console.log(this.id+&quot;====&gt;&quot;+e.eventPhase);
   }, true);
 });
* 一般默认都是冒泡阶段,很少用捕获阶段
* 冒泡阶段:从里向外
* 捕获阶段:从外向内
</code></pre><h2 id="六-获取任意一个元素的任意一个样式属性的值"><a href="#六-获取任意一个元素的任意一个样式属性的值" class="headerlink" title="六:获取任意一个元素的任意一个样式属性的值"></a>六:获取任意一个元素的任意一个样式属性的值</h2><h3 id="存在的兼容问题"><a href="#存在的兼容问题" class="headerlink" title="存在的兼容问题:"></a>存在的兼容问题:</h3><pre><code>my$(&quot;btn&quot;).onclick=function () {
    //获取元素距离左边位置的值
    console.log(my$(&quot;dv&quot;).offsetLeft);
    //谷歌,火狐支持
    console.log(window.getComputedStyle(my$(&quot;dv&quot;),null).left);
    console.log(window.getComputedStyle(my$(&quot;dv&quot;),null)[&quot;left&quot;]);
    //IE8支持
    console.log(my$(&quot;dv&quot;).currentStyle.left);
};
</code></pre><h3 id="兼容代码-1"><a href="#兼容代码-1" class="headerlink" title="兼容代码:"></a>兼容代码:</h3><pre><code>代码1:
function getStyle(element,attr) {
    //判断浏览器是否支持这个方法
    if(window.getComputedStyle){
         return window.getComputedStyle(element,null)[attr];
    }else{
        return element.currentStyle[attr];
    }
}
简化版:
function getStyle(element,attr) {
    //判断浏览器是否支持这个方法
   return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr];
  }
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h3><pre><code>console.log(getStyle(my$(&quot;dv&quot;),&quot;top&quot;))//获取id为dv的元素的top值
</code></pre><h2 id="7-e-clientX-pageX-scrollLeft的兼容性总结"><a href="#7-e-clientX-pageX-scrollLeft的兼容性总结" class="headerlink" title="7:e,clientX,pageX,scrollLeft的兼容性总结"></a>7:e,clientX,pageX,scrollLeft的兼容性总结</h2><h3 id="1-window-event和事件参数对象e的兼容"><a href="#1-window-event和事件参数对象e的兼容" class="headerlink" title="1.window.event和事件参数对象e的兼容"></a>1.window.event和事件参数对象e的兼容</h3><pre><code>    ie不支持e值,只支持window.event;
兼容代码://window.event和事件参数对象e的兼容
        function getEvent(evt) {
          return window.event||evt;
        },
</code></pre><h3 id="2-clientX-clientY"><a href="#2-clientX-clientY" class="headerlink" title="2.clientX,clientY:"></a>2.clientX,clientY:</h3><pre><code>    主要需要兼容的是e和window.event,
兼容代码://可视区域的横坐标的兼容代码
        function getClientX(evt) {
          return getEvent(evt).clientX;
        },
</code></pre><h3 id="3-scrollLeft兼容性"><a href="#3-scrollLeft兼容性" class="headerlink" title="3.scrollLeft兼容性:"></a>3.scrollLeft兼容性:</h3><pre><code>    有的浏览器认为是document卷曲的距离(document.body.scrollLeft),
    有的浏览器认为是body卷曲的距离()document.documentElement.scrollLeft,
    有的浏览器认为是window.pageXOffset卷曲的距离
兼容代码://页面向左卷曲出去的横坐标
        function getScrollLeft() {
          return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0;
        },
</code></pre><h3 id="4-pageX和pageY在谷歌和火狐可以使用-IE8不能用"><a href="#4-pageX和pageY在谷歌和火狐可以使用-IE8不能用" class="headerlink" title="4.pageX和pageY在谷歌和火狐可以使用,IE8不能用;"></a>4.pageX和pageY在谷歌和火狐可以使用,IE8不能用;</h3><pre><code>    pageX和pageY在谷歌和火狐可以直接使用:
    在ie要这样使用:
        可视区域横坐(window.event.clientX+)+向左(上)卷曲出去的横坐标(getScrollLeft())
兼容代码:
    //相对于页面的横坐标(pageX或者是clientX+scrollLeft)
    getPageX:function (evt) {
      return this.getEvent(evt).pageX? this.getEvent(evt).pageX:this.getClientX(evt)+this.getScrollLeft();
    },
</code></pre><h3 id="把这四个方法放到一个对象中封装的代码"><a href="#把这四个方法放到一个对象中封装的代码" class="headerlink" title="把这四个方法放到一个对象中封装的代码:"></a>把这四个方法放到一个对象中封装的代码:</h3><pre><code>//把代码放在一个对象中
var evt={
    //window.event和事件参数对象e的兼容
    getEvent:function (evt) {
      return window.event||evt;
    },
    //可视区域的横坐标的兼容代码
    getClientX:function (evt) {
      return this.getEvent(evt).clientX;
    },
    //可视区域的纵坐标的兼容代码
    getClientY:function (evt) {
      return this.getEvent(evt).clientY;
    },
    //页面向左卷曲出去的横坐标
    getScrollLeft:function () {
      return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0;
    },
    //页面向上卷曲出去的纵坐标
    getScrollTop:function () {
      return window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0;
    },
    //相对于页面的横坐标(pageX或者是clientX+scrollLeft)
    getPageX:function (evt) {
      return this.getEvent(evt).pageX? this.getEvent(evt).pageX:this.getClientX(evt)+this.getScrollLeft();
    },
    //相对于页面的纵坐标(pageY或者是clientY+scrollTop)
    getPageY:function (evt) {
      return this.getEvent(evt).pageY?this.getEvent(evt).pageY:this.getClientY(evt)+this.getScrollTop();
    }
};
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/vue遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/vue遇到的问题/" itemprop="url">vue  M站开发总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-05T17:22:32+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-本次m站开发是m站一期和二期的开发-涉及的知识点有限-总结下开发流程"><a href="#一-本次m站开发是m站一期和二期的开发-涉及的知识点有限-总结下开发流程" class="headerlink" title="一:本次m站开发是m站一期和二期的开发,涉及的知识点有限,总结下开发流程"></a>一:本次m站开发是m站一期和二期的开发,涉及的知识点有限,总结下开发流程</h2><h3 id="1-首先是下载一个vue-cli脚手架工具作为底层架构-其次进行本地环境-测试环境-预发布环境-生产环境的配置-最后配置完成后即可进行开发"><a href="#1-首先是下载一个vue-cli脚手架工具作为底层架构-其次进行本地环境-测试环境-预发布环境-生产环境的配置-最后配置完成后即可进行开发" class="headerlink" title="1.首先是下载一个vue-cli脚手架工具作为底层架构,其次进行本地环境,测试环境,预发布环境,生产环境的配置,最后配置完成后即可进行开发"></a>1.首先是下载一个vue-cli脚手架工具作为底层架构,其次进行本地环境,测试环境,预发布环境,生产环境的配置,最后配置完成后即可进行开发</h3><h3 id="2-目录结构分析"><a href="#2-目录结构分析" class="headerlink" title="2.目录结构分析:"></a>2.目录结构分析:</h3><pre><code>利用vue-cli下载的模板文件夹目录层级如下:
</code></pre><p><img src="/2018/12/05/vue遇到的问题/mulujiegou.png" alt="Alt text"><br>     本次项目在原有目录基础上会根据需要增加结构:<br><img src="/2018/12/05/vue遇到的问题/xiangmujiegou1.jpg" alt="Alt text"><br><img src="/2018/12/05/vue遇到的问题/xiangmujiegou2.jpg" alt="Alt text"><br><img src="/2018/12/05/vue遇到的问题/xiangmujiegou3.jpg" alt="Alt text"></p>
<pre><code>build目录下:
    build.js:vue-cli自带的,当我们需要打包的时候可以在package.json中运行它,如:&quot;build&quot;: &quot;node build/build.js&quot;;
             build.js中写的有清空文件夹的代码等,这就是为什么运行npm run build 会删除dist再重新生成dist
    weback.base.conf.js:是各种环境公共的有关配置的代码,可以在该文件中写入公共的配置,然后再把该文件引入本地环境(webpack.dev.conf.js),
            生产环境(webpack.prod.conf.js)等环境的配置,vue-cli默认只有这两种环境的配置,你可根据自己需求增加其他环境文件如
            预发布环境(webpack.pre.conf.js)
    webpack.dev.conf.js(webpack.prod.conf.js):写入各自环境需要的配置,然后引入weback.base.conf.js文件,利用
            const merge = require(&apos;webpack-merge&apos;)合并weback.base.conf.js的配置到各自页面页面中,
config目录下:
    (默认生成的文件)
    dev.env.js:设置本地环境的NODE_ENV  NODE_ENV环境变量可以在package.json中设置,如:
         &quot;dev&quot;: &quot;cross-env NODE_ENV=dev  webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,
         NODE_ENV:设置环境变量,在config目录下的xxx.env.js中有定义
         cross-env:
            能跨平台地设置及使用环境变量大多数情况下，在windows平台下使用类似于: NODE_ENV=production的命令行指令会卡住，
            windows平台与POSIX在使用命令行时有许多区别（例如在POSIX，使用$ENV_VAR,在windows，使用%ENV_VAR%。。。）
    index.js:该文件放的是各个环境的输出目录,端口,域名,以何种方式打包等配置,会在webpack.xxx.conf.js中引入该文件
    prod.env.js:设置生产环境的NODE_ENV
    test.env.js:设置test环境的NODE_ENV
src目录下:
    (默认生成的目录及文件)
    common目录:存放公共的
    components目录:存放组件和vue页面,也可以为了操作,单独存组件如toast,popup等组件,把vue页面存在自己新建的view视图中
    router目录:存放路由设置 
    App.vue:页面级vue组件
    main.js:页面入口js文件 可以把main.js和app.vue单独放到新建的entry目录下,记得在webpack.base.conf.js中改下entry引入路径就行
    (可以根据需求加入store目录:)
    assets目录:
        存放公共的css,js.images等资源如:reset.css
    api目录:
        app.js:h5和app交互的方法,
        index.js:封装的接口方法,可以把所有的接口都写在里面,也可以把接口分类,然后引入到这个文件中
    store目录:此目录下存放的是vuex的配置文件
        index.js:可以把vuex的state(初始化的数据源),getters(对数据源进行操作如(过滤)),mutations(唯一的修改数据源的方法,同步)
                actions(操作mutations,异步)都写在此页面中,也可以为了管理单独把getters,mutations,actions单独建一个文件夹,然后
                在index.js引入
    view目录:
        根据需求可以把所有的vue页面存到这里,把公用的vue组件存到components中,看起来更语义化,视图和组件分开
    utils目录:
        根据自己需求存放文件:
        request.js:存放的封装的接口请求的方法,
        jsBridge.js:存放的是和h5和app交互的请求方法
        platFormType.js:存放的是app和h5交互判断是iso还是安卓
        utils.js:存放的是自己项目中封装的方法
        formValidata.js:存放的是数字,字符串转换的方法
在static目录下:
        可以存放网站的favicon.ico在改目录下
.babelrc:
     babel的配置
index.html:入口页面
package.json:
        项目启动,打包和安装的插件等;
</code></pre><h3 id="3-代码执行流程"><a href="#3-代码执行流程" class="headerlink" title="3.代码执行流程:"></a>3.代码执行流程:</h3><pre><code>1.在terminal中执行 npm run dev 会先起一个服务,然后把NODE_ENV=dev设置为dev环境,执行webpack.dev.conf.js文件中的内容,
2.在webpack.dev.conf.js中会引入config目录下的index.js和build目录下的webpack.base.conf.js文件,编译文件入口为entry目录
   下的index.js
3.在index.js文件中会引入vue,store,axios,app.vue页面,全局引入的插件(例如:vue-lazyload懒加载),路由文件等,然后实例化一个vue对象
    const app = new Vue({
        el: &apos;#app&apos;,
        router,
        store,
        render: h =&gt; h(App)
    });
    绑定app.vue中的id=&apos;app&apos;的dom,引入router,和store,有需要全局引入的组件也可以在这里引入,如toast,也可以拦截路由的请求如对
    404,500进行拦截等
</code></pre><h2 id="二-遇到的问题"><a href="#二-遇到的问题" class="headerlink" title="二:遇到的问题:"></a>二:遇到的问题:</h2><h3 id="1-input输入框type-”number”和type-”tel”在移动端都可以唤醒数字键盘-但是他们都还是可以输入小数点-并且"><a href="#1-input输入框type-”number”和type-”tel”在移动端都可以唤醒数字键盘-但是他们都还是可以输入小数点-并且" class="headerlink" title="1. input输入框type=”number”和type=”tel”在移动端都可以唤醒数字键盘,但是他们都还是可以输入小数点,+,-,并且,"></a>1. input输入框type=”number”和type=”tel”在移动端都可以唤醒数字键盘,但是他们都还是可以输入小数点,+,-,并且,</h3><pre><code>type=&quot;number&quot;输入的小数点在视图上可以看到,但是在控制台结果输出是没有的,这个时候如果用正则表达式截取小
数点以前的数字就会出现问题,无法获取到想要的数据,type=&quot;number&quot;输入的小数点在视图上可以看到,在控制
台结果也是有的,此时用正则表达式截取是完全ok的,
参考:https://blog.csdn.net/qq_22509715/article/details/78993912
</code></pre><h3 id="2-加密方式"><a href="#2-加密方式" class="headerlink" title="2. 加密方式:"></a>2. 加密方式:</h3><pre><code>参考:https://www.jianshu.com/p/3eaa7a527871
base64加密属于可逆性的加密，意思就是既可以加密，也可以解密。而MD5加密属于不可逆性的加密，只能够给我们提供加密的方
式，却没有解密的方式，一般情况多应用与登录注册界面。
在vue中安装:
    npm install --save js-base64
    npm install --save js-md5
引入和使用
    引入:
    import md5 from &apos;js-md5&apos;;
    let Base64 = require(&apos;js-base64&apos;).Base64;
    使用:
    Base64.encode(&apos;dankogai&apos;);  // ZGFua29nYWk=
    md5(&apos;中文&apos;); // a7bac2239fcdcb3a067903d8077c4a07
</code></pre><h3 id="3-图形验证码"><a href="#3-图形验证码" class="headerlink" title="3.图形验证码:"></a>3.图形验证码:</h3><pre><code>data表示取得数据的协定名称，image/png 是数据类型名称，base64 是数据的编码方法，逗号后面就是这个image/
png文件base64编码后的数据。
根据接口返回的base64的图片,在调接口的时候拿到这个base64图片字段,然后添加到html中,
注意:是base64格式的必须要加data:image/png;base64,+接口返回的字段,
如在vue中&lt;img :src=&quot;base64Image&quot;&gt; base64Image=data:image/png;base64,+接口返回的字段,
可参考:html img Src base64 图片显示(https://www.cnblogs.com/x-st/p/5220282.html)
</code></pre><h3 id="4-Vue-nextTick-的原理和用途"><a href="#4-Vue-nextTick-的原理和用途" class="headerlink" title="4.Vue.nextTick 的原理和用途"></a>4.Vue.nextTick 的原理和用途</h3><pre><code>详细参考:(https://segmentfault.com/a/1190000012861862)
用法:在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
疑问:
    1.DOM 更新循环是指什么？
    2.下次更新循环是什么时候？
    3.修改数据之后使用，是加快了数据更新进度吗？
    4.在什么情况下要用到？
异步说明:Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。
具体来说，异步执行的运行机制如下:
    （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
    （2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，
        就在&quot;任务队列&quot;之中放置一个事件。
    （3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。
        那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
    （4）主线程不断重复上面的第三步。
事件循环说明:
    简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，
    再统一进行视图更新。
例子:(点击获取元素宽度)
    &lt;div id=&quot;app&quot;&gt;
        &lt;p ref=&quot;myWidth&quot; v-if=&quot;showMe&quot;&gt;{{ message }}&lt;/p&gt;
        &lt;button @click=&quot;getMyWidth&quot;&gt;获取p元素宽度&lt;/button&gt;
    &lt;/div&gt;
        getMyWidth() {
            this.showMe = true;
            //this.message = this.$refs.myWidth.offsetWidth;
            //报错 TypeError: this.$refs.myWidth is undefined
            this.$nextTick(()=&gt;{
                //dom元素更新后执行，此时能拿到p元素的属性
                this.message = this.$refs.myWidth.offsetWidth;
          })
        }
</code></pre><h3 id="5-vuex中store存的数据"><a href="#5-vuex中store存的数据" class="headerlink" title="5.vuex中store存的数据:"></a>5.vuex中store存的数据:</h3><pre><code>把vuex注册在根组件下,它的属性可以在单页面中任何地方使用,比如在登录页把手机号和验证码保存在vuex中,
通过点击由去到别的页面,再回到登录页仍然可以通过vuex去到手机号和验证码,但是一刷新整个页面,属性值都
会变成初始化状态
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/17/html-css知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/17/html-css知识点/" itemprop="url">html+css相关知识点梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-17T13:29:34+08:00">
                2018-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="一-清除浮动的四种方法"><a href="#一-清除浮动的四种方法" class="headerlink" title="一:清除浮动的四种方法:"></a>一:清除浮动的四种方法:</h3><pre><code>清除浮动的本质是为了父元素因为子元素浮动导致父元素内部高度为0的问题
    &lt;div class=&quot;father&quot;&gt;
        &lt;div style=&quot;float:left;width:200px;height:200px;&quot;&gt;左浮动&lt;/div&gt;
        &lt;div style=&quot;float:left;width:200px;height:200px;&quot;&gt;左浮动&lt;/div&gt;
        &lt;div class=&quot;empty&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
1:在浮动标签最后添加一个空的标签设置属性:clear:both;
    .empty{clear:both;}
    优点:通俗易懂,书写方便
    缺点:添加许多无意义标签,结构比较差
2:父级添加overflow属性方法;
    给父级添加overflow方法如:overflow:hidden|auto|scroll 都可
    .father{overflow:hidden}(前提父元素没有设置高度,如果设置了高度是不用清除的)
    优点:
    缺点:内容增多时候容易造成不会自动换行导致内容被隐藏掉,无法显示需要溢出的元素
3:伪元素清除浮动:(父元素加)
    :after方式为空元素的升级版,好处是不用单独加标签了
    使用方法:(可以把下面代码写到reset.css中)
        .clearfix:after{content:&apos;&apos;;display:block;height:0px;clear:both;visibility:hidden;}
        .clearfix{*zoom:1;}/*IE6,7专有*/
    优点:符合闭合浮动的思想,结构语义化正确
    缺点:由于ie6,7不支持:after,需要使用zoom:1触发haslayout
4:使用before和after双伪元素清除浮动
    使用方法:
        .clearfix:before, .clearfix:after{
            content:&quot;&quot;;
            display:table;/*这句话可以触发BFC,BFC可以清除浮动*/
        }
        .clearfix:after{
            clear:both;
        }
        .clearfix{*zoom:1;}
        优点:代码更简洁
        缺点:由于IE6-7不支持:after,使用zoom:1触发haslayout
</code></pre><h3 id="二-有趣的边框显示demo"><a href="#二-有趣的边框显示demo" class="headerlink" title="二:有趣的边框显示demo:"></a>二:有趣的边框显示demo:</h3><pre><code>/*需求:一列表格,边框为1px,(相邻的边框也是1px),鼠标经过的时候显示#f04颜色的边框(四个边都是#f04)*/
css:
    div{
        width:250px;
        height:300px;
        border:1px solid #ccc;
        float:left;
        margin-left:-1px;/*处理相邻边框的border为1px,不加相邻边框border为2px*/
    }
    div:hover{
        border:1px solid #f04;
        position:relative;/*处理hover时候四个边框都是f04,相对定位的元素不会脱离文档流。但是如果div已经有了position:relative,这时候再hover的时候不需要再加相对定位秩序加一个z-index:1提升显示层级即可*/
    }
html:
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
效果:
</code></pre><p><img src="/2018/10/17/html-css知识点/border_demo.png" alt="Alt text"></p>
<h3 id="三-显示隐藏"><a href="#三-显示隐藏" class="headerlink" title="三:显示隐藏:"></a>三:显示隐藏:</h3><pre><code>display:隐藏后不再保留位置
visibility:hidden|visible 隐藏之后,继续保留原有位置(停薪留职)
opacity:为0之后,继续保留原有位置(停薪留职)
</code></pre><h3 id="四-图片在div中会有3px空白问题"><a href="#四-图片在div中会有3px空白问题" class="headerlink" title="四:图片在div中会有3px空白问题:"></a>四:图片在div中会有3px空白问题:</h3><pre><code>vertical-align:top|middle|baseline|bottom(针对行内块和行内元素,块元素无此属性)
对齐方式图解:
</code></pre><p><img src="/2018/10/17/html-css知识点/vertical_demo.png" alt="Alt text"><br>    3px示意图:<br><img src="/2018/10/17/html-css知识点/vertical_demo_3px.png" alt="Alt text"><br>    原因:图片是行内块状元素,是以基线为对齐方式,所以在div显示会空出基线到底线的距离,为3px;<br>    示例:</p>
<pre><code>css:
    div{
        border:1px solid red;
    }
    img {
        /*方法1:设置图片对齐方式为非vertical-align:baseline即可*/
        vertical-align: middle;
        /*display: block*/
        /*方法2:把img 转换块状元素display:block*/
    }
html:
    &lt;div&gt;
        &lt;img src=&quot;image.jpg&quot;&gt;hello yes
    &lt;/div&gt;
</code></pre><h3 id="五-精灵-雪碧-图的使用"><a href="#五-精灵-雪碧-图的使用" class="headerlink" title="五:精灵(雪碧)图的使用:"></a>五:精灵(雪碧)图的使用:</h3><pre><code>1.为什么要使用精灵图:
    为了有效减少服务器接收和发送请求的的次数,提高页面的加载速度.
2.精灵图技术的本质:
    css精灵图是一种处理网页背景图像的方式,把一个页面设计到的所有零星的背景图像都集中到一个大图中,
    然后将大图应用于网页,这样,当用户访问页面时,只需向服务器发送一次请求,网页中的背景图像即可全部展示
    出来.
注意:小公司,背景图片很少的情况,没有必要使用精灵技术,维护成本太高(修改费劲).
使用:在需要使用背景图的地方写css(利用background-position定位)
    x:需要的背景图片在精灵图中的x轴的位置
    y:需要的背景图片在精灵图中的y轴的位置
    background:url(&apos;xxx.jpg|png&apos;) no-repeat x y;
</code></pre><h3 id="六-滑动门原理"><a href="#六-滑动门原理" class="headerlink" title="六:滑动门原理:"></a>六:滑动门原理:</h3><p>背景图片:<br><img src="/2018/10/17/html-css知识点/slideDoor.png" alt="Alt text"><br>完成效果图:<br><img src="/2018/10/17/html-css知识点/sliderdoor_demo.png" alt="Alt text"><br>    需求:在导航栏中,字体背景图(左右两边分别有一个闭合的标识)显示根据字体多少显示的时候,此时没法单纯的<br>    设置一个固定大小的背景图,只能使用滑动门的效果让背景图根据字体多少显示。<br>    1.原理：在a标签中设置背景图左标识显示的内容,在a标签中嵌套一个span标签,在span标签中显示背景图右侧的<br>    标识,不给a标签,span标签设置宽度,让他们根据字体大小撑开宽度<br>    使用:</p>
<pre><code>css:
    a{
        margin-left:30px;
        height:30px;
        display: inline-block;
        background:url(slideDoor.png) no-repeat;/*设置左侧标识背景图*/
        color:#fff;
        line-height: 30px;
        font-size:16px;
        padding-left:15px;
    }
    span{
        display: inline-block;
        height:30px;
        padding-right:15px;
        background: url(slideDoor.png) no-repeat right;/*设置右侧标识和其他部分背景图*/
    }
html:
    &lt;a&gt;
        &lt;span&gt;首页&lt;/span&gt;
    &lt;/a&gt;
    &lt;a&gt;
        &lt;span&gt;首页啊啊啊啊&lt;/span&gt;
    &lt;/a&gt;
写完之后,当在span中输入不同数量的内容时,背景图一般也能完整的显示出来(除非宽度大于了背景图的长度),
备注:结果图看起来有点错位是因为背景图是截屏截取的,不够准确
</code></pre><h3 id="七-字体图标的使用"><a href="#七-字体图标的使用" class="headerlink" title="七:字体图标的使用"></a>七:字体图标的使用</h3><pre><code>图片是有诸多有点的,但是缺点也很明显,比如图片不但增加了总文件的大小,还增加了很多额外的&quot;http请求&quot;,这都会大大降低网页
的性能,更重要的是图片不能很好的进行缩放,图片缩放会导致失真,然而,字体图标作为矢量图却是可以,改变颜色,自由缩放且不失真的
字体图标的优点:
    可以做出跟图片一样可以做的事情,改变透明度,旋转等
    但是本质是文字,可以随意改变颜色,阴影,透明效果等..(因为是字体,改变大小用font-size)
    本身体积更小,但携带的信息并没有削减
    几乎支持所有的浏览器
    移动端设备必备良药
字体图标使用流程图:
</code></pre><p><img src="/2018/10/17/html-css知识点/icon_demo.png" alt="Alt text"><br>    使用方法:<br>    1.如果设计给了svg,需要将svg图片转成文字图标样式。<br>        1.打开<a href="https://icomoon.io" target="_blank" rel="noopener">https://icomoon.io</a> 点击右上角iconMoon App<br>        2.进入新的页面后点击左上角import icons把svg图片导入进入生成icon图标<br>        3.选中图标,点击右下角generate font查看每个图标对应的class<br>        4.点击右下角download下载生成的内容载解压缩,找到style.css,存储的即为所需字体图标class样式<br>        5.在需要的地方 <i class="xxx"></i>即可<br>    2.如何实际没有个svg图,需要自己找。<br>        在第2步自己找到需要的图标继续操作即可<br>    注意:下载的sell-icon里共有如下文件夹:<br><img src="/2018/10/17/html-css知识点/sell-icon.png" alt="Alt text"><br>    fonts:存放的是四种字体的不同格式,(如果想在页面使用,需在合适的路径引入这个文件的内容)<br>    demo.html:存放的是下载的所以字体图标的对应编号(可以选择赋值空格来引入图标,也可以选择引入class来引入图标(style.css里有使用示例))<br>    selection.json:存放的是本次下载的图标所以的集合,在增加新图标的时候,可以导入这个文件获取以前的图标,然后在此基础上增加新图标<br>    style.css:存放的是引入fonts的路径和给每个图标写一个class类,可以直接引入html使用其中的class</p>
<h3 id="八-初始化css样式文件"><a href="#八-初始化css样式文件" class="headerlink" title="八:初始化css样式文件:"></a>八:初始化css样式文件:</h3><pre><code>normalize.css和reset.css(可以去github上搜索并下载即可)
    Normalize.css只是一个很小的css文件，但它在磨人的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS 
reset,Normalize.css是一种现代的、为HTML5准备的优质替代方案。总之，Normalize.css是一种CSS reset的替代方案。
normalize与CSS Reset的区别:
    1:保留有用的浏览器默认值，而不是删除它们。
    2:规范化各种HTML元素的样式。
    3:纠正错误和常见的浏览器不一致
    4:通过微妙的改进提高可用性。
    5:用注释和详细的文档来。
注意：Normalize支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表哥都进行了一般化。
尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。
</code></pre><h3 id="九-三大标签的优化-SEO优化"><a href="#九-三大标签的优化-SEO优化" class="headerlink" title="九:三大标签的优化(SEO优化):"></a>九:三大标签的优化(SEO优化):</h3><pre><code>1.title标签:
    网页标题title:title具有不可替代性,是我们的内页第一个重要的标签,是搜索引擎了解网页的入口,搜索引擎就很大部分是依靠网站title来判断你网站是关于什么内容的
    如京东:
    &lt;title&gt;京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！&lt;/title&gt;
2.meta标签的 description:
    description功能让搜索引擎是判断整个页面内容的，当中要写入的内容是你页面内容的简介。description一般不超过100个字符。
    如京东:
    &lt;meta name=&quot;description&quot; content=&quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、
    服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot;&gt;
3.meta标签的 Keyword关键字:
    Keywords是页面关键字,是搜索引擎关注点之一。Keywords应该限制在6~8个关键字左右
    如京东:
    &lt;meta name=&quot;Keywords&quot; content=&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东&quot;&gt;
</code></pre><h3 id="十-伪元素after和before用法"><a href="#十-伪元素after和before用法" class="headerlink" title="十:伪元素after和before用法:"></a>十:伪元素after和before用法:</h3><pre><code>css:
    div::before{
        content:&quot;我是before添加的内容&quot;;/*这个是必须要有的一个属性,以下的可有可无*/
        display:block;/*通过伪元素添加的盒子是个行内盒子,可以转成块状盒子*/
        width:50px;
        height:50px;
    }
    通过before和after添加的盒子在div内部,并且div::before也可以写成div:before,如果要利用after清除浮动可以把高度设置为0
html:
    &lt;div&gt;before和after的用法&lt;/div&gt;
</code></pre><h3 id="十一-转换网页title栏的ico图标"><a href="#十一-转换网页title栏的ico图标" class="headerlink" title="十一:转换网页title栏的ico图标:"></a>十一:转换网页title栏的ico图标:</h3><pre><code>1.先切图,尽量是透明图片png格式
2.把图片转换为图标 http://www.bitbug.net/(在这个网站上转图片)
3.当成功生成favicon.ico图像文件后,浏览器会自动弹出一个zip的压缩文件将压缩文件中的favicon.ico图像
放在根目录下(也可以是其他目录)在页面源文件的&lt;head&gt;&lt;/head&gt;标签之间插入
&lt;link rel=&quot;shortcut icon&quot; href=&quot; /favicon.ico&quot; /&gt; 
</code></pre><h3 id="十二-css3的flex布局-弹性布局"><a href="#十二-css3的flex布局-弹性布局" class="headerlink" title="十二:css3的flex布局(弹性布局)"></a>十二:css3的flex布局(弹性布局)</h3><pre><code>使用flex布局需要考虑到兼容性问题,pc端兼容性不好,移动端兼容性很好,在移动端使用较多,
1.通常使用flex布局来实现均分一行或者一列的元素,缩放时也保持对应比例
    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;1&lt;/div&gt;
        &lt;div&gt;2&lt;/div&gt;
        &lt;div&gt;3&lt;/div&gt;
    &lt;/div
    .father{
        display:flex;/*规定.father元素使用felx布局*/
    }
    .father div{
        flex:1;/*在一行内显示并且均分*/
    }
2.也可以固定.son的宽度,其他的div按着felx布局显示
    .son{width:200px}
3.flex布局默认水平分布,也改更改为垂直分布:
    flex-direction:column;/*水平分布*/
    flex-direction:row;/*垂直分布*/
4.其他使用可以参考官方文档即可
</code></pre><h3 id="十三-background-size背景缩放-css3"><a href="#十三-background-size背景缩放-css3" class="headerlink" title="十三:background-size背景缩放(css3)"></a>十三:background-size背景缩放(css3)</h3><pre><code>1.background-size:80px 100px;/*背景图宽高分别为80px 100px*/
2.background-size:80px/*背景图宽为80px,高auto(自动根据比例缩放)*/
3.background-size:cover;/*按背景图比例缩放,以最小的宽或者高为基准,直到最小的那个铺满div才停止缩放,div一定被背景图铺满*/
4.background-size:contain/*按背景图比例缩放,以最大的宽或者高为基准,直到最大的那个铺满div才停止缩放,div不一定被背景图铺满*/
注意:
    如果在开发中遇到了精灵图是实际需要的图的2倍的时候(ios,安卓差异),可以利用background-size:104px;
把背景图宽高设置成精灵图的一半,然后用background:url(images/xxx.png) no-repeat x y;/*x(y)缩小后
需要使用图片的x(y)轴上的位置)*/
例如:原精灵图宽208px高自动,我们需要宽104px的精灵图
    background:url(images/xxx.png) no-repeat x y;
    background-size:104px;
</code></pre><h3 id="十四-多背景-css3"><a href="#十四-多背景-css3" class="headerlink" title="十四:多背景(css3)"></a>十四:多背景(css3)</h3><pre><code>div{
    background:url(images/xxx.png) no-repeat , url(images/xxx.png) no-repeat;
}
以逗号分隔可以设置多背景,可用于自适应布局。
注意:如果div本身还有背景色,此时应该在下面继续写background:blue;不能把这个颜色写在url那行,因为会重叠覆盖
例子:
    background: url(images/paopao.png)  no-repeat top left, url(images/paopao.png) no-repeat right bottom;
    background-color: blue;  /*多背景颜色写到下面 防止被叠加*/
</code></pre><h3 id="十五-浏览器前缀"><a href="#十五-浏览器前缀" class="headerlink" title="十五:浏览器前缀"></a>十五:浏览器前缀</h3><pre><code>浏览器前缀                浏览器
-webkit-                 google Chrome,safari,Android Browser
-moz-                    Firfox
-o-                        Opera
-ms-                    Internet Explorer,Edge
-khtml-                    Konqueror
</code></pre><h3 id="十六-盒子半透明"><a href="#十六-盒子半透明" class="headerlink" title="十六:盒子半透明"></a>十六:盒子半透明</h3><pre><code>在没有css3的background:rgba(255,255,255,0.5)的时候,盒子半透明是使用opacity:0.5,但是这样使用会把盒子内的
文字也半透明,以前的处理方法是在div中嵌套一个div和一个p标签,把div中的div大小设置和外层div一样大,设置
opacity:0.5,把p标签定位到内层div上,这样就可以实现div半透明,而里面的字不是半透明的效果,在有css3的情况下我们
可以直接background:rgba(255,255,255,0.5);即可
html结构:&lt;div&gt;
            &lt;div&gt;&lt;/div&gt;
            &lt;p&gt;hello&lt;/p&gt;
        &lt;/div&gt;
</code></pre><h3 id="十七-css盒子模型"><a href="#十七-css盒子模型" class="headerlink" title="十七:css盒子模型:"></a>十七:css盒子模型:</h3><pre><code>CSS盒子模型：网页设计中CSS技术所使用的一种思维模型。
CSS盒子模型组成：外边距（margin）、边框（border）、内边距（padding）、内容（content）。
CSS盒子模型分为：标准W3C盒子模型，IE盒子模型，注意在两种模型中宽（width）和高（height）包括属性的不同。
</code></pre><h4 id="W3C模型中："><a href="#W3C模型中：" class="headerlink" title="W3C模型中："></a>W3C模型中：</h4><pre><code>W3C模型中content的宽度和高度就是content的宽和高
　　CSS中的宽（width）=内容（content）的宽
CSS中的高（height）=内容（content）的高
</code></pre><h4 id="IE模型中："><a href="#IE模型中：" class="headerlink" title="IE模型中："></a>IE模型中：</h4><pre><code>        IE盒模型中content的宽度和高度包括了border和padding。
 　   CSS中的宽（width）=内容（content）的宽+（border+padding）*2
        CSS中的高（height）=内容（content）的高+（border+padding）*2

margin（外边界）虽不可见，但是它确实在文档中占据了空间，我们要区分两个概念即：盒子所占空间（计入margin ）
和盒子实际的大小（不计入margin） 。
</code></pre><h4 id="实例区分两种盒模型"><a href="#实例区分两种盒模型" class="headerlink" title="实例区分两种盒模型:"></a>实例区分两种盒模型:</h4><pre><code>        下面举个例子来区分两种盒模型：
            一个盒子的 margin 为 20px，border 为 2px，padding 为 10px，content 的宽为 200px、高为 50px。
        ie盒子模型:
            盒子所占空间：width=20ｘ2+200=240      　　          height=20ｘ2+50=90
            盒子实际大小：width=200        　　　　　　　            height=50
        标准w3c盒子模型:
            盒子所占空间：width=20ｘ2+2ｘ2+10ｘ2+200=264  　  height=20ｘ2+２ｘ2+10ｘ2 +50=114
            盒子实际大小：width=200 +2ｘ2+10ｘ2 =224  　　　    height=50+2ｘ2+10ｘ2=74
box-sizing和两种盒模型:
        box-sizing有三个取值：
                1、content-box:使元素遵循标准 w3c 盒子模型（默认值）。(width+padding+border)
                2、border-box:使元素遵循ie 盒子模型。(width)
                3、 inherit： 规定应从父元素继承 box-sizing 属性的值
        当我们设置box-sizing:content-box时候,如果设置div宽为200px,在设置border,padding等,实际宽度会是200+(border+padding)*2;
        当我们设置box-sizing:border-box时候,如果设置div宽度为200px,在设置border,padding等,实际宽度会是就是200,只不过内容空间
        变成了减去(padding+border)*2,
现在还在用IE6以下的浏览器的用户已经很少了，所以目前浏览器大部分元素都是基于W3C标准盒子模型 上。所以我们平常说的盒子模型
一般就是标准w3c 盒子模型 （但对于input、button元素默认border-box ，还是基于传统的ie 盒子模型）。一定有人会问，那我们怎样
让我们的元素都遵循W3C标准盒子模型呢？哈哈，看看你html的文件头部是不是有一个&lt;!DOCTYPE html&gt; ，有这个，就说明你已经遵
循W3C标准盒子模型了。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/12/web存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/web存储/" itemprop="url">cookies、sessionStorage和localStorage解释及区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-12T10:13:52+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-HTML4的本地存储-cookie"><a href="#一-HTML4的本地存储-cookie" class="headerlink" title="一.HTML4的本地存储 (cookie)"></a>一.HTML4的本地存储 (cookie)</h2><h3 id="浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie-session等跟服务端进行数据交互"><a href="#浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie-session等跟服务端进行数据交互" class="headerlink" title="浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie,session等跟服务端进行数据交互"></a>浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie,session等跟服务端进行数据交互</h3><h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><pre><code>cookie和session都是用来跟踪浏览器用户身份的会话方式。
</code></pre><h3 id="cookie和session区别："><a href="#cookie和session区别：" class="headerlink" title="cookie和session区别："></a>cookie和session区别：</h3><pre><code>1、保持状态：cookie保存在浏览器端，session保存在服务器端
2、使用方式：
    (1）cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，
    这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，
    cookie数据仍然存在，直到过期时间结束才消失
    Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它
    (2）session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。
    如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建
    新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，
    在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过
    response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；
    当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。
3、存储内容：
    cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的
    对象(session中可含有多个对象)
4、存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制
5、安全性：
    cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。
    原因如下：
        （1）sessionID存储在cookie中，若要攻破session首先要攻破cookie；
        （2）sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；
        （3）第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。
        （4）sessionID是加密的
        （5）综上所述，攻击者必须在短时间内攻破加密的sessionID，这很难。
6、应用场景：
    cookie：
        （1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，
        则每次登录必须从新填写登录的相关信息。
        （2）保存上次登录的时间等信息。
        （3）保存上次查看的页面
        （4）浏览计数
</code></pre><p><img src="/2018/10/12/web存储/cookie.png" alt="Alt text"><br>        session：<br>            Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。<br>            （1）网上商城中的购物车<br>            （2）保存用户登录信息<br>            （3）将某些数据放入session中，供同一用户的不同页面使用<br>            （4）防止用户非法登录<br>     7、缺点：<br>         cookie：<br>             （1）大小受限<br>             （2）用户可以操作（禁用）cookie，使功能受限<br>             （3）安全性较低<br>             （4）有些状态不可能保存在客户端。<br>             （5）每次访问都要传送cookie给服务器，浪费带宽。<br>             （6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。<br>         session：<br>             （1）Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大<br>             （2）依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全<br>            （3）创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量<br>            将会导致代码不可读而且不好维护</p>
<h2 id="HTML5的本地存储web-Storage-localStroage-sessionStorage"><a href="#HTML5的本地存储web-Storage-localStroage-sessionStorage" class="headerlink" title="HTML5的本地存储web Storage(localStroage,sessionStorage)"></a>HTML5的本地存储web Storage(localStroage,sessionStorage)</h2><h3 id="解释一"><a href="#解释一" class="headerlink" title="解释一:"></a>解释一:</h3><h4 id="HTML5中与本地存储相关的两个重要内容："><a href="#HTML5中与本地存储相关的两个重要内容：" class="headerlink" title="HTML5中与本地存储相关的两个重要内容："></a>HTML5中与本地存储相关的两个重要内容：</h4><pre><code>    Web Storage与本地数据库。其中，Web Storage存储机制是对HTML4中cookie存储机制的一个改善。
由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的WebStorage存储机制。本地
数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器
端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访
问数据的速度。
</code></pre><h4 id="本文主要来讲解Web-Storage"><a href="#本文主要来讲解Web-Storage" class="headerlink" title="本文主要来讲解Web Storage:"></a>本文主要来讲解Web Storage:</h4><pre><code>我们知道，在HTML4中可以使用cookie在客户端保存诸如用户名等简单的用户信息，但是，通过长期的使用，
你会发现，用cookie存储永久数据存在以下几个问题:
1.大小：cookie的大小被限制在4KB。
2.带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。
3.复杂性：要正确的操纵cookie是很困难的。
针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是Web Storage。
具体来说，Web Storage又分为两种：
1.sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到
浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内
所要求保存的任何数据。
2.localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被
关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。
这两者的区别在于，sessionStorage为临时保存，而localStorage为永久保存。
到目前为止，Firefox3.6以上、Chrome6以上、Safari 5以上、Pera10.50以上、IE8以上版本的浏览器支持sessionStorage与localStorage的使用。
</code></pre><h3 id="解释二"><a href="#解释二" class="headerlink" title="解释二:"></a>解释二:</h3><pre><code>WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。
</code></pre><h4 id="WebStorage两个主要目标："><a href="#WebStorage两个主要目标：" class="headerlink" title="WebStorage两个主要目标："></a>WebStorage两个主要目标：</h4><pre><code>（1）提供一种在cookie之外存储会话数据的路径。
（2）提供一种存储大量可以跨会话存在的数据的机制。
</code></pre><h4 id="HTML5的WebStorage提供了两种API："><a href="#HTML5的WebStorage提供了两种API：" class="headerlink" title="HTML5的WebStorage提供了两种API："></a>HTML5的WebStorage提供了两种API：</h4><pre><code>localStorage（本地存储）和sessionStorage（会话存储）。
1、生命周期：
    localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。
    localStorage除非主动删除数据，否则数据永远不会消失。

    sessionStorage:sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”
    的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入
    同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口
    同一个页面，sessionStorage也是不一样的
2、存储大小：
    localStorage和sessionStorage的存储数据大小一般都是：5MB
3、存储位置：
    localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。
4、存储内容类型：
    localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理
5、获取方式：
    localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。
6、应用场景：
    localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；
</code></pre><h4 id="WebStorage的优点："><a href="#WebStorage的优点：" class="headerlink" title="WebStorage的优点："></a>WebStorage的优点：</h4><pre><code>（1）存储空间更大：cookie为4KB，而WebStorage是5MB；
（2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，
    所以减少了客户端和服务器端的交互，节省了网络流量；
（3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；
（4）快速显示：
    有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；
（5）安全性：
        WebStorage不会随着HTTPheader发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；
（6）WebStorage提供了一些方法，数据操作比cookie方便；
        setItem (key, value) ——  保存数据，以键值对的方式储存信息。
        getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。
        removeItem (key) ——  删除单个数据，根据键值移除对应的信息。
        clear () ——  删除所有的数据
        key (index) —— 获取某个索引的key
</code></pre><h2 id="cookie-、sessionStorage与localStorage的区别"><a href="#cookie-、sessionStorage与localStorage的区别" class="headerlink" title="cookie 、sessionStorage与localStorage的区别"></a>cookie 、sessionStorage与localStorage的区别</h2><p><img src="/2018/10/12/web存储/difference.png" alt="Alt text"></p>
<h3 id="cookie使用示例"><a href="#cookie使用示例" class="headerlink" title="cookie使用示例:"></a>cookie使用示例:</h3><pre><code>存储,获取,删除: 
1.存储cookie值:
    function setCookie(key,value,time){
        var oDate = new Date();//获取系统时间
        oDate.setDate(oDate.getDate()+time);//根据来访着的时间来设置过期时间time单位是天
        document.cookie = key+&apos;=&apos;+value+&apos;;expires= &apos;+oDate.toGMTString();
    }
    setCookie(&apos;sex&apos;,&apos;男&apos;,5);
2.获取存储的cookie值:
    方法1:
    function getCookie(c_name) {
        var that = this;　　　　
        if (document.cookie.length &gt; 0) {
            //检查这个cookie是否存在，不存在就为 -1
            c_start = document.cookie.indexOf(c_name + &quot;=&quot;)
            if (c_start != -1) {
                //获取cookie值的开始位置
                c_start = c_start + c_name.length + 1;
                //通过&quot;;&quot;号是否存在来判断结束位置
                c_end = document.cookie.indexOf(&quot;;&quot;, c_start);
                if (c_end == -1){
                    c_end = document.cookie.length;
                }
                //通过substring()得到了值
                return unescape(document.cookie.substring(c_start, c_end))　　 
            }　　　　
        }　　　　
        return &quot;&quot;　　
    }
    方法2:
    function getCookie(key){  
        var arr1 = document.cookie.split(&apos;;&apos;);  
        for(var i=0; i&lt;arr1.length; i++){
            var arr2 = arr1[i].split(&apos;=&apos;);
            &lt;!-- if(arr2[0]==key){
                return decodeURI(arr2[1]);
            } --&gt;
            /*浏览器截取cookie会给key加一个空格,需要去除*/
            if(arr2[0].trim()==key){
                return decodeURI(arr2[1]);
            }
        }
    }
    alert(getCookie(&apos;sex&apos;));
3.如何删除cookie:
    function  removeCookie(key){
            setCookie(key,&apos;&apos;,-1);
        }
        removeCookie(&apos;sex&apos;);
</code></pre><h3 id="sessionStorage与localStorage的使用示例。"><a href="#sessionStorage与localStorage的使用示例。" class="headerlink" title="sessionStorage与localStorage的使用示例。"></a>sessionStorage与localStorage的使用示例。</h3><pre><code>下面具体看一下读写数据时使用的基本方法
</code></pre><h4 id="1-sessionStorage"><a href="#1-sessionStorage" class="headerlink" title="(1)sessionStorage:"></a>(1)sessionStorage:</h4><pre><code>保存数据的方法：
    sessionStorage.setItem(&quot;key&quot;,&quot;value&quot;);
    //或者写成
    sessionStorage.key=&quot;value&quot;;
读取数据的方法：
    变量=sessionStorage.getItem(&quot;key&quot;);
    //或者写成
    变量=sessionStorage.key;
</code></pre><h4 id="2-localStorage"><a href="#2-localStorage" class="headerlink" title="(2)localStorage:"></a>(2)localStorage:</h4><pre><code>    保存数据的方法：
        localStorage.setItem(&quot;key&quot;,&quot;value&quot;);
        //或者写成
        localStorage.key=&quot;value&quot;;
    读取数据的方法：
        变量=localStorage.getItem(&quot;key&quot;);
        //或者写成
        变量=localStorage.key;
    在保存数据时，若使用sessionStorage读取或保存数据，则使用sessionStorage对象并调用该对象的读写方法；
    若使用localStorage读取或保存数据，则使用localStorage对象并调用该对象的读写方法。

    在进行读写时，不管是哪个对象，都可以通过该对象的getItem方法来读取数据，也可以该对象的自定义属性值读取数据；
    可以通过该对象的setItem方法保存数据，也可以通过该对象的自定义属性值保存数据。保存数据时按“键名/键值”的形式
    进行保存。当通过该对象的getItem方法读取数据时，将参数指定为键名，该方法返回键值；当通过该对象的自定义属性值
    读取数据时，可以将该对象的某个自定义属性名作为键名，访问该自定义属性的属性值即可得到键值；当通过该对象的
    setItem方法保存数据时，将第一个参数指定为键名，将第二个参数指定为键值；当通过该对象的自定义属性值保存数据时，
    可以将该对象的某个自定义属性名作为键名，然后直接将该自定义属性值设置为键值。

    在保存数据时不允许重复保存相同的键名。保存后可以修改键值，但不允许修改键名(只能重新取键名，然后再保存键值)。


首先，准备一个用来保存数据和显示数据的网页
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Web Storage 示例&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;h1&gt;Web Storage 示例&lt;/h1&gt;
    &lt;p id=&quot;msg&quot;&gt;&lt;/p&gt;
    &lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;保存数据&quot; onclick=&quot;saveStorage(&apos;input&apos;);&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;读取数据&quot; onclick=&quot;loadStorage(&apos;msg&apos;);&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;删除数据&quot; onclick=&quot;removeStorage(&apos;msg&apos;);&quot; /&gt;
    &lt;/body&gt;
&lt;/html&gt;
单击&quot;保存数据&quot;按钮时调用saveStorage方法保存数据，单击&quot;读取数据&quot;按钮时调用loadStorage方法调用数据，
这两个方法均在脚本文件script.js中，如下：
//sessionStorage 示例  (保存一个会话周期:从打开浏览器——到关闭浏览器窗口)
function saveStorage(id){
    var target=document.getElementById(id);
    var str=target.value;
    sessionStorage.setItem(&quot;message&quot;,str);
    //或者sessionStorage.message=str;
}
function loadStorage(id){
    var target=document.getElementById(id);
    var msg=sessionStorage.getItem(&quot;message&quot;);
    //或者var msg=sessionStorage.message;
    target.innerHTML=msg;
}
function removeStorage(id){
    var target=document.getElementById(&quot;msg&quot;);
    var msg=sessionStorage.removeItem (&quot;message&quot;);
    //或者var msg=localStorage.message;
    target.innerHTML=&quot;&quot;;
}
//localStorage 示例(可永久保存)    
function saveStorage(id){
    var target=document.getElementById(id);
    var str=target.value;
    localStorage.setItem(&quot;message&quot;,str);
    //或者localStorage.message=str;
}
function loadStorage(id){
    var target=document.getElementById(&quot;msg&quot;);
    var msg=localStorage.getItem(&quot;message&quot;);
    //或者var msg=localStorage.message;
    target.innerHTML=msg;
}
function removeStorage(id){
    var target=document.getElementById(&quot;msg&quot;);
    var msg=localStorage.removeItem (&quot;message&quot;);
    //或者var msg=localStorage.message;
    target.innerHTML=&quot;&quot;;
}
这个脚本文件分别使用了sessionStorage与localStorage两种方法。这两种方法都是当用户在input文本框中
输入内容后单击&quot;保存数据&quot;按钮保存数据，单击&quot;读取数据&quot;按钮读取保存后的数据。但是两种方法对数据的处理
方式不一样，在使用sessionStorage方法时，如果关闭了浏览器，这个数据就丢失了，下一次打开浏览器单击
&quot;读取数据&quot;按钮时，读取不到任何数据。在使用localStorage方法时，即使浏览器关闭了，下次打开浏览器时
仍然能够读取保存的数据。不过，数据保存是按不同的浏览器分别进行保存的，也就是说，打开别的浏览器是读
取不到在这个浏览器中保存的数据的。
</code></pre><h4 id="来源"><a href="#来源" class="headerlink" title="来源:"></a>来源:</h4><p><a href="https://www.cnblogs.com/pengc/p/8714475.html" target="_blank" rel="noopener">cookies、sessionStorage和localStorage解释及区别</a><br>参考:<br><a href="https://happyjeannie.github.io/2018/06/27/Session%E3%80%81LocalStorage%E3%80%81Cache-Control/" target="_blank" rel="noopener">Session、LocalStorage、Cache-Control</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/10/Object-assign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/10/Object-assign/" itemprop="url">es6语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-10T22:38:59+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign():"></a>Object.assign():</h1><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法:"></a>1.语法:</h2><pre><code>Object.assign(target, ...sources)
参数:target(目标对象),sources(源对象,源对象可以有多个) 返回值:目标对象
</code></pre><h2 id="2-描述"><a href="#2-描述" class="headerlink" title="2.描述:"></a>2.描述:</h2><pre><code>如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后来的源对象的属性将类似地覆盖早先的属性。

    Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，
所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合
将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 
String类型和 Symbol 类型的属性都会被拷贝。
在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。
注意，Object.assign 不会跳过那些值为 null 或 undefined 的源对象。
</code></pre><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例:"></a>3.示例:</h2><pre><code>1.复制一个对象:
    var obj = { a: 1 };
    var copy = Object.assign({}, obj);
    console.log(copy); // { a: 1 }
2.深拷贝问题:(如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这
    是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。)
    针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。
    function test() {
      //把obj1的属性拷贝到obj2空对象中
      let obj1 = { a: 0 , b: { c: 0}};
      let obj2 = Object.assign({}, obj1);
      console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}

      //修改obj1中的a属性,obj2中的a属性值不会变,因为拷贝的属性值不是一个指向对象的引用,而是一个确定的值
      obj1.a = 1;
      console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}
      console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}

      //同理,修改obj2中的a属性的值,obj1中的a的属性值也不会变
      obj2.a = 2;
      console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}
      console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}

      //修改obj2.b.c的值,obj1.b.c的值也变了,因为obj2拷贝的是obj1.b的对象的引用地址,引用的地址是一样,改变地址内c的值,b指向的值也改变,这是浅拷贝
      obj2.b.c = 3;
      console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}}
      console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}}

      // Deep Clone深拷贝 把obj1的所有属性先转成字符串格式,然后在转成json数组赋值给obj3,此时obj3.b和obj1.b的引用地址不同,所以修改obj1.b.c的值,obj3.b.c不会改变
      obj1 = { a: 0 , b: { c: 0}};
      let obj3 = JSON.parse(JSON.stringify(obj1));
      obj1.a = 4;
      obj1.b.c = 4;
      console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}
    }

    test();
3.合并对象:
    var o1 = { a: 1 };
    var o2 = { b: 2 };
    var o3 = { c: 3 };

    var obj = Object.assign(o1, o2, o3);
    console.log(obj); // { a: 1, b: 2, c: 3 }
    console.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。
4.合并具有相同属性的对象:(属性被后续参数中具有相同属性的其他对象覆盖。)
    var o1 = { a: 1, b: 1, c: 1 };
    var o2 = { b: 2, c: 2 };
    var o3 = { c: 3 };

    var obj = Object.assign({}, o1, o2, o3);
    console.log(obj); // { a: 1, b: 2, c: 3 }
5.拷贝 symbol 类型的属性:
    var o1 = { a: 1 };
    var o2 = { [Symbol(&apos;foo&apos;)]: 2 };

    var obj = Object.assign({}, o1, o2);
    console.log(obj); // { a : 1, [Symbol(&quot;foo&quot;)]: 2 } (cf. bug 1207182 on Firefox)
    Object.getOwnPropertySymbols(obj); // [Symbol(foo)]
6.继承属性和不可枚举属性是不能拷贝的:
    var obj = Object.create({foo: 1}, { // foo 是个继承属性。
        bar: {
            value: 2  // bar 是个不可枚举属性。
        },
        baz: {
            value: 3,
            enumerable: true  // baz 是个自身可枚举属性。
        }
    });

    var copy = Object.assign({}, obj);
    console.log(copy); // { baz: 3 }
7.原始类型会被包装为对象:
    var v1 = &quot;abc&quot;;
    var v2 = true;
    var v3 = 10;
    var v4 = Symbol(&quot;foo&quot;)

    var obj = Object.assign({}, v1, null, v2, undefined, v3, v4); 
    // 原始类型会被包装，null 和 undefined 会被忽略。
    // 注意，只有字符串的包装对象才可能有自身可枚举属性。
    console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }
8.异常会打断后续拷贝任务:
    var target = Object.defineProperty({}, &quot;foo&quot;, {
        value: 1,
        writable: false
    }); // target 的 foo 属性是个只读属性。

    Object.assign(target, {bar: 2}, {foo2: 3, foo: 3, foo3: 3}, {baz: 4});
    // TypeError: &quot;foo&quot; is read-only
    // 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。

    console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。
    console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。
    console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。
    console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。
    console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。
9.拷贝访问器:
var obj = {
  foo: 1,
  get bar() {
    return 2;
  }
};

var copy = Object.assign({}, obj); 
// { foo: 1, bar: 2 }
// copy.bar的值来自obj.bar的getter函数的返回值 
console.log(copy); 

// 下面这个函数会拷贝所有自有属性的属性描述符
function completeAssign(target, ...sources) {
  sources.forEach(source =&gt; {
    let descriptors = Object.keys(source).reduce((descriptors, key) =&gt; {
      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors;
    }, {});

    // Object.assign 默认也会拷贝可枚举的Symbols
    Object.getOwnPropertySymbols(source).forEach(sym =&gt; {
      let descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}

var copy = completeAssign({}, obj);
console.log(copy);
// { foo:1, get bar() { return 2 } }
</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">点击查看参考网址</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
